{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://langgithub.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-06-09T09:29:21.361Z","updated":"2020-06-09T09:29:21.361Z","comments":false,"path":"/404.html","permalink":"https://langgithub.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-09T09:29:21.397Z","updated":"2020-06-09T09:29:21.397Z","comments":false,"path":"about/index.html","permalink":"https://langgithub.github.io/about/index.html","excerpt":"","text":"本人毕业于四川文理学院。目前从事网络爬虫，Android逆向方面工作。除此之外也热爱数据分析，对房价，基金，股票有做一些数据爬虫抓取和建立模型分析"},{"title":"书单","date":"2020-06-09T09:29:21.397Z","updated":"2020-06-09T09:29:21.397Z","comments":false,"path":"books/index.html","permalink":"https://langgithub.github.io/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-08T07:36:05.000Z","updated":"2020-06-09T09:29:21.398Z","comments":true,"path":"categories/index.html","permalink":"https://langgithub.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-06-09T09:29:21.519Z","updated":"2020-06-09T09:29:21.519Z","comments":true,"path":"links/index.html","permalink":"https://langgithub.github.io/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2019-04-08T07:55:38.000Z","updated":"2020-06-09T09:29:21.519Z","comments":false,"path":"repository/index.html","permalink":"https://langgithub.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-08T07:43:28.000Z","updated":"2020-06-09T09:29:21.519Z","comments":true,"path":"tags/index.html","permalink":"https://langgithub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"scrapy-信号(5)","slug":"scrapy-信号(5)","date":"2020-08-21T03:48:48.301Z","updated":"2020-08-21T03:54:29.142Z","comments":true,"path":"2020/08/21/scrapy-信号(5)/","link":"","permalink":"https://langgithub.github.io/2020/08/21/scrapy-信号(5)/","excerpt":"","text":"scrapy-信号(5)General操作系统 single 操作系统信息即软中断，异步进行一些事件处理 信号总结 https://www.cnblogs.com/taobataoma/archive/2007/08/30/875743.html scrapy single解读 源码位置 ./python3.6/site-packages/scrapy/signalmanager.py 原理 通过from pydispatch import dispatcher来实现 信号总结","categories":[{"name":"爬虫-scrapy","slug":"爬虫-scrapy","permalink":"https://langgithub.github.io/categories/爬虫-scrapy/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://langgithub.github.io/tags/scrapy/"}]},{"title":"scrapy-scrapy如何循环(3)","slug":"scrapy-scrapy如何循环(3)","date":"2020-08-20T08:39:03.719Z","updated":"2020-08-21T02:07:59.481Z","comments":true,"path":"2020/08/20/scrapy-scrapy如何循环(3)/","link":"","permalink":"https://langgithub.github.io/2020/08/20/scrapy-scrapy如何循环(3)/","excerpt":"","text":"scrapy-scrapy如何循环 General Scrapy 轮询逻辑 _next_request_from_scheduler 1. Generalscrapy 循环核心是reactor 只的task.LoopingCall，并启动每隔slot.heartbeat.start(5) 5秒调度一次 2. Scrapy 轮询逻辑1234567891011121314151617181920212223242526272829def _next_request(self, spider): slot = self.slot if not slot: return if self.paused: return # 限制并发数的（如果request连接大于小于一个数，respons内容小于一个数）继续网络下载抓取 while not self._needs_backout(spider): # 1. 网络下载 if not self._next_request_from_scheduler(spider): break if slot.start_requests and not self._needs_backout(spider): try: # 2. 第一次启动调用自己写的start_requests request = next(slot.start_requests) except StopIteration: slot.start_requests = None except Exception: slot.start_requests = None logger.error(&apos;Error while obtaining start requests&apos;, exc_info=True, extra=&#123;&apos;spider&apos;: spider&#125;) else: self.crawl(request, spider) if self.spider_is_idle(spider) and slot.close_if_idle: # 3. 开启redis新的调度 self._spider_idle(spider) _next_request 相当于while true中的循环体 循环体中有3次集合用于获取种子 self._next_request_from_scheduler(spider) 第一处也是最重要的一处 request = next(slot.start_requests) 第二处获取种子，也就是自己重写的start_requests self._spider_idle(spider) 注册了signals.spider_idle 信号的，比如scrapy-redis 外层调度方式 self.crawler.engine.crawl 把种子传进来 self.heartbeat = task.LoopingCall(nextcall.schedule)，slot.heartbeat.start(5) 这才是循环的核心 3. _next_request_from_scheduler","categories":[{"name":"爬虫-scrapy","slug":"爬虫-scrapy","permalink":"https://langgithub.github.io/categories/爬虫-scrapy/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://langgithub.github.io/tags/scrapy/"}]},{"title":"scrapy-中间件源码分析(4)","slug":"scrapy-中间件源码分析(4)","date":"2020-08-19T08:41:59.462Z","updated":"2020-08-21T03:36:04.436Z","comments":true,"path":"2020/08/19/scrapy-中间件源码分析(4)/","link":"","permalink":"https://langgithub.github.io/2020/08/19/scrapy-中间件源码分析(4)/","excerpt":"","text":"scrapy-中间件源码分析(3) General MiddlewareManager（父） 2.1. MiddlewareManager 是中间件的抽象类，他的子类包括.以及代码中加载顺序 2.2. MiddlewareManager 初始化 2.3. 存储数据结构 ExtensionManager（子） 3.1. 首先看下程序启动时的打印代码 3.2. 扩展类中间件采用父类的加载 3.3. 中间件的key说明 DownloaderMiddlewareManager（子） 4.1. 首先看下程序启动时的打印代码 4.2. DownloaderMiddleware加载源码 4.3. 中间件的key说明 4.4. 调用方式 SpiderMiddlewareManager（子） 5.1. 首先看下程序启动时的打印代码 5.2. SpiderMiddleware加载源码 5.3. 中间件的key说明 5.4. 调用方式 ItemPipelineManager（子） 6.1. 首先看下程序启动时的打印代码 6.2. ItemPipeline加载源码 6.3. 中间件的key说明 6.4. 调用方式 1. General2. MiddlewareManager（父）2.1. MiddlewareManager 是中间件的抽象类，他的子类包括.以及代码中加载顺序 ExtensionManager 扩展中间件 1 DownloaderMiddlewareManager 下载中间件 2 SpiderMiddlewareManager 爬虫中间件 3 ItemPipelineManager pipline中间件 4 2.2. MiddlewareManager 初始化1234567def __init__(self, *middlewares): # 所有的中间件 self.middlewares = middlewares # 中间件存放的数据结构，map ,每一个map位是一个队列 self.methods = defaultdict(deque) for mw in middlewares: self._add_middleware(mw) 2.3. 存储数据结构 所有的中间件中重写的方法都会放在 self.methods = defaultdict(deque) 这个map map的key做了分类，详细见每个中间件的key解释 中间件的顺序是排好序后 append，appendleft 来实现 3. ExtensionManager（子）3.1. 首先看下程序启动时的打印代码1234562020-08-21 10:26:15 [scrapy.middleware] INFO: Enabled extensions:[&apos;scrapy.extensions.corestats.CoreStats&apos;, 核心统计收集器 &apos;scrapy.extensions.telnet.TelnetConsole&apos;, 监听控制台服务启动 &apos;scrapy.extensions.memusage.MemoryUsage&apos;, 监控内存做一些应急处理 &apos;scrapy.extensions.logstats.LogStats&apos;, 日志统计打印的 &apos;social_spider.middlewares.SpiderCallBackErrCount&apos;] 自定义收集器 3.2. 扩展类中间件采用父类的加载123456# 实际上扩展类中间件并没有保存到字典，直接在 from_crawler 中做处理，通过信号注册def _add_middleware(self, mw): if hasattr(mw, &apos;open_spider&apos;): self.methods[&apos;open_spider&apos;].append(mw.open_spider) if hasattr(mw, &apos;close_spider&apos;): self.methods[&apos;close_spider&apos;].appendleft(mw.close_spider) 3.3. 中间件的key说明 open_spiderclose_spider 4. DownloaderMiddlewareManager（子）4.1. 首先看下程序启动时的打印代码12345678910111213142020-08-21 10:29:00 [scrapy.middleware] INFO: Enabled downloader middlewares:[&apos;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&apos;, &apos;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&apos;, &apos;social_spider.middlewares.ProxyMiddleware&apos;, &apos;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&apos;, &apos;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&apos;, &apos;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&apos;, &apos;scrapy.downloadermiddlewares.retry.RetryMiddleware&apos;, &apos;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&apos;, &apos;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&apos;, &apos;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&apos;, &apos;social_spider.middlewares.StatMiddleware&apos;, &apos;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&apos;, &apos;scrapy.downloadermiddlewares.stats.DownloaderStats&apos;] 4.2. DownloaderMiddleware加载源码12345678# 重写函数，所有的 DOWNLOADER_MIDDLEWARES 都会保存到process_request，process_response，process_response， 看你重写了啥就保存啥def _add_middleware(self, mw): if hasattr(mw, &apos;process_request&apos;): self.methods[&apos;process_request&apos;].append(mw.process_request) if hasattr(mw, &apos;process_response&apos;): self.methods[&apos;process_response&apos;].appendleft(mw.process_response) if hasattr(mw, &apos;process_exception&apos;): self.methods[&apos;process_exception&apos;].appendleft(mw.process_exception) 4.3. 中间件的key说明 process_requestprocess_responseprocess_exception 4.4. 调用方式12345678910111213141516171819202122232425262728293031323334353637383940414243def download(self, download_func, request, spider): @defer.inlineCallbacks def process_request(request): for method in self.methods[&apos;process_request&apos;]: response = yield deferred_from_coro(method(request=request, spider=spider)) if response is not None and not isinstance(response, (Response, Request)): raise _InvalidOutput(&apos;Middleware %s.process_request must return None, Response or Request, got %s&apos; % \\ (method.__self__.__class__.__name__, response.__class__.__name__)) if response: defer.returnValue(response) defer.returnValue((yield download_func(request=request, spider=spider))) @defer.inlineCallbacks def process_response(response): assert response is not None, &apos;Received None in process_response&apos; if isinstance(response, Request): defer.returnValue(response) for method in self.methods[&apos;process_response&apos;]: response = yield deferred_from_coro(method(request=request, response=response, spider=spider)) if not isinstance(response, (Response, Request)): raise _InvalidOutput(&apos;Middleware %s.process_response must return Response or Request, got %s&apos; % \\ (method.__self__.__class__.__name__, type(response))) if isinstance(response, Request): defer.returnValue(response) defer.returnValue(response) @defer.inlineCallbacks def process_exception(_failure): exception = _failure.value for method in self.methods[&apos;process_exception&apos;]: response = yield deferred_from_coro(method(request=request, exception=exception, spider=spider)) if response is not None and not isinstance(response, (Response, Request)): raise _InvalidOutput(&apos;Middleware %s.process_exception must return None, Response or Request, got %s&apos; % \\ (method.__self__.__class__.__name__, type(response))) if response: defer.returnValue(response) defer.returnValue(_failure) deferred = mustbe_deferred(process_request, request) deferred.addErrback(process_exception) deferred.addCallback(process_response) return deferred 5. SpiderMiddlewareManager（子）5.1. 首先看下程序启动时的打印代码1234562020-08-21 10:37:21 [scrapy.middleware] INFO: Enabled spider middlewares:[&apos;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&apos;, &apos;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&apos;, &apos;scrapy.spidermiddlewares.referer.RefererMiddleware&apos;, &apos;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&apos;, &apos;scrapy.spidermiddlewares.depth.DepthMiddleware&apos;] 5.2. SpiderMiddleware加载源码12345678910def _add_middleware(self, mw): super(SpiderMiddlewareManager, self)._add_middleware(mw) if hasattr(mw, &apos;process_spider_input&apos;): self.methods[&apos;process_spider_input&apos;].append(mw.process_spider_input) if hasattr(mw, &apos;process_start_requests&apos;): self.methods[&apos;process_start_requests&apos;].appendleft(mw.process_start_requests) process_spider_output = getattr(mw, &apos;process_spider_output&apos;, None) self.methods[&apos;process_spider_output&apos;].appendleft(process_spider_output) process_spider_exception = getattr(mw, &apos;process_spider_exception&apos;, None) self.methods[&apos;process_spider_exception&apos;].appendleft(process_spider_exception) 5.3. 中间件的key说明 open_spiderclose_spiderprocess_spider_inputprocess_start_requestsprocess_spider_outputprocess_spider_exception 5.4. 调用方式12def process_start_requests(self, start_requests, spider): return self._process_chain(&apos;process_start_requests&apos;, start_requests, spider) 6. ItemPipelineManager（子）6.1. 首先看下程序启动时的打印代码122020-08-21 10:47:28 [scrapy.middleware] INFO: Enabled item pipelines:[&apos;social_spider.pipelines.PipelineKafka&apos;] 6.2. ItemPipeline加载源码1234def _add_middleware(self, pipe): super(ItemPipelineManager, self)._add_middleware(pipe) if hasattr(pipe, &apos;process_item&apos;): self.methods[&apos;process_item&apos;].append(deferred_f_from_coro_f(pipe.process_item)) 6.3. 中间件的key说明 open_spiderclose_spiderprocess_item 6.4. 调用方式12def process_item(self, item, spider): return self._process_chain(&apos;process_item&apos;, item, spider)","categories":[{"name":"爬虫-scrapy","slug":"爬虫-scrapy","permalink":"https://langgithub.github.io/categories/爬虫-scrapy/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://langgithub.github.io/tags/scrapy/"}]},{"title":"scrapy-twisted分析","slug":"scrapy-twisted分析(2)","date":"2020-08-18T07:42:13.247Z","updated":"2020-08-18T12:15:39.658Z","comments":true,"path":"2020/08/18/scrapy-twisted分析(2)/","link":"","permalink":"https://langgithub.github.io/2020/08/18/scrapy-twisted分析(2)/","excerpt":"","text":"scrapy-twisted分析 General twisted异步框架 2.1. reactor设计模式 2.2. Deferred延迟对象 2.3. @defer.inlineCallbacks的作用 1. Generalscrapy 底层采用异步网络框架twisted来实现的，这一章主要讲解reactor defferd defferList @defer.inlineCallbacks等一些列异步开发api在scrapy中的应用 2. twisted异步框架2.1. reactor设计模式暂时不做详细讲解，研究中 2.2. Deferred延迟对象API: https://twistedmatrix.com/documents/10.1.0/core/howto/defer.html Deferred 底层数据结构是[tuple()],如1234567891011121314151617181920def addCallbacks(self, callback, errback=None, callbackArgs=None, callbackKeywords=None, errbackArgs=None, errbackKeywords=None): &quot;&quot;&quot; Add a pair of callbacks (success and error) to this L&#123;Deferred&#125;. These will be executed when the &apos;master&apos; callback is run. @return: C&#123;self&#125;. @rtype: a L&#123;Deferred&#125; &quot;&quot;&quot; assert callable(callback) assert errback is None or callable(errback) cbs = ((callback, callbackArgs, callbackKeywords), (errback or (passthru), errbackArgs, errbackKeywords)) self.callbacks.append(cbs) if self.called: self._runCallbacks() return self addCallbacks是核心,向callbacks连表添加回调对象。addCallback-&gt;tuple(callback,passthru)，addErrback-&gt;(passthru,errback)，addBoth-&gt;(callback,errback)都会调用addCallbacks。只是addCallbacks中参数不一样.来看下_runCallbacks函数1234567891011121314151617181920212223242526272829303132# 核心逻辑def _runCallbacks(self): ...忽略... # 此处的self 是defferList连表 chain = [self] while chain: # 把list当作栈来使用 ，取出一个defferd对象 current = chain[-1] ...忽略... while current.callbacks: # 获取其中的callbacks 列表 item = current.callbacks.pop(0) callback, args, kw = item[ isinstance(current.result, failure.Failure)] args = args or () kw = kw or &#123;&#125; try: current._runningCallbacks = True try: # callback回调，传入上一次回调结果，保存当前结果 current.result = callback(current.result, *args, **kw) ...忽略... finally: current._runningCallbacks = False except: ...忽略... else: ...忽略... if finished: ...忽略... # defferd完成，移除[-1]最后一个对象 chain.pop() 2.3. @defer.inlineCallbacks的作用 @defer.inlineCallbacks封装成一个defferd对象然后返回，避免写defferd，callback。调用时启动生成器，判断返回内容是否是defferd对象，如果是继续递归调用当前方法123456789101112131415161718192021222324252627282930313233343536373839404142434445@failure._extraneousdef _inlineCallbacks(result, g, status): waiting = [True, # waiting for result? None] # result while 1: try: # Send the last result back as the result of the yield expression. isFailure = isinstance(result, failure.Failure) if isFailure: result = result.throwExceptionIntoGenerator(g) else: result = g.send(result) except StopIteration as e: # fell off the end, or &quot;return&quot; statement status.deferred.callback(getattr(e, &quot;value&quot;, None)) return except _DefGen_Return as e: ...忽略... except: status.deferred.errback() return # 如果是defferd对象，递归调用 if isinstance(result, Deferred): # a deferred was yielded, get the result. def gotResult(r): if waiting[0]: waiting[0] = False waiting[1] = r else: # We are not waiting for deferred result any more _inlineCallbacks(r, g, status) result.addBoth(gotResult) if waiting[0]: # Haven&apos;t called back yet, set flag so that we get reinvoked # and return from the loop waiting[0] = False status.waitingOn = result return result = waiting[1] waiting[0] = True waiting[1] = None","categories":[{"name":"爬虫-scrapy","slug":"爬虫-scrapy","permalink":"https://langgithub.github.io/categories/爬虫-scrapy/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://langgithub.github.io/tags/scrapy/"}]},{"title":"链表相关题","slug":"链表相关题","date":"2020-06-09T09:29:21.397Z","updated":"2020-06-09T09:29:21.397Z","comments":true,"path":"2020/06/09/链表相关题/","link":"","permalink":"https://langgithub.github.io/2020/06/09/链表相关题/","excerpt":"","text":"1.链表反转12345678910111213141516171819202122class Node(): def __init__(slef,data): self.next=None self.data=data# 方法一def reverse(head): if head.next is None: return head next=head.next head.next=None current_next=revers(next) next.next=head return current_next# 方法二def swap_reverse(head): cur,prev=head,None while cur: cur.next,prev,cur=prev,cur,cur.next return prev 两两交换链表中的节点12345678910111213141516# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head is None or head.next is None : return head next = head.next head.next=self.swapPairs(next.next) next.next=head return next 3.判断链表是否有环1234567891011121314151617181920212223242526272829303132# 正常思维item = set()class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; global item if head is None or head.next is None: return False a = item &amp; &#123;head&#125; if len(a) != 0: return True else: item.update(&#123;head&#125;) return self.hasCycle(head.next)# 龟兔赛跑class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; fast,slow=head,head while fast and fast.next and fast.next.next: slow,fast=slow.next,fast.next.next if slow==fast: return True return False 2.链表合并12345678910111213141516class Node(): def __init__(slef,data): self.next=None self.data=datadef merge(head1,head2): if head1 is None: return head2 if head2 is None: return head1 if head1.data&lt;=head2.data: head1.next=merge(head1.next,head2) return head1 else: head2.next=merger(head1,head2.next) return head2","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://langgithub.github.io/tags/算法/"}]},{"title":"贪心算法","slug":"贪心算法","date":"2020-06-09T09:29:21.396Z","updated":"2020-06-09T09:29:21.396Z","comments":true,"path":"2020/06/09/贪心算法/","link":"","permalink":"https://langgithub.github.io/2020/06/09/贪心算法/","excerpt":"","text":"贪心算法 所有贪心算法题移步动态规划","categories":[{"name":"算法-数据结构","slug":"算法-数据结构","permalink":"https://langgithub.github.io/categories/算法-数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://langgithub.github.io/tags/数据结构/"}]},{"title":"计算机网络原理","slug":"计算机网络原理","date":"2020-06-09T09:29:21.396Z","updated":"2020-06-09T09:29:21.396Z","comments":true,"path":"2020/06/09/计算机网络原理/","link":"","permalink":"https://langgithub.github.io/2020/06/09/计算机网络原理/","excerpt":"","text":"计算机网络原理 物理层（比特传输）集线器 1.1 通讯方式单工，半双工，全双工 数据链路层（交换机） 2.1 解决问题封装成帧 透明传输 差错检测 2.2 信道分类广播信道 （CSMA/CD协议）{多点接入，载波监听，碰撞检测} =》2T 点对点信道 （ppp协议）PPP 协议是用户计算机和 ISP进行通信时所使用的数据链路层协议。 2.3 信道复用技术频分复用 时分复用 统计时分复用 波分复用 码分复用 网络层 3.1 网络分类 3.2 相关协议ARP （mac地址解析协议 ip-mac） ICMP IGMP IP 3.3 路由分组转发 传输层 4.1 UDP与TCP 4.2 TCP三次握手 4.3 TCP四次挥手 4.4 TCP滑动窗口 应用层 DNS 53 FTP 20 21 smtp 25 发送 pop3 imap 读取 telnet 23 http 80","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"https://langgithub.github.io/tags/计算机网络原理/"}]},{"title":"递归算法","slug":"递归算法","date":"2020-06-09T09:29:21.396Z","updated":"2020-06-09T09:29:21.396Z","comments":true,"path":"2020/06/09/递归算法/","link":"","permalink":"https://langgithub.github.io/2020/06/09/递归算法/","excerpt":"","text":"实现pow函数 (分治递归)1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): &quot;&quot;&quot; :type x: float :type n: int :rtype: float &quot;&quot;&quot; if n&lt;0: return 1/self.my_pow(x,-n) else: return self.my_pow(x,n) def my_pow(self,x,y): if y==0: return 1 if y==1: return x if y%2==0: n=y/2 return self.my_pow(x, n)*self.my_pow(x, n) else: n=(y-1)/2 return self.my_pow(x, n) * self.my_pow(x, n)*x 括号生成 （递归，树的深度遍历，剪枝）1234567891011121314151617class Solution(object): def generateParenthesis(self, n): &quot;&quot;&quot; :type n: int :rtype: List[str] &quot;&quot;&quot; self.res=[] self._gen(&quot;&quot;,n,n) return self.res def _gen(self,s_kuo,left,right): if left==0 and right==0: self.res.append(s_kuo) if left&gt;0: self._gen(s_kuo+&quot;(&quot;,left-1,right) if right&gt;left: self._gen(s_kuo+&quot;)&quot;,left,right-1) 八皇后问题123456789101112131415161718class Solution(object): def solveNQueens(self, n): &quot;&quot;&quot; 坐标逆时针旋转90度理解p+q ,p-q :type n: int :rtype: List[List[str]] &quot;&quot;&quot; def DFS(cols,pie,na): p=len(cols) if p&gt;=n: result.append(cols) return None for q in range(n): if q not in cols and p-q not in pie and p+q not in na: DFS(cols+[q],pie+[p-q],na+[p+q]) result=[] DFS([],[],[]) return [[ &apos;.&apos;*i+&apos;Q&apos;+&apos;.&apos;*(n-1-i) for i in cols] for cols in result]","categories":[{"name":"算法-数据结构","slug":"算法-数据结构","permalink":"https://langgithub.github.io/categories/算法-数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://langgithub.github.io/tags/数据结构/"}]},{"title":"逆向-ARM指令","slug":"逆向-ARM指令","date":"2020-06-09T09:29:21.396Z","updated":"2020-06-09T09:29:21.396Z","comments":true,"path":"2020/06/09/逆向-ARM指令/","link":"","permalink":"https://langgithub.github.io/2020/06/09/逆向-ARM指令/","excerpt":"","text":"ARM指令用户模式 不分组寄存器（R0-R7） 分组寄存器（R8-R14） 程序计数器pc（R15） 状态寄存器CPSR ARM处理器 ARM状态（32位对齐指令的ARM指令） Thumb状态（16位对齐指令的Thump指令） ARM指令集 跳转指令 B 无条件跳转 BL 带链接的无条件跳转 BX 带状态切换的无条件跳转 BLX 带链接和状态的无条件跳转 B loc_地址 BNE 不相等跳转地址；BEQ 相等跳转地址 存储器和寄存器交互数据指令 存储器（主存，内存） 寄存器中的数据（字符串，数，地址，各种类型数据） LDR 从存储器中加载数据到寄存器 &lt;- load LDR R8,[R9,#04] R8为寄存器，加载值为R9+#04所指向的存储单元 STR 将寄存器的数据加载到存储器 -&gt; store STR R8,[R9,#04] 将R8寄存器中数据存储到R9+#04所指向的存储单元 LDM 将存储器的数据加载到一个寄存器列表 -&gt; LDM R0, {R1-R3} 将R0指向的存储单元的数据依次加载到R1,R2,R3寄存器 STM 将一个寄存器列表的数据存储到指定存储器 &lt;- PUSH 将寄存器值推入堆栈 POP 将堆栈的值推出到寄存器 SWP 将寄存器与存储器之间的数据进行交换 SWP R1，R1 [R0] 将R1寄存器与R0指向存储单元内容进行交换 数据传送指令 MOV 立即数或寄存器的数据数据传送到目标寄存器 MOV R0,#8 R0=#8 数据算术运算指令 ADD,SUB,MUL,DIV 有符号，无符号运算，带进位运算 数据逻辑运算指令 与 ADD 或 ORR 异或 EOR LSL 逻辑左移 LSR 逻辑右移 LSL R0，R1，#2 R0=R1*2 比较指令 CMP CMP R0 #0 R0寄存器中值与0比较 标志位 其他指令 伪处理器指令 SWT （切换用户模式） 伪指令 DCB 寄存器寻址指令 7种，常见的5种 立即寻址 MOV R0,#1234 寄存器寻址 MOV R0 , R1 寄存器移位寻址 MOV R0, R1,LSL #2 R0=R1*4 寄存器间接寻址 LDR R0 ,[R1] R1寄存器值作为地址赋R0 寄存器间接基址偏移寻址 LDR R0,[R1,#-4]将R1寄存家的值-0x4作为地址，取出地址中的值赋R0 ARM 指令收集 —SUB指令— 123减法指令SUB (SUBtract) 格式: SUB A,B //A=A-B;功能: 两个操作数的相减,即从A中减去B,其结果放在A中. —CMP指令— 123比较指令CMP格式: CMP A,B // A-B;功能: 两个操作数的相减,即从A中减去B，其结果会影响标志位， 对标志位的影响与SUB指令相同。本条指令主要是用于配合条件转移指令使用。如JZ ZF=0时，跳转 —条件转移指令 JE/JZ— 12345格式: JE/JZ标号 //等于跳转功能: ZF＝1,转到指定地址执行说明:1. 指令JE与JZ等价,它们是根据标志位ZF进行转移的指令2. JE,JZ均为一条指令的两种助记符表示方法 —str指令— 1234567格式:str&#123;条件&#125; 源寄存器，&lt;存储器地址&gt;功能:将源寄存器中数据存到存储器地址中 说明:str r1,[r2] ; 将r1中的值存到r2所指定的地址中str r1,[r2,#4] ;将r1中的值存到r2+4所指定的地址中str r1,[r2],#4 ;将r1中的值存到r2所指定的地址中, 同时r2=r2+4 —LDR LDM指令— 12345678910111213141516171819202122232425A.LDR加载指令 从右往左格式为:LDR&#123;条件&#125; 目的寄存器，&lt;存储器地址&gt;功能:LDR指令用亍从存储器中将一个32位的字数据传送到目的寄存器中说明：ldr r0，[r1] ；将存储器地址为R1的字数据读入寄存器R0。ldr r0，[r1，r2] ；将存储器地址为R1+R2的字数据读入寄存器R0。ldr r0，[r1，＃8] ；将存储器地址为R1+8的字数据读入寄存器R0。ldr r0，[r1，r2]！ ；将存储器地址为R1+R2的字数据读入寄存器R0,幵将新地址R1＋R2写入R1。ldr r0，[r1，＃8]！ ；将存储器地址为R1+8的字数据读入寄存器R0，幵将新地址R1＋8写入R1。 ldr r0，[r1]，r2 ；将存储器地址为R1的字数据读入寄存器R0，幵将新地址R1＋R2写入R1。ldr r0，[r1，r2，lsl＃2]！ ；将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。ldr r0，[r1]，r2，lsL＃2 ；将存储器地址为R1的字数据读入寄存器R0，幵将新地址R1＋R2×4写入R1。”B.伪指令格式:LDR&#123;条件&#125; 目的寄存器，&lt;存储器地址&gt;功能:说明:将COUNT的值赋给R0LDR R1,=COUNTLDR R0,[R1]LDR R1,=COUNT这条伪指令，是怎样完成将COUNT的地址赋给R1，有兴趣的可以看它编译后的结果。这条指令实际上会编译成一条LDR指令和一条DCD伪指令。B.LDM记载指令从左往右 —B,BL,BX,BLX 指令— 123456789101112131415161718192021A.B跳转指令格式:B addr功能:跳转指令B使程序跳转到指定的地址执行程序。说明:B 0x1234 ;跳转到绝对地址0x1234处。B.BL带返回的连接跳转格式:功能:BL指令用于实现子程序调用。子程序的返回可通过将LR寄存器的值复制到PC寄存器来实现。下面的指令可实现子程序返回：(1)、BX R14 (2)、MOV PC,R14说明:BL func ;跳转到子程序func处执行，同时将当前pc值保存到LR中。C.BX跳转并切换状态格式:BX&#123;&lt;cond&gt;&#125; &lt;Rm&gt;功能:带状态切换的跳转指令BX使程序跳转到指令中指定的参数Rm指定的地址执行程序。若 Rm 的 bit[0] 为1，切换到 Thumb 指令执行；若 Rm 的 bit[0] 为0，切换到 ARM 指令执行。说明:BX R0 ;跳转到R0中的地址，如果R0[0]=1，则进入Thumb状态。D.BLX带返回的跳转并切换状态格式:功能:该指令为无条件执行指令 —BEQ BNE指令— 1234567a.BEQ指令格式: BEQ 功能: 相等跳转b.BNE指令格式: BNE功能: 不想等跳转 ——-.w—— 1代表32位 ——CHP—— 1比较指令","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://langgithub.github.io/tags/ARM/"}]},{"title":"scrapy-项目介绍(1)","slug":"scrapy-项目介绍(1)","date":"2020-06-09T09:29:21.395Z","updated":"2020-08-18T07:41:32.249Z","comments":true,"path":"2020/06/09/scrapy-项目介绍(1)/","link":"","permalink":"https://langgithub.github.io/2020/06/09/scrapy-项目介绍(1)/","excerpt":"","text":"scrapy项目介绍 General 项目基本使用 scrapy整体介绍 3.1. scrapy组件 3.2. scrapy组件总结 scrapy启动 4.1. Crawler-命令执行入口 4.2. Crawler.crawl 分析 4.3. ExecutionEngine.open_spider分析 总结 1. General scrapy是底层采用twsited基于事件驱动模型的通讯框架来实现，包含Engine，Scheduler，Spider，Downloader，Pipline五大部分组成 2. 项目基本使用1234api: https://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.htmlscrapy startproject doubanmoviecd doubanmoviescrapy genspider movie duoban.com 3. scrapy整体介绍 3.1. scrapy组件 Spiders -&gt; 用户自己编写的爬虫脚本，可自定义抓取意图 pipline -&gt; 负责输出结构化数据，可自定义输出位置 Scheduler -&gt; 负责管理任务、过滤任务、输出任务的调度器，存储、去重任务都在此控制 Downloader -&gt; 下载器，负责在网络上下载网页数据，输入待下载URL，输出下载结果 Scrapy Engine -&gt; 核心引擎，负责控制和调度各个组件，保证数据流转 Downloader middlewares -&gt; 介于引擎和下载器之间，可以在网页在下载前、后进行逻辑处理 Spider middlewares -&gt; 介于引擎和爬虫之间，可以在调用爬虫输入下载结果和输出请求/数据时进行逻辑 3.2. scrapy组件总结 scrapy Engine启动调度Scheduler获取url种子 Engine将种子传递给download下载返回response Engine将response传递给spider解析 Engine将解析回来的scrapy Item传递给pipline其中在2中种子传递用Downloader middlewares进一步封装。 4. scrapy启动4.1. Crawler-命令执行入口 位于./python3.6/site-packages/scrapy/commands/crawl.py 中Command(ScrapyCommand) 是对scrapy命令解析执行. 调用逻辑run-&gt;self.crawler_process.crawl(spname, **opts.spargs)-&gt;self.crawler_process.start()。我们来看下crawler_process，该对象是在./python3.6/site-packages/scrapy/cmdline.py 中144行创建cmd.crawler_process = CrawlerProcess(settings) 接着看CrawlerProcess, 这理解之前先看下CrawlerProcess CrawlerRunner Crawler 三者的关系；首先从这里 class CrawlerProcess(CrawlerRunner) 看出CrawlerProcess继承CrawlerRunner，CrawlerRunner中的_create_crawler可以创建Crawler对象。而Crawler对象是加载全局配置文件Setting.py和爬虫文件的。 总结：./python3.6/site-packages/scrapy/commands/crawl.py 是解析scrapy命令的，第一步self.crawler_process.crawl(spname, **opts.spargs) 返回延迟对象，等待reactor轮询。第二部self.crawler_process.start() 启动轮询 1234567891011121314# CrawlerProcess函数说明class CrawlerProcess(CrawlerRunner): # 操作系统信号量回调函数注册（也就是ctrl+c 后调用的函数） def __init__(self, settings=None, install_root_handler=True):... # 信号量回调函数，ctrl+c结束当前进程，优雅的退出进程 def _signal_shutdown(self, signum, _):... # 如果一次ctrl+c没有退出，则会触发当前操作，强制退出 def _signal_kill(self, signum, _):... # 进程启动(thradpool配置，操作系统事件注册) def start(self, stop_after_crawl=True):... # 优雅退出，将退出添加到callback调用链条 def _graceful_stop_reactor(self):... # 强制退出，直接退出reactor.stop() def _stop_reactor(self, _=None):... 4.2. Crawler.crawl 分析12345678910111213141516171819202122@defer.inlineCallbacksdef crawl(self, *args, **kwargs): assert not self.crawling, &quot;Crawling already taking place&quot; self.crawling = True try: # 加载自己写的Spieder self.spider = self._create_spider(*args, **kwargs) # 加载 ExecutionEngine 引擎 self.engine = self._create_engine() # 自己写的start_requests会被执行，没有就走父类默认的start_requests # 位于./python3.6/site-packages/scrapy/spiders/__init__.py start_requests = iter(self.spider.start_requests()) # 启动引擎 yield self.engine.open_spider(self.spider, start_requests) # 启动接受控制台命令 yield defer.maybeDeferred(self.engine.start) except Exception: self.crawling = False if self.engine is not None: yield self.engine.close() raise 4.3. ExecutionEngine.open_spider分析12345678910111213141516171819202122232425@defer.inlineCallbacksdef open_spider(self, spider, start_requests=(), close_if_idle=True): assert self.has_capacity(), &quot;No free spider slot when opening %r&quot; % \\ spider.name logger.info(&quot;Spider opened&quot;, extra=&#123;&apos;spider&apos;: spider&#125;) # 调度要在下一个reactor循环中调用的函数，但前提是该函数自上次运行以来尚未被调度 nextcall = CallLaterOnce(self._next_request, spider) # 调度器加载 scheduler = self.scheduler_cls.from_crawler(self.crawler) # 中间件处理MiddleWare start_requests = yield self.scraper.spidermw.process_start_requests(start_requests, spider) # engine核心 slot = Slot(start_requests, close_if_idle, nextcall, scheduler) self.slot = slot self.spider = spider # 打开调度器 yield scheduler.open(spider) yield self.scraper.open_spider(spider) self.crawler.stats.open_spider(spider) # 发送信号，spider可以启动了 yield self.signals.send_catch_log_deferred(signals.spider_opened, spider=spider) # reactor调度开始 slot.nextcall.schedule() # 官网解释：Start running function every interval seconds. 也即是nextcall.schedule slot.heartbeat.start(5) 5. 总结 看完以上代码流程，心中肯定会有如下一些疑问？ @defer.inlineCallbacks 的作用是什么？reactor又是如何异步轮询？ self.scraper.spidermw.process_start_requests 中间件是如何加载起作用的？ yield self.signals.send_catch_log_deferred 的运作原理是什么，究竟是如何启动爬虫的？ scheduler 调度器倒是如何被调度的？ scrapy middelware 又是如何起作用的？","categories":[{"name":"爬虫-scrapy","slug":"爬虫-scrapy","permalink":"https://langgithub.github.io/categories/爬虫-scrapy/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://langgithub.github.io/tags/scrapy/"}]},{"title":"简单图形验证码","slug":"简单图形验证码","date":"2020-06-09T09:29:21.395Z","updated":"2020-06-09T09:29:21.395Z","comments":true,"path":"2020/06/09/简单图形验证码/","link":"","permalink":"https://langgithub.github.io/2020/06/09/简单图形验证码/","excerpt":"","text":"MAC1234# 准备1. brew install tesseract2. pip install pytesseract3. 去往https://github.com/tesseract-ocr/tessdata下载中文数据集chi_sim.traineddata，把它放到这目录下： /usr/local/Cellar/tesseract/3.05.01/share/tessdata 使用：1234567import pytesseractfrom PIL import Image# open imageimage = Image.open(&apos;test.png&apos;)code = pytesseract.image_to_string(image, lang=&apos;chi_sim&apos;)print(code) 总结：验证码处理步骤 灰度化 二值化（涉及到找阀值 类间方差） 去干扰线 降噪 （高斯降噪） 切割 识别","categories":[{"name":"爬虫-js逆向","slug":"爬虫-js逆向","permalink":"https://langgithub.github.io/categories/爬虫-js逆向/"}],"tags":[{"name":"简单图形验证码","slug":"简单图形验证码","permalink":"https://langgithub.github.io/tags/简单图形验证码/"}]},{"title":"自动化测试对比","slug":"自动化测试对比","date":"2020-06-09T09:29:21.395Z","updated":"2020-06-09T09:29:21.396Z","comments":true,"path":"2020/06/09/自动化测试对比/","link":"","permalink":"https://langgithub.github.io/2020/06/09/自动化测试对比/","excerpt":"","text":"自动化对比 模块 UIAutomation appium selenium pyppeteer 终极武器(chrome-devtools-protocol) 跨平台 否 Android，ios 是 chrome 浏览器就行 是 缺点 无法跨平台 adb驱动 太强大 chrome 协议 底层 driver google原生 UIAutomation #很多 chrome all #很多： selenium可支持的PC浏览器驱动包括： safari driver【包含在selenium server中】 ie driver chrome driver 【第三方】 opera driver【第三方] selenium可支持的伪浏览器驱动： PhantomJS Driver【第三方,停止更新】 HtmlUnit Driver【包含在selenium server中】 selenium可支持的移动端驱动： Windows Phone driver Selendroid-Selenium for Android【第三方】 ios-driver【第三方】 Appium 支持iphone、ipad、android、FirefoxOS【第三方】 驱动代码 UIAutomation 1234567891011121314151617python 端安装 uiautomator2 client：pip install uiautomator2Android端安装 ATX server安装方法离线 将init_machine.sh,及android_package.zip上传至/data/local/tmp目录下 给手机安装termux，此为命令行工具，打开软件 输入su,切换至管理员账户 输入cd data/local/tmp,因为云手机不能打/符，所有用tab键来凑齐。 输入sh init_machine.sh,即可安装好软件和服务 usb线连 在电脑上输入python -m uiautomator2 init即可 ### 2、打开ATX 打开ATX 点击&quot;启动uiautomator&quot; ### 3、打开QpythonL 一定要先打开这个软件，不然你python脚本会上传不成功 12345678910111213141516171819202122232425262728293031323334353637import uiautomator2 as u2# 0.0.0.0 为本机，127.0.0.1这个也行，这个连接是在手机上运行的d = u2.connect(&apos;http://0.0.0.0:7912&apos;)# 如果远程操作，就填入手机ATX显示的ip，下面有图# d = u2.connect(&apos;http://172.17.2.237:7912&apos;)# 字符串为包名，下面有获取包名教程sess = d.session(&quot;com.tencent.wework&quot;)def my_click(sess, ele, timeout=3): ele.wait(timeout=timeout) # 等待超时，因为可能此时界面动画，或者反映迟钝，该控件还没出现 x, y = ele.center() # 找到该空间的中间坐标 sess.touch.down(x, y) # 在此坐标按下 time.sleep(0.3) sess.touch.up() #等待3秒后抬起def click_search_btn(sess): ele = sess(resourceId=package_name+&quot;:id/e3g&quot;, #找到该空间的id className=&quot;android.widget.TextView&quot;,# 找到该空间的类名 instance=0) #如果根据属性查找有多个控件，则找第一个 my_click(sess, ele, 20)click_search_btn(sess)print(&apos;begin to input&apos;)ele = sess(resourceId=&quot;com.tencent.wework:id/dpu&quot;, className=&quot;android.widget.EditText&quot;)ele.set_text(phone) # 将手机号填入print(&apos;end to input&apos;)time.sleep(2)# print(u&quot;点击搜索&quot;)# 点击搜索sess(resourceId=&quot;com.tencent.wework:id/azq&quot;, className=&quot;android.widget.RelativeLayout&quot;).child(className=&quot;android.widget.TextView&quot;).click() # 因为该控件没有id，所以先找它爹，再找它爹的儿子控件，.click()直接触发点击事件。ele1 = sess(resourceId=&quot;com.tencent.wework:id/sa&quot;, className=&quot;android.widget.TextView&quot;)ele1.get_text() # 获取标签文本内容 Seleinum 1234安装：pip install selenium自行下载需要驱动的driver：如chromedriver实用executable_path 引入driver路径 1234567891011121314151617181920212223242526272829303132333435from selenium import webdriverimport time drivers = [&apos;HtmlUnit&apos;, &apos;PhantomJS&apos;, &apos;Chrome&apos;, &apos;FF&apos;, &apos;IE&apos;] dervers_time = &#123; &apos;HtmlUnit&apos; : 0, &apos;PhantomJS&apos; : 0, &apos;Chrome&apos; : 0, &apos;FF&apos; : 0, &apos;IE&apos; : 0,&#125;times = 50def run_with_Chrome(): common_step(webdriver.Chrome()) def run_with_FF(): common_step(webdriver.Firefox()) def run_with_IE(): common_step(webdriver.Ie()) def run_with_PhantomJS(): common_step(webdriver.PhantomJS(executable_path=r&apos;C:\\Python27\\Scripts\\phantomjs.exe&apos;)) def run_with_HtmlUnit(): driver = webdriver.Remote(&quot;http://localhost:4444/wd/hub&quot;, desired_capabilities=webdriver.DesiredCapabilities.HTMLUNIT) common_step(driver) def common_step(driver): driver.get(&apos;http://www.baidu.com&apos;) ele = driver.find_element_by_id(&apos;su&apos;) print ele.get_attribute(&apos;value&apos;) driver.quit() Appium 123456789101112131415161718191.node.js 安装brew install nodenpm install -g appium # get appium npm install wd # get appium client直接用npm下载往往不成功，这是需要通过代理来下载具体方法如下：npm i cnpm -g --registry=http://registry.npm.taobao.orgcnpm i appium -g # get appiumcnpm i wd -g # get appium clientcnpm i appium-doctor # get appium-doctor2.检查Appium成功安装appium-doctor更具提示配置 xcode 和 Android SDK3.下载appium客户端更加方便地址 github4.python client 安装 pip install Appium_Python_Client5.启动appium server .用客户端appium 启动即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# encoding: utf-8&quot;&quot;&quot;--------------------------------------@describe 自动化微信添加好友@version: 1.0@project: operator_spider@file: app_chrome.py@author: yuanlang @time: 2019-02-19 10:14---------------------------------------&quot;&quot;&quot;import unittestfrom time import sleepfrom appium import webdriverclass MyTestCase(unittest.TestCase): def setUp(self): capabilities = &#123; &apos;platformName&apos;: &apos;Android&apos;, &apos;platformVersion&apos;: &quot;5.1&quot;, &apos;deviceName&apos;: &quot;mx4&quot;, &apos;appPackage&apos;: &apos;com.tencent.mm&apos;, &apos;appActivity&apos;: &apos;.ui.LauncherUI&apos;, &apos;automationName&apos;: &apos;Uiautomator2&apos;, &apos;unicodeKeyboard&apos;: True, &apos;resetKeyboard&apos;: True, &apos;noReset&apos;: True, &apos;chromeOptions&apos;: &#123;&apos;androidProcess&apos;: &apos;com.tencent.mm:tools&apos;&#125;, &#125; self.driver = webdriver.Remote(&quot;http://127.0.0.1:4723/wd/hub&quot;, capabilities) self.driver.implicitly_wait(30) sleep(5) def test_chromeApp(self): # 点击加号 print(&quot;search&quot;) driver = self.driver el1 = driver.find_element_by_id(&quot;com.tencent.mm:id/gd&quot;) el1.click() sleep(5) el2 = driver.find_element_by_xpath( &quot;/hierarchy/android.widget.FrameLayout/android.widget.ListView/android.widget.LinearLayout[2]/android.widget.LinearLayout/android.widget.TextView&quot;) el2.click() sleep(5) el3 = driver.find_element_by_id(&quot;com.tencent.mm:id/hx&quot;) el3.click() sleep(5) driver.find_element_by_id(&quot;com.tencent.mm:id/hx&quot;).send_keys(&quot;15775691981&quot;) sleep(5) driver.find_element_by_id(&quot;com.tencent.mm:id/l4&quot;).click() sleep(5) print(driver.context) name = driver.find_element_by_id(&quot;com.tencent.mm:id/ang&quot;).text print(name) def tearDown(self): self.driver.close_app() self.driver.quit()if __name__ == &apos;__main__&apos;: unittest.main() pyppeteer12345原生是node.js 开发基于chrome-devtools-protocol + websocketpython也有对应改写版项目由google维护pip install pyppeteer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# encoding: utf-8&quot;&quot;&quot;--------------------------------------@describe @version: 1.0@project: operator_spider@file: dddd.py@author: yuanlang @time: 2019-02-21 19:11---------------------------------------&quot;&quot;&quot;import asyncioimport pyppeteerfrom collections import namedtupleResponse = namedtuple(&quot;rs&quot;, &quot;title url html cookies headers history status&quot;)async def get_html(url, timeout=30): # 默认30s #,executablePath=&quot;&quot; browser = await pyppeteer.launch(headless=False, args=[&apos;--no-sandbox&apos;]) page = await browser.newPage() js=&quot;&quot;&quot; function sniffDetector() &#123; const userAgent = window.navigator.userAgent; const platform = window.navigator.platform; window.navigator.__defineGetter__(&apos;userAgent&apos;, function() &#123; window.navigator.sniffed = true; return userAgent; &#125;); window.navigator.__defineGetter__(&apos;platform&apos;, function() &#123; window.navigator.sniffed = true; return platform; &#125;); //自动化反反爬虫，反自动化检测 Object.defineProperty(navigator, &apos;webdriver&apos;, &#123; get: () =&gt; false, &#125;); &#125; &quot;&quot;&quot; await page.evaluateOnNewDocument(js) res = await page.goto(url, options=&#123;&apos;timeout&apos;: int(timeout * 1000)&#125;) await asyncio.sleep(5) data = await page.content() title = await page.title() resp_cookies = await page.cookies() resp_headers = res.headers resp_history = None resp_status = res.status response = Response(title=title, url=url, html=data, cookies=resp_cookies, headers=resp_headers, history=resp_history, status=resp_status) return responseif __name__ == &apos;__main__&apos;: url_list = [&quot;https://jx.ac.10086.cn&quot;] task = (get_html(url) for url in url_list) loop = asyncio.get_event_loop() results = loop.run_until_complete(asyncio.gather(*task)) for res in results: print(res) chrome-devtools-protocol1234底层采用websocket 协议控制浏览器。[协议连接](https://chromedevtools.github.io/devtools-protocol/)安装1.pip install pychrom2./Chromium --remote-debugging-port=9222 1234567891011121314151617181920import pychromebrowser = pychrome.Browser(url=&quot;http://127.0.0.1:9222&quot;)tab = browser.new_tab()def request_will_be_sent(**kwargs): print(&quot;loading: %s&quot; % kwargs.get(&apos;request&apos;).get(&apos;url&apos;))tab.set_listener(&quot;Network.requestWillBeSent&quot;, request_will_be_sent)tab.start()tab.call_method(&quot;Network.enable&quot;)tab.call_method(&quot;Page.navigate&quot;, url=&quot;https://jx.ac.10086.cn&quot;, _timeout=5)import time# print(&quot;ok&quot;)time.sleep(5)result=tab.call_method(&quot;Runtime.evaluate&quot;,expression=&quot;document.documentElement.outerHTML&quot;)print(result)tab.stop() 自动化反反爬虫123Object.defineProperty(navigator, &apos;webdriver&apos;, &#123; get: () =&gt; false,&#125;); 12345678910111213141516171819202122232425262728293031323334&apos;&apos;&apos;// overwrite the `languages` property to use a custom getterObject.defineProperty(navigator, &quot;languages&quot;, &#123; get: function() &#123; return [&quot;zh-CN&quot;,&quot;zh&quot;,&quot;zh-TW&quot;,&quot;en-US&quot;,&quot;en&quot;]; &#125;&#125;);// Overwrite the `plugins` property to use a custom getter.Object.defineProperty(navigator, &apos;plugins&apos;, &#123; get: () =&gt; [1, 2, 3, 4, 5],&#125;);// Pass the Webdriver testObject.defineProperty(navigator, &apos;webdriver&apos;, &#123; get: () =&gt; false,&#125;);// Pass the Chrome Test.// We can mock this in as much depth as we need for the test.window.navigator.chrome = &#123; runtime: &#123;&#125;, // etc.&#125;;// Pass the Permissions Test.const originalQuery = window.navigator.permissions.query;window.navigator.permissions.query = (parameters) =&gt; ( parameters.name === &apos;notifications&apos; ? Promise.resolve(&#123; state: Notification.permission &#125;) : originalQuery(parameters));&apos;&apos;&apos; 12345678910111213# 修改chromedriver$ hexedit chromedriver # 操作 1. tab 跳转到string栏 2. ctrl+S 查找 var key = &apos;$cdc_asdjflasutopfhvcZLmcfl_&apos;（对于2.40版本） 3. 替换&apos;$cdc_asdjflasutopfhvcZLmcfl_&apos;为任意值 4. ctrl+X 保存# 移动chromedriver 到 /usr/bin$ mv chromedriver /usr/bin[详细连接](&quot;https://zhuanlan.zhihu.com/p/43581988?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=32546582691840&amp;from=groupmessage&quot;) 总结：seleium 是采用webdriver 协议 ,seleium server端也是使用chrome-devtools-protocol。只不过为了跨平台采用webdriver restful api 形式开发。chrome-devtools-protocol 可以使用 ./chromium –remote-debug 自动化测试","categories":[{"name":"爬虫-玄学","slug":"爬虫-玄学","permalink":"https://langgithub.github.io/categories/爬虫-玄学/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"https://langgithub.github.io/tags/自动化/"}]},{"title":"爬虫-engine","slug":"爬虫-engine","date":"2020-06-09T09:29:21.395Z","updated":"2020-06-09T09:29:21.395Z","comments":true,"path":"2020/06/09/爬虫-engine/","link":"","permalink":"https://langgithub.github.io/2020/06/09/爬虫-engine/","excerpt":"","text":"爬虫engine 线程池如何实现engine ayncio如何实现engine 线程池engine实现1234567891011121314151617181920212223242526272829303132333435363738import timeimport threadingfrom queue import Queuequeue=Queue()headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&apos;&#125;base_path=&quot;archives&quot;class WorkThread(threading.Thread): def __init__(self,name,queue): threading.Thread.__init__(self) self.name=name self.queue=queue def run(self): while True: url,file_img_path=self.queue.get() print(f&quot;fetch url==&gt;&#123;url&#125; path==&gt;&#123;file_img_path&#125;&quot;) self.download(url,file_img_path) if queue.empty(): print(f&quot;任务做完，&#123;self.name&#125; 休息中&quot;) time.sleep(2) def download(self,img_url,file_img_path): img_response = requests.get(img_url, headers=headers) with open(file_img_path, &quot;wb&quot;) as f: f.write(img_response.content) def engine(): global queue thread_pool=[] for i in range(10): t = WorkThread(f&quot;Thread &#123;i&#125;&quot;,queue) t.start() thread_pool.append(t)","categories":[{"name":"爬虫-玄学","slug":"爬虫-玄学","permalink":"https://langgithub.github.io/categories/爬虫-玄学/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://langgithub.github.io/tags/爬虫/"}]},{"title":"爬虫日志收集（flume+kafka+elk）","slug":"爬虫日志收集（flume+kafka+elk）","date":"2020-06-09T09:29:21.395Z","updated":"2020-06-09T09:29:21.395Z","comments":true,"path":"2020/06/09/爬虫日志收集（flume+kafka+elk）/","link":"","permalink":"https://langgithub.github.io/2020/06/09/爬虫日志收集（flume+kafka+elk）/","excerpt":"","text":"（一）flume1.61.1 flume配置（将日志上传到HDFS离线分析和kafka实时分析）a1.sources = r1 a1.sinks = k2 k1 a1.channels = c2 c1 Describe/configure the sourcea1.sources.r1.type = exec a1.sources.r1.command=tail -n +0 -f /usr/lang/log.log a1.sources.r1.channels = c1 a1.sources.r1.channels = c2 Describe the sinka1.sinks.k1.type = hdfs a1.sinks.k1.channel = c1 a1.sinks.k1.hdfs.path = hdfs://lang:8020/user/flume a1.sinks.k1.hdfs.filePrefix = events- a1.sinks.k1.hdfs.round = true a1.sinks.k1.hdfs.roundValue = 10 a1.sinks.k1.hdfs.roundUnit = minute a1.sinks.k2.channel=c2 a1.sinks.k2.type=org.apache.flume.sink.kafka.KafkaSink a1.sinks.k2.topic=lang a1.sinks.k2.brokerList=node1:9092 a1.sinks.k2.requiredAcks=1 a1.sinks.k2.batchSize=20 Use a channel which buffers events in memorya1.channels.c1.type = memory a1.channels.c1.capacity = 1000 a1.channels.c1.transactionCapacity = 100 a1.channels.c2.type = memory a1.channels.c2.capacity = 1000 a1.channels.c2.transactionCapacity = 100 1.2 flume启动bin/flume-ng agent -c conf -f conf/flume-conf -n a1 -Dflume.root.logger=DEBUG,console （二）kafka 0.11集群2.1重要配置文件server.properties: broker.id=0 (根据实际主机，分配0,1,2) listeners=PLAINTEXT://:9092 zookeeper.connect=192.168.205.11:2181,192.168.205.12:2181,192.168.205.13:2181 producer.properties bootstrap.servers=192.168.205.11:9092,192.168.205.12:9092,192.168.205.13:9092 consumer.properties zookeeper.connect=192.168.205.11:2181,192.168.205.12:2181,192.168.205.13:2181 2.2同步配置文件2.3相关命令先启动zookeeper 启动kafka bin/kafka-server-start.sh config/server.properties &amp; 停止kafka bin/kafka-server-stop.sh 创建topic bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic lang 展示topic bin/kafka-topics.sh –list –zookeeper localhost:2181 描述topic bin/kafka-topics.sh –describe –zookeeper localhost:2181 –topic lang 生产者： bin/kafka-console-producer.sh –broker-list node1:9092 –topic lang 消费者： bin/kafka-console-consumer.sh -bootstrap-server localhost:9092 –topic lang –from-beginning 删除topic: bin/kafka-topics.sh –delete –zookeeper 130.51.23.95:2181 –topic topicname (三)logstash5.5.13.1配置（文件输入，es输出）input { file { path =&gt; [“/usr/lang/log.log”] start_position =&gt; “beginning” } } filter { date { match =&gt; [ “timestamp” , “YYYY-MM-dd HH:mm:ss” ] } } output { elasticsearch { hosts =&gt; [“192.168.205.14:9200”] } stdout { codec =&gt; rubydebug } } 3.2配置（kafka输入，es输出）input { kafka { #workers =&gt;2 bootstrap_servers =&gt; “node1:9092,node2:9092,node3:9092” #zookeeper地址 topics =&gt; “lang” #kafka中topic名称，记得创建该topic #group_id =&gt; “logstash” #默认为“logstash” #consumer_threads =&gt;2 #消费的线程数 #reset_beginning =&gt; false #reset_beginning=&gt;true #decorate_events =&gt; true #在输出消息的时候回输出自身的信息，包括：消费消息的大小、topic来源以及consumer的group信息。 #type =&gt; “nginx-access-log” } } filter { date { match =&gt; [ “timestamp” , “YYYY-MM-dd HH:mm:ss” ] } } output { elasticsearch { hosts =&gt; [“192.168.205.14:9200”] #index =&gt; “kafakindex-%{+YYYY.MM.dd}” } stdout { codec =&gt; rubydebug } } （四）elasticsearch4.1内存配置 config/jvm.properties4.2配置文件 config/elsticsearchcluster.name: my-application node.name: node-1(集群中名称不一样) network.host: 192.168.205.14 http.port: 9200 bootstrap.system_call_filter: false http.cors.enabled: true http.cors.allow-origin: “*” 4.3注意事项：Java内存参数，配置文件中空格问题4.4elasticsearch-head（索引UI管理界面）（五）kibana没啥，直接启动 有问题直接联系我 QQ：1146941596 参考资料 1.elk安装（参照官网） http://blog.csdn.net/onlylove_longshao/article/details/72765696 2.注意点：操作系统内存2G，系统某些参数配置 3.elasticsearch-head 安装 http://blog.csdn.net/napoay/article/details/53896348","categories":[{"name":"数据存储-bigdata","slug":"数据存储-bigdata","permalink":"https://langgithub.github.io/categories/数据存储-bigdata/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://langgithub.github.io/tags/hadoop/"}]},{"title":"滑块验证码","slug":"滑块验证码","date":"2020-06-09T09:29:21.394Z","updated":"2020-06-09T09:29:21.394Z","comments":true,"path":"2020/06/09/滑块验证码/","link":"","permalink":"https://langgithub.github.io/2020/06/09/滑块验证码/","excerpt":"","text":"滑块验证码破解方式一 数据发包1234如zhongguorenshou.py,思路1.请求背景图片2.两张图片滑动距离（有的需要图片还原）3.更具滑动距离模拟生成鼠标滑动参数和时间 方式二 driver1234567ru industry.py基于selenium+phantomjs 原理1.phantomjs 是一款基于浏览器内核软件2.通过selenium模拟人为操作3.缺点：和浏览器操作一样，慢4.优势：不用模拟鼠标滑动，易过调 方式三 收集滑动轨迹，存放到数据库1231.请求背景图片2.两张图片滑动距离（有的需要图片还原）3.采用js hook 方式手机滑动轨迹 目录介绍v1 是老版本工商滑块 （无法使用了）v2 通过发包的方式过滑块 （滑块跟新块，基本不考虑，无法使用）v3 推荐使用滑块方式 more: v3介绍亮点一：v3中的滑动距离计算，采用计算两张图片差值进行灰度化，在二值化（采用类间方差）亮点二：轨迹生成方面采用算法更高效 介绍js hook1234567891011121314//目标hook函数startRecord//添加自己的日志代码orig = window.startRecord;window.startRecord=function(str)&#123; orig(str); console.log(&apos;-----------typeMouse------------&apos;); console.log(typeMouse); console.log(&apos;-----------pageXAxis------------&apos;); console.log(pageXAxis); console.log(&apos;-----------pageYAxis------------&apos;); console.log(pageYAxis); console.log(&apos;-----------mouseTime------------&apos;); console.log(mouseTime)&#125; 注：个人博客 https://langgithub.github.io/","categories":[{"name":"爬虫-js逆向","slug":"爬虫-js逆向","permalink":"https://langgithub.github.io/categories/爬虫-js逆向/"}],"tags":[{"name":"滑块验证码","slug":"滑块验证码","permalink":"https://langgithub.github.io/tags/滑块验证码/"}]},{"title":"机器学习案例","slug":"机器学习案例","date":"2020-06-09T09:29:21.394Z","updated":"2020-06-09T09:29:21.394Z","comments":true,"path":"2020/06/09/机器学习案例/","link":"","permalink":"https://langgithub.github.io/2020/06/09/机器学习案例/","excerpt":"","text":"1.泰坦尼克号预测 https://blog.csdn.net/han_xiaoyang/article/details/497971432.房屋估计预测 https://github.com/xiaoyusmd/Bj_HousePricePredict/blob/master/%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E4%B8%8E%E5%88%86%E6%9E%90.ipynb","categories":[{"name":"算法-机器学习","slug":"算法-机器学习","permalink":"https://langgithub.github.io/categories/算法-机器学习/"}],"tags":[{"name":"案例","slug":"案例","permalink":"https://langgithub.github.io/tags/案例/"}]},{"title":"极客算法课","slug":"极客算法课","date":"2020-06-09T09:29:21.394Z","updated":"2020-06-09T09:29:21.394Z","comments":true,"path":"2020/06/09/极客算法课/","link":"","permalink":"https://langgithub.github.io/2020/06/09/极客算法课/","excerpt":"","text":"leetcode 刷题网站https://leetcode-cn.com 算法题 githubhttps://github.com/CyC2018 LUR cache (最近最少使用替换)123```# Bloom Fillter 存在的元素存在误识别率，不存在肯定不存在 对于错误率修正 对存在的元素再再数据库中查询一遍 挡掉不存在元素，存在元素再数据库中搜索 ` # priority Queue 一个任务的密度=重要程度/完成时间 kelly formula 凯利公式 game theory 博弈论 #","categories":[{"name":"算法-数据结构","slug":"算法-数据结构","permalink":"https://langgithub.github.io/categories/算法-数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://langgithub.github.io/tags/数据结构/"}]},{"title":"树相关题","slug":"树相关题","date":"2020-06-09T09:29:21.394Z","updated":"2020-06-09T09:29:21.394Z","comments":true,"path":"2020/06/09/树相关题/","link":"","permalink":"https://langgithub.github.io/2020/06/09/树相关题/","excerpt":"","text":"1. 判断是否二叉搜索树12345678910111213141516171819202122232425# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: node_list=[] return_flag=True def isValidBST(self, root: TreeNode) -&gt; bool: self.in_order(root) return self.return_flag def in_order(self,root): if root is None: return self.isValidBST(root.left) if not self.node_list or self.node_list[-1]&lt;root.val: self.node_list.append(root.val) else: self.node_list.append(root.val) self.return_flag= False return self.isValidBST(root.right) 2. 二叉树的最近公共祖先1234567891011121314151617class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if root == None or root.val ==q or root.val==p : return root left = self.lowestCommonAncestor(root.left,p,q) right= self.lowestCommonAncestor(root.right,p,q) if left is None: return right elif right is None: return left else: return root.val 3. 二叉树广度优先遍历 BFS123456789101112131415161718def BFS(root): q=[] q.append(root) num=[] while q: size=len(q) current_num=[] for i in range(size): root=q.pop(0) current_num.append(root.data) if root.left_child is not None: q.append(root.left_child) if root.right_child is not None: q.append(root.right_child) num.append(current_num) return num 4. 二叉树深度优先遍历 DFS123456def DFS(root): if root is None: return print(root.data) if root.left_child is not None: DFS(root.left_child) if root.right_child is not None: DFS(root.right_child) 1.二叉树 构建二叉查找树 先序遍历 中序遍历 后序遍历 构建平衡二叉树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class TreeNode(): def __init__(self,x): self.left_child=None self.right_child=None self.data=xclass Tree(): def __init__(self,x): self.tree_data=[] self.root=None def insert(self,root,x): &quot;&quot;&quot; 构造二叉查找树 &quot;&quot;&quot; if root is None: return TreeNode(x) if root.data &gt; x: root.left_child=self.insert(root.left_child,x) else: root.right_child=self.insert(root.right_child,x) return root def preorder(slef,root): “”“ 先序遍历 ”“” if not root : return self.tree_data.append(root.data) self.preorder(root.left_child) self.preorder(root.right_child) def inorder(slef,root): “”“ 中序遍历 ”“” if not root : return self.inorder(root.left_child) self.tree_data.append(root.data) self.inorder(root.right_child) def postorder(slef,root): “”“ 后序遍历 ”“” if not root : return self.postorder(root.left_child) self.postorder(root.right_child) self.tree_data.append(root.data) def insert2(self,root,x): &quot;&quot;&quot; 构建平衡二叉树 &quot;&quot;&quot; if root is None: return TreeNode(x) tree_node=[root] wile True: node=tree_node.pop(0) if node.left_child is None: node.left_child=TreeNode(x) return root elif node.right_child is None: node.right_child=TreeNode(x) return root else: tree_node.append(node.left_child) tree_node.append(node.right_child) 2.树的子节点(判断是不是一颗树的子树)1234567891011121314def subTree(root,sub_root): if root is None or sub_root is None: return false return isSubTree(root,sub_root) || subTree(root.left,sub_root) || subTree(root.right,sub_root)def isSubTree(root,sub_root): if sub_root is None: return True if root is None: return False if root.data!= sub_root.data: return False return isSubTree(root.left,sub_root.left) and isSubTree(root.right,sub_root.right) 3.二叉树的镜像123456789def mirror(root) if root is None: return swap(root) mirror(root.left) mirror(root.right)def swap(root) root.left,root.right=root.right,root.left 4.判处是否是对称二叉树12345678910111213def subTree(root): if root is None: return false return isSubTree(root.eft,root.right)def isSubTree(root,sub_root): if sub_root is None: return True if root is None: return False if root.data!= sub_root.data: return False return isSubTree(root.left,sub_root.left) and isSubTree(root.right,sub_root.right)","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://langgithub.github.io/tags/算法/"}]},{"title":"机器学习—路线图","slug":"机器学习—路线图","date":"2020-06-09T09:29:21.394Z","updated":"2020-06-09T09:29:21.394Z","comments":true,"path":"2020/06/09/机器学习—路线图/","link":"","permalink":"https://langgithub.github.io/2020/06/09/机器学习—路线图/","excerpt":"","text":"机器学习数据处理步骤： 机器学习基础与实践（一）—-数据清洗机器学习基础与实践（二）—-数据转换机器学习基础与实践（三）—-数据降维之PCA基本机器学习算法推导：决策树：https://blog.csdn.net/yen_csdn/article/details/79012871KNN分类：http://www.cnblogs.com/bahcelor/p/7239997.htmlSVM:https://blog.csdn.net/zxllll8898/article/details/53404484神经网络：https://www.cnblogs.com/bahcelor/p/7252394.htmlK-means：https://blog.csdn.net/loveliuzz/article/details/78052711卷积神经网络：https://www.cnblogs.com/skyfsm/p/6790245.html 深度学习推导：零基础入门深度学习(1) - 感知器零基础入门深度学习(2) - 线性单元和梯度下降零基础入门深度学习(3) - 神经网络和反向传播算法零基础入门深度学习(4) - 卷积神经网络零基础入门深度学习(5) - 循环神经网络零基础入门深度学习(6) - 长短时记忆网络(LSTM)零基础入门深度学习(7) - 递归神经网络 难点：pca降维推导：https://www.cnblogs.com/tbiiann/p/6259459.htmlsvd分解推导：https://www.cnblogs.com/tbiiann/p/6262397.html机器学习中的距离：https://www.cnblogs.com/tbiiann/p/5968784.html最小二乘法法推导：https://www.cnblogs.com/paiandlu/p/7843236.htmlsvm手推：https://blog.csdn.net/v_july_v/article/details/7624837kkt条件解释：https://www.cnblogs.com/liaohuiqiang/p/7805954.htmlgbdt：https://blog.csdn.net/lyzmyy/article/details/45665105?utm_source=blogxgwz3或者 https://blog.csdn.net/v_july_v/article/details/40718799","categories":[{"name":"算法-机器学习","slug":"算法-机器学习","permalink":"https://langgithub.github.io/categories/算法-机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://langgithub.github.io/tags/机器学习/"}]},{"title":"源码刷机-环境搭建（ubuntu 14.04.5 编译Android 4.4.4 r1源码）","slug":"源码刷机-环境搭建（ubuntu 14.04.5 编译Android 源码）","date":"2020-06-09T09:29:21.394Z","updated":"2020-06-09T09:29:21.394Z","comments":true,"path":"2020/06/09/源码刷机-环境搭建（ubuntu 14.04.5 编译Android 源码）/","link":"","permalink":"https://langgithub.github.io/2020/06/09/源码刷机-环境搭建（ubuntu 14.04.5 编译Android 源码）/","excerpt":"","text":"Android刷机步骤 jdk安装 ubuntu环境配置 android源码下载 驱动下载 编译 刷入手机 源码阅读 一·JDK安装编译Android4.x的源码是不能用OpenJDK，需要用Oracle JDK 1.6，Oracle JDK 1.7目前是不支持的；编译Android 5.x版本以后的源码不再能使用Oracle JDK，需要使用OpenJDK 7版本。从下载页 http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html#jdk-6u45-oth-JPR下载Linux x64bit版本Oracle JDK 1.60_45. 解压 123cd /home/androidcode/AndroidDevlopsudo chmod u+x jdk-6u45-linux-x64.binsudo ./jdk-6u45-linux-x64.bin 环境变量 12345678910sudo gedit /etc/profile# 添加java环境变量export JAVA_HOME=/home/androidcode/AndroidDevlop/jdk1.6.0_45export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport PATH=$PATH:$&#123;JAVA_HOME&#125;/binexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libsource /etc/profilejavac 二.ubuntu环境配置 ssh配置 参考博客：linux免密钥登陆 编译环境配置 123456$ sudo apt-get update$ sudo apt-get install git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dri:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 dpkg-dev $ sudo ln -s /usr/lib/i386-linux-gnu/mesa/libGL.so.1 /usr/lib/i386-linux-gnu/libGL.so# 注：遇到问题参考 http://www.voidcn.com/article/p-fxftmkft-bpy.html 我遇到的安装错误 1234567#libcheese7$ sudo apt-get remove libcheese-gtk23 libcheese7$ sudo apt-get install libcheese-gtk23 libcheese7#g++$ sudo apt-get install g++$ sudo apt-get install g++-multilib 三.android源码下载 安装repo 1234567891011$ git config --global user.name &quot;lang&quot;$ git config --global user.email &quot;lang@gmail.com&quot;# 下载repo 脚本 (一个依赖python2.7 文件下载脚步。可以换网址)$ mkdir android$ cd android$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repo$ chmod a+x repo# 替换源repo脚步中的源# REPO_URL = &apos;https://aosp.tuna.tsinghua.edu.cn/git-repo&apos; android源码下载 123$ repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-4.4.4_r1$ repo sync 涉及问题 repo脚步获取需要翻墙，也可以用国内源代替 也可以从百度云下载源码 http://pan.baidu.com/s/1ngsZs 四.驱动下载1234在https://developers.google.com/android/drivers#hammerheadktu84p 下载对应版本驱动 这里是 KTU84P，下载文件有如下，移动到Android源码解压后运行里面 .sh 生成vendor文件夹1. lge-hammerhead-ktu84p-49419c39.tgz2. qcom-hammerhead-ktu84p-f159eadf.tgz3. broadcom-hammerhead-ktu84p-5a5bf60e.tgz 五.编译12345678# 初始化环境$ source build/envsetup.sh# 选择编译版本$ lunch 7 # 编译性能参数 8=电脑核心数*2$ make -j8 六.刷入手机12345# 连接电脑$ sudo adb reboot bootloader# 查看手机状态 如果没有，查看fastboot 权限$ fastboot devices $ fastboot -w flashall 七.源码阅读123456第一步，这行命令的意思是编译idegen这个项目，生成idegen.jar文件。$ mmm development/tools/idegen/如果你看到了绿色的 #### make completed successfully ####，说明这步是ok的。第二步，这行命令的意思是生成:android.iws, android.ipr, android.iml这个三个文件。$ sh ./development/tools/idegen/idegen.sh第三步, as 导入 android.ipr","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"Android刷机","slug":"Android刷机","permalink":"https://langgithub.github.io/tags/Android刷机/"}]},{"title":"机器学习—数学基础二（线性代数）","slug":"机器学习—数学基础二（线性代数）","date":"2020-06-09T09:29:21.393Z","updated":"2020-06-09T09:29:21.393Z","comments":true,"path":"2020/06/09/机器学习—数学基础二（线性代数）/","link":"","permalink":"https://langgithub.github.io/2020/06/09/机器学习—数学基础二（线性代数）/","excerpt":"","text":"1.矩阵的行几何意义：行构成的方程有解 2.矩阵列的几何意义：列构成的向量求和 3. https://blog.csdn.net/u010182633/article/details/52335565基组成子空间=最大的线性无关组 4.四个空间 5.四个空间关系图 6.矩阵的分解 学会求解： a. https://jingyan.baidu.com/article/9989c746d5af17f648ecfefd.html","categories":[{"name":"算法-机器学习","slug":"算法-机器学习","permalink":"https://langgithub.github.io/categories/算法-机器学习/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://langgithub.github.io/tags/线性代数/"}]},{"title":"机器学习—数学知识点清单","slug":"机器学习—数学知识点清单","date":"2020-06-09T09:29:21.393Z","updated":"2020-06-09T09:29:21.393Z","comments":true,"path":"2020/06/09/机器学习—数学知识点清单/","link":"","permalink":"https://langgithub.github.io/2020/06/09/机器学习—数学知识点清单/","excerpt":"","text":"深度学习数学知识点清单根据原文：机器学习数学篇—基础数学知识清单 进行修改和补充 说明：字体加粗表示该知识点很重要，需要重点掌握 一. 线性代数 向量 矩阵 集合 标量 张量 范数 内积 向量正交 正交基 特征值分解 奇异值分解 矩阵分解 总结:前面的都是基础概念性的内容，后面的三个分解很重要，奇异值分解也属于矩阵分解里的一种，在很多应用中其实都会用到，譬如推荐系统，主题模型等。在一些其他的算法思想里其实也有用到，我们求特征向量的时候，其实也是在做特征值分解，主成分分析/因子分析 其实都用到了矩阵分解。尤其是当数据量比较小的时候，可以先不上深度学习，先用简单又基础的方法试一下，看看效果怎么样，作为baseline，加大数据集后，再采取更深层次的算法来做。 二. 概率论 条件概率 联合概率 全概率公式 逆概率 贝叶斯公式 贝叶斯定理 先验概率 后验概率 似然概率 最大似然估计法 最大后验概率法 离散型随机变量 连续型随机变量 概率质量函数 概率密度函数 两点分布 二项分布 泊松分布 均匀分布 指数分布 正态分布 数字特征 数学期望 方差 协方差 总结:概率论的内容也非常重要，掌握好了才能理解我们在机器学习/深度学习里经常出现的一些概念。它包含在我们算法的很多方面，譬如，数据是否符合正态分布/泊松分布，什么情况下可以用最大似然估计法等等，贝叶斯的定理除了运用在贝叶斯算法中，还有没有其他的算法有运用到这个思想的，条件概率个联合概率等，在后续的信息论出现的作用是什么？都需要我们队每个知识点好好掌握。重点掌握我加粗的知识点。 三. 数理统计 样本 总体 统计量 参数估计 假设检验 置信区间 区间估计 泛化能力 泛化误差 欠拟合 过拟合 噪声 偏差 总结:同样，前面是基础知识，后面的几点更为关键。泛化能力和泛化误差是我们衡量这个模型跑完了能否拿到实际场景中去应用的一个重要指标;欠拟合 or 过拟合 也是我们在模型训练的过程中需要注意和解决的两点;偏差方差等也属于评价指标，我们需要达到一个trade-off，所以如何平衡也是需要关注的。其实也可以这样看，如果数据中出现了噪音，迭代次数过少（或者一些其他原因），导致模型欠拟合，那么它的偏差大，方差小，如果过拟合，则偏差小，方差大，不管哪种情况，这个模型的泛化能力都不行，没法拿到真实场景中去用，所以我们需要对其进行调整，这个时候我们就会关注到数据本身和模型调参上。数据本身如果有噪音和异常点应该如何找到并去除，模型跳槽应该如何避免欠拟合和过拟合，都是我们在掌握这些知识点时需要重点关注的点。 四. 优化相关 目标函数 全局最小值 局部极小值 无约束优化 约束优化 拉格朗日函数 KKT条件与对偶函数 梯度下降法 一阶导数 二阶导数 牛顿法 泰勒展开 线性搜索方法 置信域方法 启发式算法 总结:优化部分的内容也是非常重要的一环。当我们设定了目标函数后，就会采取各种优化算法来去优化目标函数的值，使目标函数的值最小(/最大，一般是最小，根据具体情况而定)，如何使目标函数的值下降的最快，这时我们就引出了梯度下降，因为沿着负梯度下降的方向是函数值减小的最快方向，由此我们可以引出多种梯度下降的方法，包括批梯度，随机梯度，mini-batch等等。当然，这是针对一阶函数优化来说的，如果是二阶函数，我们就会考虑到用牛顿法，什么时候会出现二阶函数呢？在xgboost里针对目标函数的优化我们就会涉及到二阶函数的优化。而在这些优化函数的计算中，都会涉及到泰勒展开，在SVM里又会因为要求支持向量所以会引出拉格朗日乘子法和KKT条件，从一点去发散，我们可以发现很多知识点。所以在针对具体的算法学习过程中再去掌握这些数学知识点，高效而且有用。在深度学习中涉及到的优化算法相对就少一些，没有机器学习里的那么多，但是这些基础性的东西还是需要掌握的。 五.信息论 信息熵 互信息 信息增益 KL 散度 最大熵原理 交叉熵和相对熵的对比 各种熵之间的关系 总结：信息论这一章非常重要，基本上每个知识点都是重点，因为很多情况下我们都会使用交叉熵作为损失函数，所以得弄明白它的原理和为什么我们经常使用它做损失函数的原因。对于一些特殊的情况，可以做出哪些变型，也是在掌握了这些基础上才会做的，所以大家要好好掌握。","categories":[{"name":"算法-机器学习","slug":"算法-机器学习","permalink":"https://langgithub.github.io/categories/算法-机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://langgithub.github.io/tags/机器学习/"}]},{"title":"机器学习—特征工程","slug":"机器学习—特征工程","date":"2020-06-09T09:29:21.393Z","updated":"2020-06-09T09:29:21.394Z","comments":true,"path":"2020/06/09/机器学习—特征工程/","link":"","permalink":"https://langgithub.github.io/2020/06/09/机器学习—特征工程/","excerpt":"","text":"详细pdf:链接：https://pan.baidu.com/s/1pUWhb_y7kK7_fU0Gjqfe0Q 密码：602lsklearn中的特征工程：https://www.cnblogs.com/jasonfreak/p/5619260.html 特征工程实则是数据深度清洗过程 1.数据清洗 a. 数据格式化（日期，数值格式化）b. 脏数据清洗（不合理数据）c. 缺失值处理方案 方案一 : 如果缺失值的样本占总数比例行高，可直接舍弃该字段，反倒成为噪声 方案二 : 如果缺失值的样本占总数比例适中，且该字段是离散型值，将缺失值作为新的一类 方案三：如果缺失值的样本占总数比例适中，且该字段是连续型数值，将数值离散化处理，将缺失值作为新的一类 方案四: 如果缺失值得样本占总数比例较少，可根据已有的值，拟合一定的数据补充上 2.数据采样 . 采样方式 1.随机采样 2.分层采样. 正负样本不平衡处理办法 1.上采样（量大） 2.下采样（量小） 3.特征处理1.数值型 类别型 时间型 文本型 统计型 组合类型 4.特征选择 过滤型包裹型嵌入型","categories":[{"name":"算法-机器学习","slug":"算法-机器学习","permalink":"https://langgithub.github.io/categories/算法-机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://langgithub.github.io/tags/机器学习/"}]},{"title":"机器学习—数学基础一（统计学与概率论）","slug":"机器学习—数学基础一（统计学与概率论）","date":"2020-06-09T09:29:21.393Z","updated":"2020-06-09T09:29:21.393Z","comments":true,"path":"2020/06/09/机器学习—数学基础一（统计学与概率论）/","link":"","permalink":"https://langgithub.github.io/2020/06/09/机器学习—数学基础一（统计学与概率论）/","excerpt":"","text":"注：随机变量分离散型随机变量和非离散型随机变量，非离散型随机变量中只讨论连续型随机变量 ### 条件概率，全概率，贝叶斯三者关系 二项分布 泊松分布 概率分布 正态分布","categories":[{"name":"算法-机器学习","slug":"算法-机器学习","permalink":"https://langgithub.github.io/categories/算法-机器学习/"}],"tags":[{"name":"统计","slug":"统计","permalink":"https://langgithub.github.io/tags/统计/"}]},{"title":"操作系统","slug":"操作系统","date":"2020-06-09T09:29:21.392Z","updated":"2020-06-09T09:29:21.392Z","comments":true,"path":"2020/06/09/操作系统/","link":"","permalink":"https://langgithub.github.io/2020/06/09/操作系统/","excerpt":"","text":"操作系统四大特点1. 并发 2. 共享 3. 虚拟 4. 异步 操作系统基本功能1. 进程管理 1.1 进程：cpu资源分配的基本单位。主要构成进程控制快（PCB），创建撤销进程都是对PCB的操作 1.2 线程：cpu调度的基本单位。一个进程包含多个线程 1.3 进程状态切换 就绪 运行 阻塞 1.4 进程调度算法 批处理系统（先来先服务，短作业有限，最短剩余时间优先） 交互式系统 （时间片轮转，优先级调度，多级反馈） 实时系统 1.5 进程同步 临界区 同步与互斥 信号量 管程 1.6 生产者与消费者 1.7 哲学家就餐（死锁） 预分配 互斥 占有且申请 不可抢占 循环等待 2. 文件管理 文件读写，保护 3. 内存管理 （内存分配，映射） 3.1 页面置换算法 3.2 分段 3.3 分页 4. 设备管理 完成用户io请求，方便用户使用设备 生产者与消费者1234567891011121314151617181920212223242526272829303132333435363738394041#no1. 协程方式def product(): shop=0 while shop&lt;5: shop=shop+1 print(&quot;生产了一个商品shop:&quot;+str(shop)) yield shopdef constorm(t): try: while True: shop=t.send(None) print(&quot;消费了一个商品:&quot;+str(shop)) except StopIteration as e: pass#no2. 多线程import threadingfrom queue import Queuedef product(que: Queue): while True: shop=&quot;new shop&quot; que.put(shop) print(&quot;procuce :&quot;+shop)def constorm(que: Queue): while True: shop=que.get() print(&quot;消费了一个商品:&quot;+shop)que=Queue(maxsize=5)t1=threading.Thread(target=product,args=(que,))t2=threading.Thread(target=product,args=(que,))t1.start()t2.start()t3=threading.Thread(target=constorm,args=(que,))t4=threading.Thread(target=constorm,args=(que,))t3.start()t4.start() 死锁1234567891011121314151617181920212223242526272829303132333435363738import threadingimport timelock1=threading.Lock()lock2=threading.Lock()def people1(): while True: lock1.acquire() print(&quot;people1 拿到左边筷子&quot;) time.sleep(1) lock2.acquire() print(&quot;people1 拿到右边筷子&quot;) lock2.release() lock1.release() print(&quot;people 吃完了放筷子&quot;)def people2(): while True: lock2.acquire() print(&quot;people2 拿到右边筷子&quot;) time.sleep(1) lock1.acquire() print(&quot;people2 拿到左边筷子&quot;) lock1.release() lock2.release() print(&quot;people 吃完了放筷子&quot;)t1=threading.Thread(target=people1)t2=threading.Thread(target=people2)t1.start()t2.start()","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://langgithub.github.io/tags/操作系统/"}]},{"title":"手机群控","slug":"手机群控","date":"2020-06-09T09:29:21.392Z","updated":"2020-06-09T09:29:21.392Z","comments":true,"path":"2020/06/09/手机群控/","link":"","permalink":"https://langgithub.github.io/2020/06/09/手机群控/","excerpt":"","text":"手机群控github项目浏览 项目 地址 原理 weiqunkong https://github.com/zhongxia245/weiqunkong Java Swing+ddmlib （adb通信）+Android录屏 pc-android-controller-pc https://github.com/kaixuanluo/-pc-android-controller-pc Java Swing+ddmlib （adb通信）+Android录屏 AndroidControl https://github.com/imharryzhu/AndroidControl spring web+usb连接（上传安装minicap，minitouch） openstf https://github.com/langgithub/stf nodejs web+usb连接（上传安装minicap，minitouch） atx-server https://github.com/openatx/atx-server go web+wifi（上传安装minicap，minitouch）","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"手机群控","slug":"手机群控","permalink":"https://langgithub.github.io/tags/手机群控/"}]},{"title":"并查集算法","slug":"并查集数据结构","date":"2020-06-09T09:29:21.392Z","updated":"2020-06-09T09:29:21.392Z","comments":true,"path":"2020/06/09/并查集数据结构/","link":"","permalink":"https://langgithub.github.io/2020/06/09/并查集数据结构/","excerpt":"","text":"并查集 优化一（将高的tree作为root,降低树的高度） 优化二 (递归路径压缩) 解题思路12341. find union 代码不变2. self.count 代表需要合并的节点（岛屿，朋友）对角矩阵问题节点只有一般3. self.parent 代表初始化节点树，若是二维数组非对角矩阵问题需降纬4. 寻找需要合并的条件 岛屿数量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class UnionSet(): def __init__(self,grid): m, n = len(grid), len(grid[0]) # 代表需要合并的节点（岛屿，朋友） self.count=0 self.parent=[] # 将二维数组降纬 for i in range(m): for j in range(n): if grid[i][j]==&apos;1&apos;: self.count+=1 self.parent.append(i*n+j) # 树的秩，也就是高度。初始化数量与节点树相同 self.rank=[0 for i in range(m*n)] def find(self,x): if self.parent[x]!=x: self.parent[x]=self.find(self.parent[x]) return self.parent[x] def union(self,x,y): rootx=self.find(x) rooty=self.find(y) if rootx!=rooty: if self.rank[rootx]&lt;self.rank[rooty]: self.parent[rootx]=rooty self.rank[rootx]+=1 elif self.rank[rootx]&gt;self.rank[rooty]: self.parent[rooty]=rootx self.rank[rooty]+=1 else: self.parent[rooty]=rootx self.rank[rooty]+=1 self.count-=1class Solution(): def numIslands(self,grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) direction=[(1,0),(-1,0),(0,1),(0,-1)] us=UnionSet(grid) for i in range(m): for j in range(n): if grid[i][j]==&apos;0&apos;: continue for d in direction: nc,nr=i+d[0],j+d[1] if nc&gt;=0 and nr&gt;=0 and nc &lt;m and nr &lt;n and grid[nc][nr]==&quot;1&quot;: us.union(i*n+j,nc*n+nr) return us.count 朋友圈个数123456789101112131415161718192021222324252627282930313233343536373839404142class UnionSet(): def __init__(self,grid): m, n = len(grid), len(grid[0]) self.count=m self.parent=[] for i in range(m): self.parent.append(i) self.rank=[0 for i in range(m)] def find(self,x): if self.parent[x]!=x: self.parent[x]=self.find(self.parent[x]) return self.parent[x] def union(self,x,y): rootx=self.find(x) rooty=self.find(y) if rootx!=rooty: if self.rank[rootx]&lt;self.rank[rooty]: self.parent[rootx]=rooty self.rank[rootx]+=1 elif self.rank[rootx]&gt;self.rank[rooty]: self.parent[rooty]=rootx self.rank[rooty]+=1 else: self.parent[rooty]=rootx self.rank[rooty]+=1 self.count-=1class Solution(): def findCircleNum(self,grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) us=UnionSet(grid) for i in range(m): for j in range(n): if grid[i][j]==1: us.union(i,j) return us.count","categories":[{"name":"算法-数据结构","slug":"算法-数据结构","permalink":"https://langgithub.github.io/categories/算法-数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://langgithub.github.io/tags/数据结构/"}]},{"title":"堆相关题","slug":"堆相关题","date":"2020-06-09T09:29:21.392Z","updated":"2020-06-09T09:29:21.392Z","comments":true,"path":"2020/06/09/堆相关题/","link":"","permalink":"https://langgithub.github.io/2020/06/09/堆相关题/","excerpt":"","text":"堆（二叉堆，斐波那契堆）流式数据第k大（或者第k小）的元素是多少 ;时间负责度nlog2(k)1234567891011121314151617181920212223// 第k个最大用小顶堆，第k个最小用大顶堆class KthLargest &#123; private int k; private PriorityQueue&lt;Integer&gt; q; public KthLargest(int k,int[] nums)&#123; this.k=k; this.q=new PriorityQueue&lt;&gt;(k); for(int a:nums)&#123; add(a); &#125; &#125; public Integer add(int val)&#123; if(q.size()&lt;this.k) q.offer(val); else if(q.peek()&lt;val)&#123; q.poll(); q.offer(val); &#125; return q.peek(); &#125;&#125; 滑动窗口题,每次求最大值123456789101112def maxSlidingWindow(nums, k: int): if not nums:return [] window,res=[],[] for i,a in enumerate(nums): if i&gt;=k and window[0]&lt;=i-k: window.pop(0) while window and nums[window[-1]]&lt;=a: window.pop(-1) window.append(i) if i&gt;=k-1: res.append(nums[window[0]]) return res","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://langgithub.github.io/tags/算法/"}]},{"title":"数据库","slug":"数据库","date":"2020-06-09T09:29:21.392Z","updated":"2020-06-09T09:29:21.392Z","comments":true,"path":"2020/06/09/数据库/","link":"","permalink":"https://langgithub.github.io/2020/06/09/数据库/","excerpt":"","text":"事务的ACID特征 原子性 一致性 隔离性 持久性 数据库三范式 1NF 列是原子性，不能再分 在1NF基础上，一个表一个主键，其他属性必须完全依赖主键 在2NF基础上，非主键列不存在依赖情况 乐观锁和悲观锁 乐观锁 版本号控制 version字段 悲观锁 for update mysql 一次性添加几十万大数据 insert 批量操作 开启事务，设置 innodb_log_buffer_size 尽可能大 主键顺序插入 mysql 数据优化方案 根据业务类型特点选择存储引擎，innodb 事务类型；myisam 支持全文检索 分库分表 对查询进行优化，where 和 order by 字段添加索引 where 字段避免null, 避免使用！= or &lt;&gt;,避免使用or来连接条件 json大表可以采用分页 Redis1.基本类型","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://langgithub.github.io/tags/数据库/"}]},{"title":"栈与列表相关题","slug":"堆与列表相关题","date":"2020-06-09T09:29:21.391Z","updated":"2020-06-09T09:29:21.392Z","comments":true,"path":"2020/06/09/堆与列表相关题/","link":"","permalink":"https://langgithub.github.io/2020/06/09/堆与列表相关题/","excerpt":"","text":"1. 有效的括号1234567891011121314151617class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; stack=[] kuo_hao=&#123;&quot;(&quot;:&quot;)&quot;,&quot;&#123;&quot;:&quot;&#125;&quot;,&quot;[&quot;:&quot;]&quot;&#125; for a in s: if a in kuo_hao: stack.append(a) else: if not stack: return False if stack and kuo_hao[stack.pop()]!=a: return False return not stack 2. 两个队列实现一个栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 存使用l ,取也是l只不过是最后一个。class MyStack(object): def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.queue_l=[] self.queue_r=[] def push(self, x): &quot;&quot;&quot; Push element x onto stack. :type x: int :rtype: None &quot;&quot;&quot; self.queue_l.append(x) def pop(self): &quot;&quot;&quot; Removes the element on top of the stack and returns that element. :rtype: int &quot;&quot;&quot; while len(self.queue_l)&gt;1: self.queue_r.append(self.queue_l.pop(0)) value= self.queue_l.pop(0) while self.queue_r: self.queue_l.append(self.queue_r.pop(0)) return value def top(self): &quot;&quot;&quot; Get the top element. :rtype: int &quot;&quot;&quot; while len(self.queue_l)&gt;1: self.queue_r.append(self.queue_l.pop(0)) value= self.queue_l.pop(0) if value is not None: self.queue_r.append(value) while self.queue_r: self.queue_l.append(self.queue_r.pop(0)) return value def empty(self): &quot;&quot;&quot; Returns whether the stack is empty. :rtype: bool &quot;&quot;&quot; return not self.queue_l 3. 两个栈实现一个队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 存放在l,取从r中取，再把r中值晴空写回lclass MyQueue(object): def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.stack_l = [] self.stack_r = [] def push(self, x): &quot;&quot;&quot; Push element x to the back of queue. :type x: int :rtype: None &quot;&quot;&quot; self.stack_l.append(x) def pop(self): &quot;&quot;&quot; Removes the element from in front of queue and returns that element. :rtype: int &quot;&quot;&quot; while self.stack_l: self.stack_r.append(self.stack_l.pop()) value= self.stack_r.pop() while self.stack_r: self.stack_l.append(self.stack_r.pop()) return value def peek(self): &quot;&quot;&quot; Get the front element. :rtype: int &quot;&quot;&quot; while self.stack_l: self.stack_r.append(self.stack_l.pop()) value= self.stack_r.pop() self.stack_r.append(value) while self.stack_r: self.stack_l.append(self.stack_r.pop()) return value def empty(self): &quot;&quot;&quot; Returns whether the queue is empty. :rtype: bool &quot;&quot;&quot; while self.stack_l: self.stack_r.append(self.stack_l.pop()) return (not self.stack_r)","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://langgithub.github.io/tags/算法/"}]},{"title":"四哥逆向目录","slug":"四哥逆向目录","date":"2020-06-09T09:29:21.391Z","updated":"2020-06-09T09:29:21.391Z","comments":true,"path":"2020/06/09/四哥逆向目录/","link":"","permalink":"https://langgithub.github.io/2020/06/09/四哥逆向目录/","excerpt":"","text":"某付宝Xposed检查 2018-5-15123456789101112131415- 通过id查找突破口无望，估计对字符串常量进行了base64加密- 某付宝采用弹出框方式，可hook弹出框抛出异常更具堆栈信息寻找线索- 某宝检查xposed方式 1. 直接加载xposed类 2. 读取加载后的动态链接库 /proc/id/maps 3. 主动抛出异常检查xposed关键字 4. 获取安装的应用程序- 某付宝so文件检查 hack|inject|hook|call 1. cat /proc/pid/maps | grep injectco 2. cat /proc/pid/maps | grep hook 3. cat /proc/pid/maps | grep call 4. cat /proc/pid/maps | grep hack- 某付宝root检测原理是：是否含有su程序和ro.secure是否为1 1. su (#) 2. getprop ro.secure (=1) 某付宝蚂蚁森林能量收取 2018-9-10123451. 分析打开蚂蚁森林后response参数，包含能量，好友列表2. 查找自己能量收取方法调用3. 查找收取好友能量收取方法4. 查找以上两种能量收取方法参数5. hook以上方法并赋值参数","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://langgithub.github.io/tags/Android逆向/"}]},{"title":"回溯法","slug":"回溯法","date":"2020-06-09T09:29:21.391Z","updated":"2020-06-09T09:29:21.391Z","comments":true,"path":"2020/06/09/回溯法/","link":"","permalink":"https://langgithub.github.io/2020/06/09/回溯法/","excerpt":"","text":"回溯（递归）-重复计算 基本思想类同于：图的深度优先搜索 二叉树的后序遍历 经典问题 装载问题 0-1背包问题 旅行售货员问题 八皇后问题 迷宫问题 图的m着色问题","categories":[{"name":"算法-数据结构","slug":"算法-数据结构","permalink":"https://langgithub.github.io/categories/算法-数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://langgithub.github.io/tags/数据结构/"}]},{"title":"区块链-链码的介绍","slug":"区块链-链码的介绍","date":"2020-06-09T09:29:21.391Z","updated":"2020-06-09T09:29:21.391Z","comments":true,"path":"2020/06/09/区块链-链码的介绍/","link":"","permalink":"https://langgithub.github.io/2020/06/09/区块链-链码的介绍/","excerpt":"","text":"链码的介绍https://www.jianshu.com/p/47933c110b78","categories":[{"name":"区块链","slug":"区块链","permalink":"https://langgithub.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://langgithub.github.io/tags/区块链/"}]},{"title":"位运算相关题","slug":"位运算相关题","date":"2020-06-09T09:29:21.390Z","updated":"2020-06-09T09:29:21.390Z","comments":true,"path":"2020/06/09/位运算相关题/","link":"","permalink":"https://langgithub.github.io/2020/06/09/位运算相关题/","excerpt":"","text":"位运算相关操作1231. x &amp; 1==1 (奇) x &amp; 1 == 0(偶数)2. x &amp; (x-1) 打掉最后一位13. x &amp; -x 获取最后一位1 输出一个数二进制有多少位11234567891011class Solution(object): def hammingWeight(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; count=0 while n!=0: n=n&amp;(n-1) count+=1 return count 判断一个数是不是2的幂1234567class Solution(object): def isPowerOfTwo(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; return n&gt;0 and not n&amp;(n-1) 比特计算1234567891011class Solution(object): def countBits(self, num): &quot;&quot;&quot; :type num: int :rtype: List[int] &quot;&quot;&quot; d=[0]*(num+1) for i in range(1,num+1): # 打掉最后一个1又把它加回来 ，递归思想 d[i]=d[i&amp;(i-1)]+1 return d","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://langgithub.github.io/tags/算法/"}]},{"title":"区块链-安装","slug":"区块链-安装","date":"2020-06-09T09:29:21.390Z","updated":"2020-06-09T09:29:21.390Z","comments":true,"path":"2020/06/09/区块链-安装/","link":"","permalink":"https://langgithub.github.io/2020/06/09/区块链-安装/","excerpt":"","text":"区块链安装 安装流程参考 https://learnblockchain.cn/2019/04/21/fabric-v1.4-install-demo/ 在执行 ./byfn.sh -m generate -c jackychannel（自定义名字） 确保fabric/bin存在文件。下载链接:https://pan.baidu.com/s/1-BDoJPveepMVcdwKVf6Cig 密码:o8sd","categories":[{"name":"区块链","slug":"区块链","permalink":"https://langgithub.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://langgithub.github.io/tags/区块链/"}]},{"title":"区块链-概念","slug":"区块链-概念","date":"2020-06-09T09:29:21.390Z","updated":"2020-06-09T09:29:21.390Z","comments":true,"path":"2020/06/09/区块链-概念/","link":"","permalink":"https://langgithub.github.io/2020/06/09/区块链-概念/","excerpt":"","text":"分布式账本 （Hyperledger） 分布式账本，就是一个可以在多个实体，不同地理位置，不同机构之间组成的网络上进行交易信息共享的技术，在这个网络里的每个参与者都可以获得一个真实唯一的信息副本。 在这个账本里，存储数据的安全性是通过公私钥以及签名的使用，去控制账本的访问权，从而实现加密保护。 根据网络中已达成的共识规则，账本中的记录可以由一个，一些或者是所有参与者共同进行更新 共识新区块的生成过程 用户申请交易，通过验证的交易进入内存池 时间戳更新 解题 ：挖矿的过程","categories":[{"name":"区块链","slug":"区块链","permalink":"https://langgithub.github.io/categories/区块链/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://langgithub.github.io/tags/区块链/"}]},{"title":"动态规划","slug":"动态规划","date":"2020-06-09T09:29:21.390Z","updated":"2020-06-09T09:29:21.390Z","comments":true,"path":"2020/06/09/动态规划/","link":"","permalink":"https://langgithub.github.io/2020/06/09/动态规划/","excerpt":"","text":"动态规划=回溯+贪心 dp 由来 暴力穷举 带备忘录的递归 非递归的动态规划 即：dp table dp 解题思路 递归+记忆化-&gt; 递推（倒推） 状态的定义： opt[n],dp[n],fib[n] 状态转移方程：opt[n]=best_of(opt[n-1],opt(n-2)) 最优子结构 斐波那契数列dp(n) 定义：第n层的解法dp动态转移方程 =&gt; dp(n)=n (n&lt;2) =&gt; dp(n)=dp(n-1)+dp(n-2) (n&gt;=2) 零钱兑换dp[n] 定义：够成面值n最小的硬笔数量dp动态转移方程 =&gt; dp(n)=n (n=0) =&gt; dp(n)=min(dp[n-coin[j]]+1])","categories":[{"name":"算法-数据结构","slug":"算法-数据结构","permalink":"https://langgithub.github.io/categories/算法-数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://langgithub.github.io/tags/数据结构/"}]},{"title":"xposed攻防","slug":"xposed攻防","date":"2020-06-09T09:29:21.389Z","updated":"2020-06-09T09:29:21.389Z","comments":true,"path":"2020/06/09/xposed攻防/","link":"","permalink":"https://langgithub.github.io/2020/06/09/xposed攻防/","excerpt":"","text":"xposed攻防check: https://github.com/w568w/XposedCheckerhider: https://github.com/Yaerin/XposedHider 常用检查xposed方式 直接加载xposed类 读取加载后的动态链接库 主动抛出异常检查xposed关键字 获取安装的应用程序 … 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314//直接加载xposed类XC_MethodHook hookClass = new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed1&quot;); String packageName = (String) param.args[0]; if (packageName.matches(&quot;de\\\\.robv\\\\.android\\\\.xposed\\\\.Xposed+.+&quot;)) &#123; Log.i(&quot;xposed&quot;,&quot;de\\\\.robv\\\\.android\\\\.xposed\\\\.Xposed+.+&quot;); param.setThrowable(new ClassNotFoundException(packageName)); &#125; &#125;&#125;;// FIXME: 18-6-23 w568w: It&apos;s very dangerous to hook these methods, thinking to replace them.XposedHelpers.findAndHookMethod( ClassLoader.class, &quot;loadClass&quot;, String.class, boolean.class, hookClass);XposedHelpers.findAndHookMethod( Class.class, &quot;forName&quot;, String.class, boolean.class, ClassLoader.class, hookClass);//读取加载后的动态链接库 XposedHelpers.findAndHookMethod(BufferedReader.class, &quot;readLine&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; String result = (String) param.getResult(); if(result != null) &#123; if (result.contains(&quot;XposedBridge&quot;)) &#123; param.setResult(&quot;&quot;);new File(&quot;&quot;).lastModified(); &#125; &#125; &#125;&#125;);//主动抛出异常检查xposed关键字XC_MethodHook hookStack = new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed3&quot;); StackTraceElement[] elements = (StackTraceElement[]) param.getResult(); List&lt;StackTraceElement&gt; clone = new ArrayList&lt;&gt;(); for (StackTraceElement element : elements) &#123; if (!element.getClassName().toLowerCase().contains(C.KW_XPOSED)) &#123; clone.add(element); &#125; &#125; param.setResult(clone.toArray(new StackTraceElement[0])); &#125;&#125;;XposedHelpers.findAndHookMethod( Throwable.class, &quot;getStackTrace&quot;, hookStack);XposedHelpers.findAndHookMethod( Thread.class, &quot;getStackTrace&quot;, hookStack);//获取安装的应用程序XposedHelpers.findAndHookMethod( &quot;android.app.ApplicationPackageManager&quot;, lpparam.classLoader, &quot;getInstalledPackages&quot;, int.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed4&quot;); List&lt;PackageInfo&gt; apps = (List&lt;PackageInfo&gt;) param.getResult(); List&lt;PackageInfo&gt; clone = new ArrayList&lt;&gt;(); // foreach is very slow. final int len = apps.size(); for (int i = 0; i &lt; len; i++) &#123; PackageInfo app = apps.get(i); if (!app.packageName.toLowerCase().contains(C.KW_XPOSED)) &#123; clone.add(app); &#125; &#125; param.setResult(clone); &#125; &#125;);XposedHelpers.findAndHookMethod( &quot;android.app.ApplicationPackageManager&quot;, lpparam.classLoader, &quot;getInstalledApplications&quot;, int.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed5&quot;); List&lt;ApplicationInfo&gt; apps = (List&lt;ApplicationInfo&gt;) param.getResult(); List&lt;ApplicationInfo&gt; clone = new ArrayList&lt;&gt;(); final int len = apps.size(); for (int i = 0; i &lt; len; i++) &#123; ApplicationInfo app = apps.get(i); boolean shouldRemove = app.metaData != null &amp;&amp; app.metaData.getBoolean(&quot;xposedmodule&quot;) || app.packageName != null &amp;&amp; app.packageName.toLowerCase().contains(C.KW_XPOSED) || app.className != null &amp;&amp; app.className.toLowerCase().contains(C.KW_XPOSED) || app.processName != null &amp;&amp; app.processName.toLowerCase().contains(C.KW_XPOSED); if (!shouldRemove) &#123; clone.add(app); &#125; &#125; param.setResult(clone); &#125; &#125;);//查看某些函数是否是nativeXposedHelpers.findAndHookMethod( Modifier.class, &quot;isNative&quot;, int.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed6&quot;); param.setResult(false); &#125; &#125;);XposedHelpers.findAndHookMethod( System.class, &quot;getProperty&quot;, String.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed7&quot;); if (&quot;vxp&quot;.equals(param.args[0])) &#123; param.setResult(null); &#125; &#125; &#125;);XposedHelpers.findAndHookMethod( File.class, &quot;list&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed8&quot;); String[] fs = (String[]) param.getResult(); if (fs == null) &#123; return; &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String f : fs) &#123; if (!f.toLowerCase().contains(C.KW_XPOSED) &amp;&amp; !f.equals(&quot;su&quot;)) &#123; list.add(f); &#125; &#125; param.setResult(list.toArray(new String[0])); &#125; &#125;);Class&lt;?&gt; clazz = null;try &#123; clazz = Runtime.getRuntime().exec(&quot;echo&quot;).getClass();&#125; catch (IOException ignore) &#123; XposedBridge.log(&quot;[W/XposedHider] Cannot hook Process#getInputStream&quot;);&#125;if (clazz != null) &#123; XposedHelpers.findAndHookMethod( clazz, &quot;getInputStream&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed9&quot;); InputStream is = (InputStream) param.getResult(); if (is instanceof FilterXpInputStream) &#123; param.setResult(is); &#125; else &#123; param.setResult(new FilterXpInputStream(is)); &#125; &#125; &#125; );&#125;XposedBridge.hookAllMethods(System.class, &quot;getenv&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) &#123; Log.i(&quot;xposed&quot;,&quot;xposed10&quot;); if (param.args.length == 0) &#123; Map&lt;String, String&gt; res = (Map&lt;String, String&gt;) param.getResult(); String classpath = res.get(&quot;CLASSPATH&quot;); param.setResult(filter(classpath)); &#125; else if (&quot;CLASSPATH&quot;.equals(param.args[0])) &#123; String classpath = (String) param.getResult(); param.setResult(filter(classpath)); &#125; &#125; private String filter(String s) &#123; List&lt;String&gt; list = Arrays.asList(s.split(&quot;:&quot;)); List&lt;String&gt; clone = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; if (!list.get(i).toLowerCase().contains(C.KW_XPOSED)) &#123; clone.add(list.get(i)); &#125; &#125; StringBuilder res = new StringBuilder(); for (int i = 0; i &lt; clone.size(); i++) &#123; res.append(clone); if (i != clone.size() - 1) &#123; res.append(&quot;:&quot;); &#125; &#125; return res.toString(); &#125; &#125;);XposedHelpers.findAndHookMethod(&quot;android.app.ApplicationPackageManager&quot;, lpparam.classLoader, &quot;getPackageInfo&quot;, String.class, int.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; String packageName = (String) param.args[0]; XposedBridge.log(&quot;ApplicationPackageManager: &quot; + packageName); if(packageName.equals(&quot;de.robv.android.xposed.installer&quot;))&#123; param.args[0]=&quot;de.robv.android.Xposed.installer&quot;; &#125; &#125;&#125;);XposedHelpers.findAndHookMethod(&quot;android.app.ApplicationPackageManager&quot;, lpparam.classLoader, &quot;getApplicationInfo&quot;, String.class, int.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; String packageName = (String) param.args[0]; if (isTarget(packageName)) &#123; XposedBridge.log(&quot;packageName: &quot; + packageName); &#125; &#125;&#125;);XposedHelpers.findAndHookMethod(&quot;android.app.ActivityManager&quot;, lpparam.classLoader, &quot;getRunningServices&quot;, int.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; List&lt;ActivityManager.RunningServiceInfo&gt; serviceInfoList = (List) param.getResult(); List&lt;ActivityManager.RunningServiceInfo&gt; resultList = new ArrayList&lt;&gt;(); for (ActivityManager.RunningServiceInfo runningServiceInfo : serviceInfoList) &#123; String serviceName = runningServiceInfo.process; if (isTarget(serviceName)) &#123; XposedBridge.log(&quot;serviceName: &quot; + serviceName); &#125; else &#123; resultList.add(runningServiceInfo); &#125; &#125; param.setResult(resultList); &#125;&#125;);XposedHelpers.findAndHookMethod(&quot;android.app.ActivityManager&quot;, lpparam.classLoader, &quot;getRunningTasks&quot;, int.class, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; List&lt;ActivityManager.RunningTaskInfo&gt; serviceInfoList = (List) param.getResult(); List&lt;ActivityManager.RunningTaskInfo&gt; resultList = new ArrayList&lt;&gt;(); for (ActivityManager.RunningTaskInfo runningTaskInfo : serviceInfoList) &#123; String taskName = runningTaskInfo.baseActivity.flattenToString(); if (isTarget(taskName)) &#123; XposedBridge.log(&quot;taskName: &quot; + taskName); &#125; else &#123; resultList.add(runningTaskInfo); &#125; &#125; param.setResult(resultList); &#125;&#125;);XposedHelpers.findAndHookMethod(&quot;android.app.ActivityManager&quot;, lpparam.classLoader, &quot;getRunningAppProcesses&quot;, new XC_MethodHook() &#123; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcessInfos = (List) param.getResult(); List&lt;ActivityManager.RunningAppProcessInfo&gt; resultList = new ArrayList&lt;&gt;(); for (ActivityManager.RunningAppProcessInfo runningAppProcessInfo : runningAppProcessInfos) &#123; String processName = runningAppProcessInfo.processName; if (isTarget(processName)) &#123; XposedBridge.log(&quot;processName: &quot; + processName); &#125; else &#123; resultList.add(runningAppProcessInfo); &#125; &#125; param.setResult(resultList); &#125;&#125;);private static boolean isTarget(String name) &#123; return name.contains(&quot;Hu&quot;) || name.contains(&quot;xposed&quot;);&#125;","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"https://langgithub.github.io/tags/xposed/"}]},{"title":"zygote注入","slug":"zygote注入","date":"2020-06-09T09:29:21.389Z","updated":"2020-06-09T09:29:21.389Z","comments":true,"path":"2020/06/09/zygote注入/","link":"","permalink":"https://langgithub.github.io/2020/06/09/zygote注入/","excerpt":"","text":"zygote注入 xposed 基本解释 zygote系统进程 zygote进程是大部分应用程序的父进程 zygote fork 孵化出子进程 “fork” 是linux操作系统进程复用技术 zygote注入技术属于间接注入方式 隐秘，强大 zygote注入实现 关闭seLinux seLinux是Linux的一个安全子系统 关闭seLinux三个步骤：获取seLinux配置目录 获取seLinux配置文件中seLinux功能中开关状态（“/sys/fs/selinux”,&quot;/proc/mounts&quot;） 关闭seLinux 附加zygote进程，阻塞进程，保存寄存器现场 ptrace附加，waitpid,获取寄存器值，保存zygote进程注入前寄存器环境 获取zygote进程中关键函数地址 mprotect/dlopen/dlsym/mmap/munmap zygote进程中函数地址=zygote进程模块基址+zygote进程内存偏移地址 zygote进程内存偏移地址=辅助进程内存偏移地址（进程中包含相同模块） 辅助进程内存偏移地址=辅助进程中函数地址-辅助进程模块基址 远程调用mmap函数分配内存空间 设置堆栈布局 （参数处理） pc寄存器值设置为mmap函数的地址 lr寄存器置为0 配置shellcode 调用dlopen函数加载指定模块 调用dlsym函数获取模块中关键函数地址 调用已获取的关键函数 远程调用shellcode lr置0，pc置0 （lr置0 人为设置，代表调用；pr置0是shellcode代码运行会置0） 远程调用munmap释放内存 恢复进程，恢复寄存器环境，释放附加 控制权判断 判断是否为目标游戏进程，获取当前进程信息，匹配目标游戏进程字符串 /system/lib/libdvm.so,dvmloadnativecode函数 关键点 目标进程需要在zygote注入完成后再启动 注入的模块需要获取控制权 判断当前进程是否是目标进程","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"ptrace","slug":"ptrace","permalink":"https://langgithub.github.io/tags/ptrace/"}]},{"title":"二分法","slug":"二分法","date":"2020-06-09T09:29:21.389Z","updated":"2020-06-09T09:29:21.389Z","comments":true,"path":"2020/06/09/二分法/","link":"","permalink":"https://langgithub.github.io/2020/06/09/二分法/","excerpt":"","text":"二分查找法12345678910111213141516171819class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if not nums: return -1 left = 0 right =len(nums)-1 while(left&lt;=right): mid=(left+right)//2 if nums[mid]==target: return mid elif nums[mid]&gt; target: right=mid-1 else: left=mid+1 return -1 求平方根12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def mySqrt(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; if x==0 or x==1: return x left =0 right =x # 控制精度 while(right-left&gt;0.001): mid = (left + right) / 2 if mid == x/mid: return mid if mid&lt;x/mid: left=mid else: right=mid return &quot;%.3f&quot;%left除此之外，可用用牛顿迭代法=&gt; x2=x1-f(x)/f(x)`=&gt; x2=(x+a/x)/2class Solution(object): def mySqrt(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; a,x1,n=x,x,0 # 1e-9代表进度 while(abs(x1-n)&gt;1e-9): n = x1 x1= (x1+a/x1)/2 print(n,x1,str(&quot;%.5f&quot;%(n-x1))) return x1","categories":[{"name":"算法-数据结构","slug":"算法-数据结构","permalink":"https://langgithub.github.io/categories/算法-数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://langgithub.github.io/tags/数据结构/"}]},{"title":"xposed使用","slug":"xposed","date":"2020-06-09T09:29:21.388Z","updated":"2020-06-09T09:29:21.388Z","comments":true,"path":"2020/06/09/xposed/","link":"","permalink":"https://langgithub.github.io/2020/06/09/xposed/","excerpt":"","text":"Xposd app步骤 一部root后的手机 安装xposed install android app 开发 assets目录 下xposed_init文件: xposed所在类 AndroidManifest.xml 中添加 123456789&lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot; /&gt;&lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;蚂蚁森林自动收取好友能量&quot; /&gt;&lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;30&quot; /&gt; lib下添加 api-82.jar 编写hook代码 fuck this121. compileOnly &apos;de.robv.android.xposed:api:82&apos;2. 请确保禁用Instant Run（File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run），否则您的类不会直接包含在APK中，而是通过Xposed无法处理的存根应用程序加载。","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"xposed","slug":"xposed","permalink":"https://langgithub.github.io/tags/xposed/"}]},{"title":"vim打造python ide（mac系统）","slug":"vim打造python ide","date":"2020-06-09T09:29:21.388Z","updated":"2020-06-09T09:29:21.388Z","comments":true,"path":"2020/06/09/vim打造python ide/","link":"","permalink":"https://langgithub.github.io/2020/06/09/vim打造python ide/","excerpt":"","text":"vim IDEMacvim安装12345$ brew install macvim$ vi ~/.bash_profile# 添加如下配置#macvimalias vim=&apos;mvim&apos; .vimrc 配置1234# 根据 https://github.com/amix/vimrc。这款配置值得推荐给大家# 安装方式$ git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime$ sh ~/.vim_runtime/install_awesome_vimrc.sh my_config.vim123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&quot;vundle&quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限set nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin &apos;VundleVim/Vundle.vim&apos;&quot;git interfacePlugin &apos;tpope/vim-fugitive&apos;&quot;filesystemPlugin &apos;scrooloose/nerdtree&apos;Plugin &apos;jistr/vim-nerdtree-tabs&apos;Plugin &apos;kien/ctrlp.vim&apos; Plugin &apos;Yggdroot/LeaderF&apos;&quot;html&quot; isnowfy only compatible with python not python3Plugin &apos;isnowfy/python-vim-instant-markdown&apos;Plugin &apos;jtratner/vim-flavored-markdown&apos;Plugin &apos;suan/vim-instant-markdown&apos;Plugin &apos;nelstrom/vim-markdown-preview&apos;&quot;python sytax checker&quot;Plugin &apos;nvie/vim-flake8&apos;&quot;Plugin &apos;vim-scripts/Pydiction&apos;&quot;Plugin &apos;vim-scripts/indentpython.vim&apos;&quot;Plugin &apos;scrooloose/syntastic&apos;&quot;auto-completion stuff&quot;Plugin &apos;klen/python-mode&apos;Bundle &apos;Valloric/YouCompleteMe&apos;&quot;Plugin &apos;klen/rope-vim&apos;Plugin &apos;davidhalter/jedi-vim&apos;&quot;Plugin &apos;ervandew/supertab&apos;&quot;code foldingPlugin &apos;tmhedberg/SimpylFold&apos;&quot;Colors!!!Plugin &apos;altercation/vim-colors-solarized&apos;Plugin &apos;jnurmine/Zenburn&apos;call vundle#end()filetype plugin indent on &quot; enables filetype detection# 代码折叠显示一行let g:SimpylFold_docstring_preview = 1&quot; YouCompleteMe配置&quot;let g:ycm_python_interpreter_path = &apos;/Users/yuanlang/work/python/anaconda2/envs/python3_6/bin/python&apos;let g:ycm_python_interpreter_path =&quot;&quot;let g:ycm_python_sys_path = []&quot;这个参数会在ycm_extra_conf_vim中额外用到let g:ycm_extra_conf_vim_data = [ \\ &apos;g:ycm_python_interpreter_path&apos;, \\ &apos;g:ycm_python_sys_path&apos; \\]&quot;代码提示环境之类let g:ycm_global_ycm_extra_conf=&apos;~/.vim/.ycm_extra_conf.py&apos;&quot;错误提示符号let g:ycm_error_symbol = &apos;&gt;&gt;&apos;&quot;警告提示符号let g:ycm_warning_symbol = &apos;&gt;*&apos;&quot;let g:ycm_server_keep_logfiles = 1&quot;let g:ycm_server_log_level = &apos;debug&apos;&quot;python编译器let g:ycm_python_binary_path = &apos;/Users/yuanlang/work/python/anaconda2/envs/python3_6/bin/python3.6&apos;let g:ycm_autoclose_preview_window_after_completion=1nnoremap &lt;leader&gt;gl :YcmCompleter GoToDeclaration&lt;CR&gt;nnoremap &lt;leader&gt;gf :YcmCompleter GoToDefinition&lt;CR&gt;nnoremap &lt;leader&gt;gg :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;nmap &lt;F5&gt; :YcmDiags&lt;CR&gt;&quot;pydiction 提示，效果一般&quot;let g:pydiction_location = &apos;/Users/yuanlang/.vim/bundle/pydiction/complete-dict&apos; &quot;let g:pydiction_menu_height = 20&quot;I don&apos;t like swap filesset nobackupset noswapfile&quot;turn on numberingset nu&quot;python with virtualenv support&quot;py &lt;&lt; EOF&quot;import os.path&quot;import sys&quot;import vim&quot;if &apos;VIRTUA_ENV&apos; in os.environ:&quot; project_base_dir = os.environ[&apos;VIRTUAL_ENV&apos;]&quot; sys.path.insert(0, project_base_dir)&quot; activate_this = os.path.join(project_base_dir,&apos;bin/activate_this.py&apos;)&quot; execfile(activate_this, dict(__file__=activate_this))&quot;EOF&quot;it would be nice to set tag files by the active virtualenv here&quot;:set tags=~/mytags &quot;tags for ctags and taglist&quot;omnicomplete&quot;autocmd FileType python set omnifunc=pythoncomplete#Complete&quot;------------Start Python PEP 8 stuff----------------&quot; Number of spaces that a pre-existing tab is equal to.&quot;au BufRead,BufNewFile *py,*pyw,*.c,*.h set tabstop=4&quot;spaces for indents&quot;au BufRead,BufNewFile *.py,*pyw set shiftwidth=4&quot;au BufRead,BufNewFile *.py,*.pyw set expandtab&quot;au BufRead,BufNewFile *.py set softtabstop=4&quot; Use the below highlight group when displaying bad whitespace is desired.&quot;highlight BadWhitespace ctermbg=red guibg=red&quot; Display tabs at the beginning of a line in Python mode as bad.&quot;au BufRead,BufNewFile *.py,*.pyw match BadWhitespace /^\\t\\+/&quot; Make trailing whitespace be flagged as bad.&quot;au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\\s\\+$/&quot; Wrap text after a certain number of characters&quot;au BufRead,BufNewFile *.py,*.pyw, set textwidth=100&quot; Use UNIX (\\n) line endings.&quot;au BufNewFile *.py,*.pyw,*.c,*.h set fileformat=unix&quot; Set the default file encoding to UTF-8:set encoding=utf-8&quot; For full syntax highlighting:&quot;let python_highlight_all=1&quot;syntax on&quot; Keep indentation level from previous line:autocmd FileType python set autoindent&quot; make backspaces more powerfull&quot;set backspace=indent,eol,start&quot;Folding based on indentation:autocmd FileType python set foldmethod=indent&quot;use space to open foldsnnoremap &lt;space&gt; za &quot;----------Stop python PEP 8 stuff--------------&quot;js stuff&quot;&quot;autocmd FileType javascript setlocal shiftwidth=2 tabstop=2&quot;-------------run-----------------------------map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc() exec &quot;w&quot; if &amp;filetype == &apos;c&apos; exec &quot;!g++ % -o %&lt;&quot; exec &quot;!time ./%&lt;&quot; elseif &amp;filetype == &apos;cpp&apos; exec &quot;!g++ % -o %&lt;&quot; exec &quot;!time ./%&lt;&quot; elseif &amp;filetype == &apos;java&apos; exec &quot;!javac %&quot; exec &quot;!time java %&lt;&quot; elseif &amp;filetype == &apos;sh&apos; :!time bash % elseif &amp;filetype == &apos;python&apos;&quot; exec &quot;!time python2.7 %&quot; exec &quot;!time python3.6 %&quot; elseif &amp;filetype == &apos;html&apos; exec &quot;!firefox % &amp;&quot; elseif &amp;filetype == &apos;go&apos; exec &quot;!go build %&lt;&quot; exec &quot;!time go run %&quot; elseif &amp;filetype == &apos;mkd&apos; exec &quot;!~/.vim/markdown.pl % &gt; %.html &amp;&quot; exec &quot;!firefox %.html &amp;&quot; endifendfunc&quot;----------------taglist---------------------let Tlist_Auto_Highlight_Tag=1let Tlist_Auto_Open=1let Tlist_Auto_Update=1let Tlist_Display_Tag_Scope=1let Tlist_Exit_OnlyWindow=1let Tlist_Enable_Dold_Column=1let Tlist_File_Fold_Auto_Close=1let Tlist_Show_One_File=1let Tlist_Use_Right_Window=1let Tlist_Use_SingleClick=1nnoremap &lt;silent&gt; &lt;F8&gt; :TlistToggle&lt;CR&gt;&quot;-------------ctags----------------------&quot;set tags+=/usr/local/bin/ctags 主要插件介绍：1.leaderf(全局搜索) leaderfFile2.ycmd(自动补全)3.nerdtree （）4.tabnew tabclose5.”,f” —&gt;menu “,o”—-buffer6.ctags 跳转 ycmd插件安装(mac电脑)12345git clone YouCompleteMe 到 ~/.vim/bundle/brew install cmakecd YouCompleteMepython ./install.py --clang-completer注意：python 不要用anacoda中的","categories":[{"name":"辅助工具","slug":"辅助工具","permalink":"https://langgithub.github.io/categories/辅助工具/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://langgithub.github.io/tags/vim/"},{"name":"YouCompleteMe","slug":"YouCompleteMe","permalink":"https://langgithub.github.io/tags/YouCompleteMe/"}]},{"title":"sublime3 无法联网安装插件","slug":"sublime3 无法联网安装插件","date":"2020-06-09T09:29:21.388Z","updated":"2020-06-09T09:29:21.388Z","comments":true,"path":"2020/06/09/sublime3 无法联网安装插件/","link":"","permalink":"https://langgithub.github.io/2020/06/09/sublime3 无法联网安装插件/","excerpt":"","text":"sublime3 无法联网安装插件12345678910111213141.下载 JSON文件：“https://packagecontrol.io/channel_v3.json”；2.修改 JSON文件中的版本号“schema_version”，将“3.0.0”修改为 “2.0”；3.打开 首选项 --》插件设置 --》Package Control --》 设置-用户 （或者“设置-默认”）4. 修改第3步设置文件中的 channels 属性的值，在 channels[……]的最前面添加 JSON文件 的 地址（步骤1下载的文件）注意：英文逗号分割 和 斜线方向&quot;channels&quot;:[ &quot;/Users/yuanlang/work/sublime/channel_v3.json&quot;],","categories":[{"name":"辅助工具","slug":"辅助工具","permalink":"https://langgithub.github.io/categories/辅助工具/"}],"tags":[{"name":"sublime text3","slug":"sublime-text3","permalink":"https://langgithub.github.io/tags/sublime-text3/"}]},{"title":"android文件-so","slug":"so 文件结构","date":"2020-06-09T09:29:21.388Z","updated":"2020-06-09T09:29:21.388Z","comments":true,"path":"2020/06/09/so 文件结构/","link":"","permalink":"https://langgithub.github.io/2020/06/09/so 文件结构/","excerpt":"","text":"android文件-so archives/559.html archives/849.html 清华大学so文件分析 (https://langgithub.github.io/file/ELF文件格式分析.pdf) 寄存器接受参数在 R0 - R3 ,返回值在R0so文件结构 header ELF文件头是ELF文件中唯一一个固定位置的文件结构，保存段头表和节头表位置和大小信息 section program 段头表保存了ELF文件的加载过程中各节头表的内存映射，依赖库等信息 .dynstr .text .dynamic相同flg section 放在一起组成program load 段才会被加载到内存 123456789101112131415161718192021222324252627282930313233341、.text段一般C语言编译后的执行语句都编译成机器代码，保存在.text段。2、.data段已经初始化的全局变量和局部静态变量（虽然默认会初始化为0,或者手动初始化为0，都没有必要在数据段分配空间，直接放在.bss段，就默认值为0了）都保存在.data段。大体来说，该section包含了在内存中的程序的初始化数据；data段包含三个部分：heap(堆)、stack(栈)和静态数据区。即.data还会存放其他类型的数据，比如局部变量。数据段只是存放数据，变量名存放在字符串表中。3、.bss段未初始化的全局变量和局部静态变量都保存在.bss段。大体来说该section包含了在内存中的程序的未初始化的数据。由于程序加载（一般是指main之前）时，bss会被操作系统清零，所以未赋初值或初值为0的全局变量都在bss。.bss段只是为未初始化的全局变量和局部静态变量预留位置而已，它并没有内容，所以它在文件中也不占据空间，这样可减少目标文件体积。但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和(通过start_bss和end_bss地址写入机器代码)。当加载器(loader)加载程序时，将为BSS段分配的内存初始化为0。4、.rodata段存放只读数据，一般是程序里面的只读变量（如const修饰的变量），以及字符串常量（不一定，也可能放在.data中）。5、.got段GOT（Global Offset Table）表中每一项都是本运行模块要引用的一个全局变量或函数的地址。可以用GOT表来间接引用全局变量、函数，也可以把GOT表的首地址作为一个基 准，用相对于该基准的偏移量来引用静态变量、静态函数。由于加载器不会把运行模块加载到固定地址，在不同进程的地址空间中，各运行模块的绝对地址、相对位 置都不同。这种不同反映到GOT表上，就是每个进程的每个运行模块都有独立的GOT表，所以进程间不能共享GOT表。6、.plt段过程链接表用于把位置独立的函数调用重定向到绝对位置。通过 PLT 动态链接的程序支持惰性绑定模式。每个动态链接的程序和共享库都有一个 PLT，PLT 表的每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。程序对某个函数的访问都被调整为对 PLT 入口的访问。每个 PLT 入口项对应一个 GOT 项，执行函数实际上就是跳转到相应 GOT 项存储的地址，该 GOT 项初始值为 PLTn项中的 push 指令地址(即 jmp 的下一条指令，所以第 1 次跳转没有任何作用)，待符号解析完成后存放符号的真正地址。动态链接器在装载映射共享库时在 GOT 里设置 2 个特殊值：在 GOT+4( 即 GOT[1]) 设置动态库映射信息数据结构link_map 地址；在 GOT+8(即 GOT[2])设置动态链接器符号解析函数的地址_dl_runtime_resolve。每一个外部定义的符号在全局偏移表 (Global Offset Table GOT)中有相应的条目,如果符号是函数则在过程连接表(Procedure Linkage Table PLT)中也有相应的条目下面来看张图就了解了.got段和.plt段的关系：这个在我们之前说到Hook技术就是用着两个段来实现的。只要修改需要hook的函数地址，插入我们hook的函数，执行之后，再回来就可以了，这里只要修改.got和.plt表就可以了，相关知识大家去网上搜一下吧。这里就不在解释了。 readelf 使用 readelf -h xxx.so (查看so文件的头部信息) readelf -S xxx.so (查看so文件的节(Section)头的信息) readelf -l xxx.so (查看so文件的程序段头信息(Program)) readelf -a xxx.so (查看so文件所有信息) 010 Editor 运用","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"文件结构","slug":"文件结构","permalink":"https://langgithub.github.io/tags/文件结构/"}]},{"title":"so 文件加载过程","slug":"so 文件加载过程","date":"2020-06-09T09:29:21.387Z","updated":"2020-06-09T09:29:21.387Z","comments":true,"path":"2020/06/09/so 文件加载过程/","link":"","permalink":"https://langgithub.github.io/2020/06/09/so 文件加载过程/","excerpt":"","text":"so文件加载流程 记载步骤 java 加载loadLibrary=&gt;doLoad=&gt;nativeLoad native 加载 初始化阶段 加载到内存 打开so文件 映射so到内存空间 解析 dynamic section 链接阶段 3.so加载关键函数dlopen -&gt; 打开so文件dlsym -&gt; 获取JNI_Onload函数地址,调用该函数dlerror -&gt; 处理错误 4.初始化initinit_array 5.常用类log 6.root权限读写内存数据-》内存页属性的修改 -〉 r/w/x chmod 777 7.下断点时机 (init init_array) JNI_OnLoad 注意：so加载了program header 没有加载session header","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://langgithub.github.io/tags/ndk/"},{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"}]},{"title":"python黑魔法-上下文管理器","slug":"python黑魔法-上下文管理器","date":"2020-06-09T09:29:21.387Z","updated":"2020-06-09T09:29:21.387Z","comments":true,"path":"2020/06/09/python黑魔法-上下文管理器/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python黑魔法-上下文管理器/","excerpt":"","text":"python 上下文管理器 with的作用是什么 @contextlib.contextmanager与with有什么关系 上下文管理器使用案例 多个管理器嵌套 nested函数 问题一with是一款语法糖 大致执行分为三个阶段 enter(self): with进入前 with 内部代码 exit(self, type, value, traceback) with 退出后 问题二 在理解 @contextlib.contextmanager内部先看下 1234567891011121314151617181920212223242526272829#未使用上下文管理器，handle_query代码啰嗦class Database(object): def __init__(self): self.connected = False def connect(self): self.connected = True def close(self): self.connected = False def query(self): if self.connected: return &apos;query data&apos; else: raise ValueError(&apos;DB not connected &apos;)def handle_query(): db = Database() db.connect() print &apos;handle --- &apos;, db.query() db.close()def main(): handle_query()if __name__ == &apos;__main__&apos;: main() 使用上下文管理器后 12345678910111213141516171819202122232425262728293031323334353637#handle_query 简单多了import contextlibclass Database(object): def __init__(self): self.connected = False def connect(self): self.connected = True def close(self): self.connected = False def query(self): if self.connected: return &apos;query data&apos; else: raise ValueError(&apos;DB not connected &apos;)@contextlib.contextmanagerdef database(): db = Database() try: if not db.connected: db.connect() yield db except Exception as e: db.close()def handle_query(): with database() as db: print(&apos;handle ---&apos;, db.query())handle_query() 分析下代码执行逻辑 进入@contextlib.contextmanager 实质是contextlib.contextmanager(database) 123456#进入装饰器后又来一个装饰器wrap#简单说明下wrap装饰器的作用是将 要装饰的方法相关属性的指针指向装饰器，也就是将func的属性地址给 helper@wraps(func)def helper(*args, **kwds): return _GeneratorContextManager(func, args, kwds)return helper 执行到whit database() 的database()时候进入到return _GeneratorContextManager(func, args, kwds)，初始化 _GeneratorContextManager过程中 func（==database）协程初始化完成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class _GeneratorContextManager(ContextDecorator, AbstractContextManager): &quot;&quot;&quot;Helper for @contextmanager decorator.&quot;&quot;&quot; def __init__(self, func, args, kwds): self.gen = func(*args, **kwds) self.func, self.args, self.kwds = func, args, kwds # Issue 19330: ensure context manager instances have good docstrings doc = getattr(func, &quot;__doc__&quot;, None) if doc is None: doc = type(self).__doc__ self.__doc__ = doc # Unfortunately, this still doesn&apos;t provide good help output when # inspecting the created context manager instances, since pydoc # currently bypasses the instance docstring and shows the docstring # for the class instead. # See http://bugs.python.org/issue19404 for more details. def _recreate_cm(self): # _GCM instances are one-shot context managers, so the # CM must be recreated each time a decorated function is # called return self.__class__(self.func, self.args, self.kwds) def __enter__(self): try: return next(self.gen) except StopIteration: raise RuntimeError(&quot;generator didn&apos;t yield&quot;) from None def __exit__(self, type, value, traceback): if type is None: try: next(self.gen) except StopIteration: return False else: raise RuntimeError(&quot;generator didn&apos;t stop&quot;) else: if value is None: # Need to force instantiation so we can reliably # tell if we get the same exception back value = type() try: self.gen.throw(type, value, traceback) except StopIteration as exc: # Suppress StopIteration *unless* it&apos;s the same exception that # was passed to throw(). This prevents a StopIteration # raised inside the &quot;with&quot; statement from being suppressed. return exc is not value except RuntimeError as exc: # Don&apos;t re-raise the passed in exception. (issue27122) if exc is value: return False # Likewise, avoid suppressing if a StopIteration exception # was passed to throw() and later wrapped into a RuntimeError # (see PEP 479). if type is StopIteration and exc.__cause__ is value: return False raise except: # only re-raise if it&apos;s *not* the exception that was # passed to throw(), because __exit__() must not raise # an exception unless __exit__() itself failed. But throw() # has to raise the exception to signal propagation, so this # fixes the impedance mismatch between the throw() protocol # and the __exit__() protocol. # if sys.exc_info()[1] is value: return False raise raise RuntimeError(&quot;generator didn&apos;t stop after throw()&quot;) 触发enter ，通过next(self.gen)启动协程 进入函数database yield db 挂起自己，释放控制权返回db 12345678def database(): db = Database() try: if not db.connected: db.connect() yield db except Exception as e: db.close() 进入with内部 print(‘handle —‘, db.query()) 触发exit 继续回到协程 yeild db，关闭连接 退出with 12问题二：可以看到 with 是要与具有__enter__，__exit__的对象一起使用，而contextlib.contextmanager就是那个对象 问题三12345678910111213#锁资源@contextmanagerdef locked(lock): lock.acquire() try: yield finally: lock.release()with locked(myLock): #代码执行到这里时，myLock已经自动上锁 pass #执行完后会，会自动释放锁 123456789101112#文件资源@contextmanagerdef myopen(filename, mode=&quot;r&quot;): f = open(filename,mode) try: yield f finally: f.close()with myopen(&quot;test.txt&quot;) as f: for line in f: print(line) 1234567891011121314151617#数据库资源@contextmanagerdef transaction(db): db.begin() try： yield except: db.rollback() raise else: db.commit()with transaction(mydb): mydb.cursor.execute(sql) mydb.cursor.execute(sql) mydb.cursor.execute(sql) mydb.cursor.execute(sql) 问题412345678910111213141516171819202122232425from contextlib import contextmanagerfrom contextlib import nestedfrom contextlib import closing@contextmanagerdef my_context(name): print(&quot;enter&quot;) try: yield name finally: print(&quot;exit&quot;)#使用nested函数来调用多个管理器print(&quot;---------使用nested函数调用多个管理器-----------&quot;)with nested(my_context(&quot;管理器一&quot;), my_context(&quot;管理器二&quot;),my_context(&quot;管理器三&quot;)) as (m1,m2,m3): print(m1) print(m2) print(m3)#直接使用with来调用调用多个管理器print(&quot;---------使用with调用多个管理器-----------&quot;)with my_context(&quot;管理器一&quot;) as m1, my_context(&quot;管理器二&quot;) as m2, my_context(&quot;管理器三&quot;) as m3: print(m1) print(m2) print(m3)","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"rom刷机-总结","slug":"rom刷机-总结","date":"2020-06-09T09:29:21.387Z","updated":"2020-06-09T09:29:21.387Z","comments":true,"path":"2020/06/09/rom刷机-总结/","link":"","permalink":"https://langgithub.github.io/2020/06/09/rom刷机-总结/","excerpt":"","text":"刷机总结刷机前的准备 一般手机需要解锁，解除屏幕锁 解除fastboot使用权限（比如小米） 需要正版的twrp,官网上下载 https://twrp.me 。这一点很重要，后期的刷机，刷magisk,刷xposed.都需要借助twrp上下载的recovery镜像 下载Rom刷机包，这里提供两个好用的.注意选择手机版本 1.https://download.mokeedev.com/whyred/nightly/file/MK90.0-whyred-201904151652-NIGHTLY 2.https://downloads.aospextended.com/whyred/ 刷机方式 线刷 使用刷机精灵等软件。(bootloader) 123adb reboot bootloader (进入bootloader模式)fastboot -w flashallfastboot update XXX.zip 卡刷(recovery) 12345# 先刷机前准备# fastboot flash recovery twrp.img (刷入启动刷机包的镜像)# fastboot boot &lt;twrp.img&gt;# adb push rom(rom包) /sdcard/# 进入recovery模式后刷入镜像（twrp.img）,刷入rom刷机包 刷入magisk （和刷rom包一样）superus 停止更新了就用了magisk地址：https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445 刷入xposed（和刷rom包一样）地址 ：https://forum.xda-developers.com/showthread.php?t=3034811也就是 https://dl-xda.xposed.info/framework/ 刷到手机","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"Android刷机","slug":"Android刷机","permalink":"https://langgithub.github.io/tags/Android刷机/"}]},{"title":"python黑魔法-装饰器","slug":"python黑魔法-装饰器","date":"2020-06-09T09:29:21.387Z","updated":"2020-06-09T09:29:21.387Z","comments":true,"path":"2020/06/09/python黑魔法-装饰器/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python黑魔法-装饰器/","excerpt":"","text":"装饰器剖析 不带参数的装饰器 带参数的装饰器 类装饰器 利用functools.wrap 将wapped 的属性赋值给wapper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158# encoding: utf-8&quot;&quot;&quot;--------------------------------------@describe @version: 1.0@project: websockets@file: test.py@author: yuanlang @time: 2019-03-18 14:29---------------------------------------&quot;&quot;&quot;# 先看看函数复制def a(): passprint(a)x = aprint(x)# 结论# a方法地址给了 x# 两个地址都是 a方法print(&quot;---------------------------------------&quot;)def log_track(func): def wapper(*args, **kwargs): print(func.__name__) func(*args, **kwargs) return wapperdef hello2(): pass@log_trackdef hello(): print(&quot;hello&quot;)print(hello)hello = wapper = log_track(hello) # 和 @log_track效果一样print(hello)print(hello2.__name__)print(hello.__name__)# 结论# hello指针指向的hello函数地址进入到wapper作用域中，返回的wapper函数地址给 helloprint(&quot;---------------------------------------&quot;)# 带参数的装饰器def user_loggin(level): print(level) def decoration(func): print(func.__name__) def wrapper(*args,**kwargs): print(func.__name__) func(*args,**kwargs) print(&quot;return wrapper&quot;) return wrapper print(&quot;return decoration&quot;) return decorationdef foo(): return &quot;foo&quot;func = decoration = user_loggin(level=&quot;debug&quot;)print(func)print(&quot;func.__name__ &gt;&gt;&gt;&gt;&gt; &quot;,func.__name__)print(&quot;######################&quot;)func = wrapper = user_loggin(level=&quot;debug&quot;)(foo)print(func)print(&quot;func.__name__ &gt;&gt;&gt;&gt;&gt;&quot;,func.__name__)print(&quot;######################&quot;)@user_loggin(level=&quot;debug&quot;)def foo2(): print(&quot;fool&quot;)# 总结# 带参数的装饰器比不带参数的装饰器多一层，需先解压出装饰器print(&quot;---------------------------------------&quot;)# 类装饰器class Foo(): def __init__(self,func): self.__func=func def __call__(self, *args, **kwargs): print(&quot;before call&quot;) self.__func(*args,**kwargs) print(&quot;after call&quot;) return self.__funcdef test(): print(&quot;test&quot;)foo_obj=Foo(test)print(foo_obj)print(&quot;__call__&quot;,foo_obj())print(&quot;######################&quot;)print(&quot;__call__&quot;,foo_obj.__call__())print(&quot;######################&quot;)@Foodef test1(): print(&quot;test1&quot;)test1()# 总结# 类装饰器 实质是将 类的__call__地址 负值给要装饰的函数 test1=Foo(test1).__call__print(&quot;---------------------------------------&quot;)#### 可以发现 需要被装饰的函数的 docstring、__name__ 被装饰器替代了## 所以引出 functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器函数中##from functools import wrapsdef logged(func): #func=decoration=wraps(func)(with_logging) #wraps(func)解压并调用类装饰器 #func=partial().__call__ #update_wapper 将with_loggin 的某些参数负值给f return 的 with_logging 变为 f @wraps(func) def with_logging(*args, **kwargs): print(func.__name__ + &quot; was called&quot;) return func(*args, **kwargs) return with_logging@loggeddef f(x): &quot;&quot;&quot;does some math&quot;&quot;&quot; return x + x * xprint(f.__name__ ) # prints &apos;f&apos;print(f.__doc__ ) # prints &apos;does some math1&apos;","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"python黑魔法-python基础","slug":"python黑魔法-python基础","date":"2020-06-09T09:29:21.386Z","updated":"2020-06-09T09:29:21.386Z","comments":true,"path":"2020/06/09/python黑魔法-python基础/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python黑魔法-python基础/","excerpt":"","text":"python LEGB原则1所谓LEGB是指 local&lt; enClosed&lt; global&lt; buind in nonloacl 与 global1nonloacl 处在函数嵌套中 非global对象 实例属性 与 类属性1实例属性 从属于实例 类属性从属于类 python 内存分析123栈：对象引用放入栈堆：类对象（也叫模具 即type）（存放类属性，类方法，静态方法）和实例对象（存放 id ，type，实例属性 方法地址） 垃圾回收机制（引用计数 del）垃圾回收器调用私有属性 (属性和方法) dir查看所有属性（方法也是属性）12双下划线： 私有属性私有属性外部如何访问 实例._类名.__私有属性 @property1作用是将方法变属性使用 mro()12查看内存结构，类的继承关系python中继承方法重写安广度优先算法","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"python源码阅读(7)-Cpython调试","slug":"python源码阅读(7)-Cpython调试","date":"2020-06-09T09:29:21.385Z","updated":"2020-06-09T09:29:21.385Z","comments":true,"path":"2020/06/09/python源码阅读(7)-Cpython调试/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python源码阅读(7)-Cpython调试/","excerpt":"","text":"一. 工作准备12345678910# locally clone the repo.git clone https://github.com/python/cpython# Navigate to the repo directorycd cpython# Switch to the version of python you want to work ongit checkout 3.6# configure a debug build for CPython./configure --with-pydebug# build without echoing commands and use 2 coresmake -s -j2 注意：最好是linux系统 二. 了解python字节码12345678910111213&gt;&gt;&gt; import dis&gt;&gt;&gt; def foo():... a = 1... a.x...&gt;&gt;&gt; dis.dis(foo) 2 0 LOAD_CONST 1 (1) 3 STORE_FAST 0 (a) 3 6 LOAD_FAST 0 (a) 9 LOAD_ATTR 0 (x) 12 POP_TOP 13 LOAD_CONST 0 (None) 16 RETURN_VALUE 使用dis模块查看python字节码，其中LOAD_CONST指令对于如下 1234567891011// Python/ceval.c 2862 TARGET(LOAD_ATTR) &#123; 2863 PyObject *name = GETITEM(names, oparg); 2864 PyObject *owner = TOP(); 2865 PyObject *res = PyObject_GetAttr(owner, name); 2866 Py_DECREF(owner); 2867 SET_TOP(res); 2868 if (res == NULL) 2869 goto error; 2870 DISPATCH();&#125; gdb 调试 启动dgb，编写代码例子 12345678910111213141516171819sabbas@sabbas-VirtualBox:~/Documents/pythondev/cpython$ gdb pythonGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.(gdb) runStarting program: /home/sabbas/Documents/pythondev/cpython/python [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.Python 3.6.2+ (heads/3.6:cb7fdf6, Aug 23 2017, 22:24:16) [GCC 5.4.0 20160609] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; def foo():... x = 1... x.a... &gt;&gt;&gt; 另外启动一个终端 暂停python执行器，提供打入断点机会 12sabbas@sabbas-VirtualBox:~/Documents/pythondev/cpython$ pkill python -SIGTRAP 回到dgb调试打断点 123456789101112131415161718192021222324252627sabbas@sabbas-VirtualBox:~/Documents/pythondev/cpython$ gdb pythonGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.(gdb) runStarting program: /home/sabbas/Documents/pythondev/cpython/python [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.Python 3.6.2+ (heads/3.6:cb7fdf6, Aug 23 2017, 22:24:16) [GCC 5.4.0 20160609] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; def foo():... x = 1... x.a... &gt;&gt;&gt;Program received signal SIGTRAP, Trace/breakpoint trap.0x00007ffff71dd573 in __select_nocancel () at ../sysdeps/unix/syscall-template.S:8484 ../sysdeps/unix/syscall-template.S: No such file or directory.(gdb) b Python/ceval.c:2855Breakpoint 1 at 0x5418d7: file Python/ceval.c, line 2855.(gdb)cContinuing.&gt;&gt;&gt; 函数调用,断在cpython中了 1234&gt;&gt;&gt; foo()Breakpoint 1, _PyEval_EvalFrameDefault (f=&lt;optimized out&gt;, throwflag=&lt;optimized out&gt;) at Python/ceval.c:28552855 PyObject *name = GETITEM(names, oparg);(gdb) 使用dbg相关命令查看cpython中变量，等等等","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python源码阅读","slug":"python源码阅读","permalink":"https://langgithub.github.io/tags/python源码阅读/"}]},{"title":"python源码阅读(6)-python垃圾回收","slug":"python源码阅读(6)-python垃圾回收","date":"2020-06-09T09:29:21.385Z","updated":"2020-06-09T09:29:21.385Z","comments":true,"path":"2020/06/09/python源码阅读(6)-python垃圾回收/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python源码阅读(6)-python垃圾回收/","excerpt":"","text":"引用计数与垃圾收集引用计数机制所带来的维护引用计数的额外操作与python运行中所进行的内存分配和释放, 引用赋值次数是成正比的, 这也是引用计数执行效率较慢的原因(软肋).为了与引用计数机制搭配, 在内存的分配和释放上获得最高的效率, python因此设计了很多内存池机制, 如上一篇的小块内存池. 而且在一些PyObject中如PyLongObject, PyUnicodeObject, PyDictObject, PyListObject等都有与各个对象相关的内存池机制. 这些大量使用的面向特定对象内存池机制正式为了弥补引用计数的软肋. 引用计数还需要处理一个致命的弱点, 就是循环引用. 当若干对象相互引用, 会造成每一个对象的引用计数都不会0, 因此这些对象所占用的内存永远不会回收. python中的标记-清除对与循环应用问题，python采用标记-清除。 container对象之间如list, dict, class等. 当python的垃圾收集机制运行时, 只需要检测这些container对象，这些container对象包含一个双向链表 python 通过ref_count计算应用计数垃圾回收，gc_ref是ref_count副本，用于循环应用的垃圾回收，GC时分两步，一是gc_ref自减1，摘除循环引用；二是从root根出发标记是否可达。最后gc_ref为0且不可达将被回收 分代回收分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。 python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。 总结总体来说，在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python源码阅读","slug":"python源码阅读","permalink":"https://langgithub.github.io/tags/python源码阅读/"}]},{"title":"python源码阅读(5)-python线程","slug":"python源码阅读(5)-python线程","date":"2020-06-09T09:29:21.385Z","updated":"2020-06-09T09:29:21.385Z","comments":true,"path":"2020/06/09/python源码阅读(5)-python线程/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python源码阅读(5)-python线程/","excerpt":"","text":"GIL12全局解释器锁(Global Interpreter Lock) 当CPython创建变量时，它会分配内存然后计算对该变量的引用数量，大家通常称之为“引用计数”。 如果引用计数变为0，则从系统中释放该内存。引用 计数变量时需要保护竞争条件，多个线程同时增加 或减少变量引用计数时，可能导致内存泄漏或者错 误的内存释放。 CPython引入了GIL，线程在执行代码时，必须首先 获得解释器的使用权，虽然保证了数据安全，也意 味着单进程下Python多线程的性能没有那么好。 12345678910111213141516171819202122232425262728293031323334353637[ceval_gil.h]static _Py_atomic_int gil_locked = &#123;-1&#125;;static _Py_atomic_address gil_last_holder = &#123;0&#125;;static COND_T gil_cond;static MUTEX_T gil_mutex;static void create_gil(void)&#123; MUTEX_INIT(gil_mutex); MUTEX_INIT(switch_mutex); COND_INIT(gil_cond); COND_INIT(switch_cond); _Py_atomic_store_relaxed(&amp;gil_last_holder, 0); _Py_ANNOTATE_RWLOCK_CREATE(&amp;gil_locked); _Py_atomic_store_explicit(&amp;gil_locked, 0, _Py_memory_order_release);&#125;[ceval_gil.h]static void take_gil(PyThreadState *tstate)&#123; int err; err = errno; MUTEX_LOCK(gil_mutex); if (!_Py_atomic_load_relaxed(&amp;gil_locked)) goto _ready; while (_Py_atomic_load_relaxed(&amp;gil_locked)) &#123; int timed_out = 0; COND_TIMED_WAIT(gil_cond, gil_mutex, INTERVAL, timed_out); ... &#125;_ready: ... _Py_atomic_store_relaxed(&amp;gil_locked, 1); ...&#125; 线程12345678910111213141516171819202122232425262728293031[Modules/_threadmodule.c]static PyMethodDef thread_methods[] = &#123; &#123;&quot;start_new_thread&quot;, (PyCFunction)thread_PyThread_start_new_thread, METH_VARARGS, start_new_doc&#125;, &#123;&quot;start_new&quot;, (PyCFunction)thread_PyThread_start_new_thread, METH_VARARGS, start_new_doc&#125;, &#123;&quot;allocate_lock&quot;, (PyCFunction)thread_PyThread_allocate_lock, METH_NOARGS, allocate_doc&#125;, &#123;&quot;allocate&quot;, (PyCFunction)thread_PyThread_allocate_lock, METH_NOARGS, allocate_doc&#125;, ... &#123;NULL, NULL&#125; /* sentinel */&#125;;[cveal.c]static PyThread_type_lock pending_lock = 0; /* for pending calls */static unsigned long main_thread = 0;/* Request for dropping the GIL */static _Py_atomic_int gil_drop_request = &#123;0&#125;;void PyEval_InitThreads(void)&#123; if (gil_created()) // 如果初始化过了 return; create_gil(); take_gil(PyThreadState_GET()); main_thread = PyThread_get_thread_ident(); if (!pending_lock) pending_lock = PyThread_allocate_lock();&#125; 从GIL到字节码1234567891011121314151617181920212223242526[pystate.c]PyThreadState * PyThreadState_New(PyInterpreterState *interp)&#123; return new_threadstate(interp, 1);&#125;static PyThreadState * new_threadstate(PyInterpreterState *interp, int init)&#123; PyThreadState *tstate = (PyThreadState *)PyMem_RawMalloc(sizeof(PyThreadState)); if (_PyThreadState_GetFrame == NULL) // 设置获得线程中函数调用栈的操作 _PyThreadState_GetFrame = threadstate_getframe; ... if (init) _PyThreadState_Init(tstate); ... return tstate;&#125;void _PyThreadState_Init(PyThreadState *tstate)&#123;#ifdef WITH_THREAD _PyGILState_NoteThreadState(tstate);#endif&#125; 子线程在创建了自身的线程状态对象后, 通过 _PyGILState_NoteThreadState 将这个线程对象设置到 autoTLSkey 中. 有意思的是, 这时候当前活动的python线程不一定是获得GIL的线程. 这是因为主线程和子线程都是操作系统原生线程, 所以操作系统可能在主线程和子线程之间切换. 这里要区分的一点是, 系统级别的线程调度与GIL无关. 而python级的线程调度才与GIL有关, 前面也说了, python自己模拟一套线程的调度方式. 所以操作系统级的并不一定意味着GIL的得手, 当所有的线程都完成了初始化的动作之后, 操作系统的线程调度和python的线程调度才会同一. 那时, python的线程调度会强制当前活动线程释放GIL, 而这一操作会触发Event内核对象, 这个触发进而触发操作系统进行线程调度. 这个GIL其实是起到了从python级线程到操作系统级线程调度的桥梁作用. 真正争夺GIL的是在 t_bootstrap 中, 透过 PyEval_AcquireThread 获得GIL的话语权. 到了这一步, 子线程将自己挂起, 操作系统的线程调度不能唤起它, 只有等待python的线程调度强制主线程放弃GIL后, 子线程才回被唤醒. 而子线程被唤醒后, 主线程又将陷入等待中. 当子线程被python的线程调度唤醒后, 做的第一件事就是通过 PyThreadState_Swap(tstate) 设置python维护当前线程状态对象, 如操作系统的进程上下文环境恢复一样.","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python源码阅读","slug":"python源码阅读","permalink":"https://langgithub.github.io/tags/python源码阅读/"}]},{"title":"python源码阅读(4)-python字节码","slug":"python源码阅读(4)-python字节码","date":"2020-06-09T09:29:21.385Z","updated":"2020-06-09T09:29:21.385Z","comments":true,"path":"2020/06/09/python源码阅读(4)-python字节码/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python源码阅读(4)-python字节码/","excerpt":"","text":"PyCodeObject (虚拟机运行时，常量，环境，字节码信息)12345678910111213141516171819202122/* code.h *//* Bytecode object */typedef struct &#123; PyObject_HEAD int co_argcount; /* #arguments, except *args */ int co_nlocals; /* #local variables */ int co_stacksize; /* #entries needed for evaluation stack */ int co_flags; /* CO_..., see below */ PyObject *co_code; /* instruction opcodes */ PyObject *co_consts; /* list (constants used) */ PyObject *co_names; /* list of strings (names used) */ PyObject *co_varnames; /* tuple of strings (local variable names) */ PyObject *co_freevars; /* tuple of strings (free variable names) */ PyObject *co_cellvars; /* tuple of strings (cell variable names) */ /* The rest doesn&apos;t count for hash/cmp */ PyObject *co_filename; /* string (where it was loaded from) */ PyObject *co_name; /* string (name, for reference) */ int co_firstlineno; /* first source line number */ PyObject *co_lnotab; /* string (encoding addr&lt;-&gt;lineno mapping) See Objects/lnotab_notes.txt for details. */ void *co_zombieframe; /* for optimization only (see frameobject.c) */ PyObject *co_weakreflist; /* to support weakrefs to code objects */&#125; PyCodeObject; pyc文件（PyCodeObject持久化）12345678/*import.c*/static void write_compiled_module(PyCodeObject *co, char *cpathname, struct stat *srcstat, time_t mtime)&#123; PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION); /* First write a 0 for mtime */ PyMarshal_WriteLongToFile(0L, fp, Py_MARSHAL_VERSION); PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);&#125; 字节码1234567891011121314151617181920212223241 0 LOAD_CONST 0 (&apos;A&apos;) 3 LOAD_NAME 0 (object) 6 BUILD_TUPLE 1 9 LOAD_CONST 1 (&lt;code object A at 0x7f993a73adb0, file &quot;demo.py&quot;, line 1&gt;) 12 MAKE_FUNCTION 0 15 CALL_FUNCTION 0 18 BUILD_CLASS 19 STORE_NAME 1 (A) 4 22 LOAD_CONST 2 (&lt;code object func at 0x7f993a662a30, file &quot;demo.py&quot;, line 4&gt;) 25 MAKE_FUNCTION 0 28 STORE_NAME 2 (func) 9 31 LOAD_NAME 1 (A) 34 CALL_FUNCTION 0 37 STORE_NAME 3 (a) 10 40 LOAD_NAME 2 (func) 43 CALL_FUNCTION 0 46 POP_TOP 47 LOAD_CONST 3 (None) 50 RETURN_VALUE 注：左边第一列代表指令对应源码中的行号. 第二列代表当前字节码再co_code中的偏移量, 第三列是当前的字节码指令, 最后一列是当前字节码指令的参数. pyc文件是对PyCodeObject的持久化，存放在硬盘，包含了除字节码意外的其他参数。每次执行后会将pyCodeObject持久化下来 使用 python demo.py启动脚步，若demo.py中无import 不会持久化 PyFrameObject12345678910111213141516171819[frameobject.h]typedef struct _frame &#123; PyObject_VAR_HEAD struct _frame *f_back; // 执行环境链的上一个frame PyCodeObject *f_code; // PyCodeObject对象 PyObject *f_builtins; // builtin名字空间 PyObject *f_globals; // global 名字空间 PyObject *f_locals; // local 名字空间 PyObject **f_valuestack; // 运行栈的栈底 PyObject **f_stacktop; // 运行栈的栈顶 PyObject *f_trace; // 异常时调用的句柄 ... int f_lasti; // 上一条字节码指令在f_code中的偏移位置 int f_lineno; // 当前字节码对应的源代码行 int f_iblock; // 当前指令在栈f_blockstack中的索引 ... PyObject *f_localsplus[1]; // locals+stack, 动态内存, 维护(局部变量+运行时栈)所需要的空间 */&#125; PyFrameObject; python只有一个interpreter, 其中维护了一个或多个PyThreadState对象, 这些对象对应的线程轮流使用一个字节码执行引擎. 为了实现线程同步, python通过一个全局解释器锁GIL. 线程执行栈帧（PyFrameObject）,PyFrameObject 对象也是一个变长对象, 每次创建PyFrameObject对象的大小可能是不一样的. 每个栈帧对象都维护了一个PyCodeObject对象,f_builtins, f_globals 和 f_locals 是3个独立的名字空间, LOAD_NAME 将以此从local, global, builtin 3个名字空间顺序查找, 如果都没找到说明名字未定义, 抛出异常, 终止python虚拟机的运行. 搜索规则也就是 LGB 规则. 1234567891011121314151617181920212223242526// 有删改TARGET(LOAD_NAME) &#123; PyObject *name = GETITEM(names, oparg); PyObject *locals = f-&gt;f_locals; PyObject *v; v = PyDict_GetItem(locals, name); Py_XINCREF(v); if (v == NULL) &#123; v = PyDict_GetItem(f-&gt;f_globals, name); Py_XINCREF(v); if (v == NULL) &#123; v = PyDict_GetItem(f-&gt;f_builtins, name); if (v == NULL) &#123; format_exc_check_arg( PyExc_NameError, NAME_ERROR_MSG, name); goto error; &#125; Py_INCREF(v); &#125; &#125; PUSH(v); DISPATCH();&#125; python的异常机制处理中, 最重要的是why所表示的虚拟机状态及PyFrameObject对象中f_blockstack里存放的PyTryBlock对象. 变量why将指明python虚拟机当前是否发生了异常, 而PyTryBlock对象则指示程序员是否为异常设置了 except 代码块和 finally 代码块. python虚拟机处理异常的过程就是 why 和 PyTryBlock 的共同作用下完成的.","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python源码阅读","slug":"python源码阅读","permalink":"https://langgithub.github.io/tags/python源码阅读/"}]},{"title":"python黑魔法-python不一样的懒加载","slug":"python黑魔法-python不一样的懒加载","date":"2020-06-09T09:29:21.385Z","updated":"2020-06-09T09:29:21.385Z","comments":true,"path":"2020/06/09/python黑魔法-python不一样的懒加载/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python黑魔法-python不一样的懒加载/","excerpt":"","text":"懒加载一.一般方式懒加载12345678910111213class Singleton(object): _instance=None @classmethod def instance(clz): if clz._instance is None: clz._instance=Singleton() return clz._instanceprint(Singleton.instance()==Singleton.instance())# 弊端是直接Singleton()就不一样 二.new来实现懒加载1234567891011121314151617class Singleton(object): def __new__(clz): if not hasattr(clz,&quot;_instance&quot;): clz._instance=super(Singleton,clz).__new__(clz) return clz._instanceprint(Singleton()==Singleton())# 注意： __init__ 与 __new__区别与联系 # 1. 在调用__init__前是先调用__new__方法# 2. __new__一定会有return# 3. __new__可以自定义类的实例化 # 如： class PositiveInteger(int): def __new__(clz,value): return super(PositiveInteger,clz).__new__(clz,abs(value)) i=PositiveInteger(-3)# 4.__new__可以实现mateclass 三.new + mateclass实现懒加载123456789101112131415161718class TypeSingleton(type): def __new__(clz, name, base, attrs): # 这里可用用super 即object来创建 ，也可以直接tpye创建类 clz._instance = type.__new__(clz, name, base, attrs) return clz._instanceclass Singleton(metaclass=TypeSingleton): _instance = None @classmethod def instance(clz): return clz._instanceprint(Singleton.instance() == Singleton.instance())#注意：#1. object类是所有内的父类（包含type类）#2. type类是所有实例的父类（object也是type类创建） 四.高阶写法 多线程下懒加载12345678910111213141516171819import threadinglock=threading.Lock()class Singleton(object): def __new__(cls, *args, **kwargs): if not hasattr(cls,&quot;_instance&quot;): try: lock.acquire() if not hasattr(cls, &quot;_instance&quot;): cls._instance=super(Singleton,cls).__new__(cls,*args, **kwargs) finally: lock.release() return cls._instanceprint(Singleton() == Singleton())# 双重检查+单例","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"python源码阅读(3)-python中基本类型","slug":"python源码阅读(3)-python中基本类型","date":"2020-06-09T09:29:21.384Z","updated":"2020-06-09T09:29:21.384Z","comments":true,"path":"2020/06/09/python源码阅读(3)-python中基本类型/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python源码阅读(3)-python中基本类型/","excerpt":"","text":"整型123456789101112131415161718192021222324252627282930313233343536373839404142PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;int&quot;, /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ long_dealloc, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_reserved */ long_to_decimal_string, /* tp_repr */ &amp;long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ (hashfunc)long_hash, /* tp_hash */ 0, /* tp_call */ long_to_decimal_string, /* tp_str */ PyObject_GenericGetAttr, /* tp_getattro */ 0, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LONG_SUBCLASS, /* tp_flags */ long_doc, /* tp_doc */ 0, /* tp_traverse */ 0, /* tp_clear */ long_richcompare, /* tp_richcompare */ 0, /* tp_weaklistoffset */ 0, /* tp_iter */ 0, /* tp_iternext */ long_methods, /* tp_methods */ 0, /* tp_members */ long_getset, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ 0, /* tp_descr_get */ 0, /* tp_descr_set */ 0, /* tp_dictoffset */ 0, /* tp_init */ 0, /* tp_alloc */ long_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; python3统一采用长整型8 bit id() 内存地址; is 是判断内存地址id是否相等，==判断内容是否相等 相同代码块的缓存机制 int str bool 使用相同的常量池对象 在不同代码块下，采用小整数驻留机制[-5,256] 该tp_new函数应该调用subtype-&gt;tp_alloc(subtype, nitems)为对象分配空间。于不可变类型，所有初始化都应该在tp_new，而对于可变类型，大多数初始化应该延迟到tp_init。 字符串12345678910PyObject *PyUnicode_FromString(const char *u)&#123; size_t size = strlen(u); if (size &gt; PY_SSIZE_T_MAX) &#123; PyErr_SetString(PyExc_OverflowError, &quot;input too long&quot;); return NULL; &#125; return PyUnicode_DecodeUTF8Stateful(u, (Py_ssize_t)size, NULL, NULL);&#125; 字符串对象的共享机制intern 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 字符串创建void PyUnicode_InternInPlace(PyObject **p)&#123; PyObject *s = *p; PyObject *t; if (s == NULL || !PyUnicode_Check(s)) return; // 对PyUnicodeObjec进行类型和状态检查 if (!PyUnicode_CheckExact(s)) return; if (PyUnicode_CHECK_INTERNED(s)) return; // 创建intern机制的dict if (interned == NULL) &#123; interned = PyDict_New(); if (interned == NULL) &#123; PyErr_Clear(); /* Don&apos;t leave an exception */ return; &#125; &#125; // 对象是否存在于inter中 t = PyDict_SetDefault(interned, s, s); // 存在， 调整引用计数 if (t != s) &#123; Py_INCREF(t); Py_SETREF(*p, t); return; &#125; /* The two references in interned are not counted by refcnt. The deallocator will take care of this */ Py_REFCNT(s) -= 2; _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;&#125;[unicodeobjec.c]PyObject * PyUnicode_DecodeUTF8Stateful(const char *s, Py_ssize_t size, const char *errors, Py_ssize_t *consumed)&#123; ... /* ASCII is equivalent to the first 128 ordinals in Unicode. */ if (size == 1 &amp;&amp; (unsigned char)s[0] &lt; 128) &#123; if (consumed) *consumed = 1; return get_latin1_char((unsigned char)s[0]); &#125; ...&#125;static PyObject *unicode_latin1[256] = &#123;NULL&#125;;static PyObject* get_latin1_char(unsigned char ch)&#123; PyObject *unicode = unicode_latin1[ch]; if (!unicode) &#123; unicode = PyUnicode_New(1, ch); if (!unicode) return NULL; PyUnicode_1BYTE_DATA(unicode)[0] = ch; assert(_PyUnicode_CheckConsistency(unicode, 1)); unicode_latin1[ch] = unicode; &#125; Py_INCREF(unicode); return unicode;&#125;总结：先对所创建的字符串（只有一个字符）对象进行intern操作，再将inter的结果缓存到字符缓冲池 unicode_latin1 中,两者都是指向同一个字符对象。 intern机制中的PyUnicodObject采用了特殊的引用计数机制。将一个PyUnicodeObject对象a的PyObject指针作为key和valu添加到intered中时，PyDictObjec对象会通过这两个指针对a的引用计数进行两次+1操作。这会造成a的引用计数在python程序结束前永远不会为0，这也是 Py_REFCNT(s) -= 2; 将计数减2的原因。 字符串对象有两种状态，一个是 SSTATE_INTERNED_IMMORTAL 另一个是 SSTATE_INTERNED_MORTAL， 处于SSTATE_INTERNED_IMMORTAL这种状态的字符串永远不会被销毁，它将与python虚拟机共存亡。 PyUnicode_InternInPlace 函数只能创建SSTATE_INTERNED_MORTAL 状态的对象 python中使用 “+” 符号进行字符串拼接， 这种方法效率极低，建议使用jion list123456789101112131415161718192021222324252627282930313233343536typedef struct &#123; PyObject_VAR_HEAD // ob_item为指向元素列表的指针，实际上python中list[0]就是ob_item[0] PyObject **ob_item; Py_ssize_t allocated;&#125; PyListObject;PyObject * PyList_New(Py_ssize_t size)&#123; PyListObject *op; ... // 缓冲池是否可用 if (numfree) &#123; numfree--; op = free_list[numfree]; _Py_NewReference((PyObject *)op); &#125; else &#123; // 缓冲池不可用时 op = PyObject_GC_New(PyListObject, &amp;PyList_Type); if (op == NULL) return NULL; &#125; // 申请为PyListObject对象中维护的元素列表空间 if (size &lt;= 0) op-&gt;ob_item = NULL; else &#123; // 空间申请size个空间的数组并重置0 op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); &#125; Py_SIZE(op) = size; op-&gt;allocated = size; _PyObject_GC_TRACK(op); return (PyObject *) op;&#125; 缓冲池 free_list 中最多会维护80个PyListObject对象 123#define PyList_MAXFREELIST 80static PyListObject *free_list[PyList_MAXFREELIST];static int numfree = 0; 设置元素 list[2] = 200 123456789101112131415161718192021222324int PyList_SetItem(PyObject *op, Py_ssize_t i, PyObject *newitem)&#123; PyObject **p; // 索引越界检查 if (i &lt; 0 || i &gt;= Py_SIZE(op)) &#123; Py_XDECREF(newitem); PyErr_SetString(PyExc_IndexError, &quot;list assignment index out of range&quot;); return -1; &#125; // 找到ob_item[i] p = ((PyListObject *)op) -&gt; ob_item + i; Py_XSETREF(*p, newitem); return 0;&#125;#define Py_XSETREF(op, op2) \\ do &#123; \\ PyObject *_py_tmp = (PyObject *)(op); \\ (op) = (op2); \\ Py_XDECREF(_py_tmp); \\ &#125; while (0) 插入元素 123456789101112131415161718192021222324252627282930313233343536[longobject.c]int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem)&#123; // 类型检查 if (!PyList_Check(op)) &#123; PyErr_BadInternalCall(); return -1; &#125; return ins1((PyListObject *)op, where, newitem);&#125;static intins1(PyListObject *self, Py_ssize_t where, PyObject *v)&#123; Py_ssize_t i, n = Py_SIZE(self); PyObject **items; if (list_resize(self, n+1) &lt; 0) return -1; // 确定插入点 if (where &lt; 0) &#123; where += n; if (where &lt; 0) where = 0; &#125; if (where &gt; n) where = n; items = self-&gt;ob_item; // 元素后移 for (i = n; --i &gt;= where; ) items[i+1] = items[i]; Py_INCREF(v); items[where] = v; return 0;&#125; 删除元素 1234567891011121314151617181920static PyObject *listremove(PyListObject *self, PyObject *v)&#123; Py_ssize_t i; for (i = 0; i &lt; Py_SIZE(self); i++) &#123; int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ); // 如果相等, 删除元素 if (cmp &gt; 0) &#123; if (list_ass_slice(self, i, i+1, (PyObject *)NULL) == 0) Py_RETURN_NONE; return NULL; &#125; else if (cmp &lt; 0) return NULL; &#125; PyErr_SetString(PyExc_ValueError, &quot;list.remove(x): x not in list&quot;); return NULL;&#125; Dict闭散列法也称为开放定址法.当产生冲突时,python会通过一个二次探测函数f,计算下一个候选索引, 如果索引不可用,就再次用f探测.直到找到一个可用的位置.12345678910111213141516171819202122232425262728293031323334353637383940414243[dict-common.h]typedef struct &#123; Py_hash_t me_hash; PyObject *me_key; PyObject *me_value;&#125; PyDictKeyEntry;[dictobject.h]PyObject * PyDict_New(void)&#123; PyDictKeysObject *keys = new_keys_object(PyDict_MINSIZE); if (keys == NULL) return NULL; return new_dict(keys, NULL);&#125;static PyDictKeysObject *new_keys_object(Py_ssize_t size)&#123; PyDictKeysObject *dk; Py_ssize_t es, usable; usable = USABLE_FRACTION(size); es = 4; if (size == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; 0) &#123; // 使用缓冲池 dk = keys_free_list[--numfreekeys]; &#125; else &#123; dk = PyObject_MALLOC(sizeof(PyDictKeysObject) - Py_MEMBER_SIZE(PyDictKeysObject, dk_indices) + es * size + sizeof(PyDictKeyEntry) * usable); &#125; DK_DEBUG_INCREF dk-&gt;dk_refcnt = 1; dk-&gt;dk_size = size; dk-&gt;dk_usable = usable; dk-&gt;dk_lookup = lookdict_unicode_nodummy; dk-&gt;dk_nentries = 0; // hash table 初始化 memset(&amp;dk-&gt;dk_indices.as_1[0], 0xff, es * size); memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable); return dk;&#125; PyDict_MINSIZE 值为8, 默认情况下, PyDict_New会创建8个entry Unused： me_key == me_value == NULL (Unused是entry的初始状态，key和value都为NULL。插入元素时，Unused状态转换成Active状态。这是me_key为NULL的唯一情况。) Active： me_key != NULL and me_key != dummy 且 me_value != NULL(插入元素后，entry就成了Active状态，这是me_value唯一不为NULL的情况，删除元素时Active状态刻转换成Dummy状态。) Dummy： me_key == dummy 且 me_value == NULL(Dummy是一种类似的伪删除方式，保证探测链的连续性 ABC 删除B 保证A-&gt;c) lookdict(k,v) 1. index &lt;- hash1(k)，freeslot&lt;-Null,根据me_key与me_value选择2、3、4一个执行; 2. 查看index处的值处于’有效元素占据‘状态，判断data[index]与v是否一致(地址或内容),一致,则返回查找成功;否则转5 3. index所指向的位置处于’原始空‘状态，查找失败，若freeslot==Null返回index;否则返回freeslot;转5 4. index所指向的位置处于’有效元素离去‘状态，freeslot&lt;-index, 转5 5. index &lt;- hash2(index),，转2 加载因子 2/3 ，大于则扩容","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python源码阅读","slug":"python源码阅读","permalink":"https://langgithub.github.io/tags/python源码阅读/"}]},{"title":"python源码阅读(2)-pyObject","slug":"python源码阅读(2)-pyObject","date":"2020-06-09T09:29:21.384Z","updated":"2020-06-09T09:29:21.384Z","comments":true,"path":"2020/06/09/python源码阅读(2)-pyObject/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python源码阅读(2)-pyObject/","excerpt":"","text":"pyObject12345678910111213[object.h]typedef struct _object &#123; # Py_DEBUG implies Py_TRACE_REFS # Py_TRACE_REFS 则对象结构会变成是一个双向列表, 所有堆中活动的对象都在这列表中,Py_TRACE_REFS 则对象结构会变成是一个双向列表,所有堆中活动的对象都在这列表中,与debug相关 _PyObject_HEAD_EXTRA # typedef int Py_ssize_t; # ob_refcnt 为int类型的应用计数 Py_ssize_t ob_refcnt; # type 结构体 struct _typeobject *ob_type;&#125; PyObject; type123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105[typestruct.h]typedef struct _typeobject &#123; # 扩展 ob_size 为对象提供长度的概念 PyObject_VAR_HEAD # 开发引用的 const char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */ # 计算该类型实例的字节大小 Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ # 指向实例析构函数的指针 destructor tp_dealloc; # 保留插槽，以前用于Python 2.x中的打印格式。 printfunc tp_print; # 指向get-attribute-string函数的可选指针。 getattrfunc tp_getattr; # 指向get-attribute-string函数的可选指针。 setattrfunc tp_setattr; # 指向另一个结构的指针 PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2) or tp_reserved (Python 3) */ # 指向实现内置函数的函数的可选指针 repr()。 reprfunc tp_repr; /* Method suites for standard classes */ # 该结构包含仅与实现数字协议的对象相关的字段 PyNumberMethods *tp_as_number; # 该结构包含仅与实现数字协议的对象相关的字段 PySequenceMethods *tp_as_sequence; # 该结构包含仅与实现数字协议的对象相关的字段 PyMappingMethods *tp_as_mapping; /* More standard operations (here for binary compatibility) */ # 指向实现内置函数的函数的可选指针 hash()。 hashfunc tp_hash; ternaryfunc tp_call; reprfunc tp_str; getattrofunc tp_getattro; setattrofunc tp_setattro; /* Functions to access object as input/output buffer */ # 结构包含仅与实现缓冲区接口的对象相关的字段 PyBufferProcs *tp_as_buffer; /* Flags to define presence of optional/expanded features */ # 如果这样的标志位是清除的，则不能访问它所保护的类型字段， unsigned long tp_flags; const char *tp_doc; /* Documentation string */ /* call function for all accessible objects */ traverseproc tp_traverse; /* delete references to contained objects */ inquiry tp_clear; /* rich comparisons */ richcmpfunc tp_richcompare; /* weak reference enabler */ Py_ssize_t tp_weaklistoffset; /* Iterators */ getiterfunc tp_iter; iternextfunc tp_iternext; /* Attribute descriptor and subclassing stuff */ struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members; struct PyGetSetDef *tp_getset; struct _typeobject *tp_base; PyObject *tp_dict; descrgetfunc tp_descr_get; descrsetfunc tp_descr_set; Py_ssize_t tp_dictoffset; initproc tp_init; allocfunc tp_alloc; newfunc tp_new; freefunc tp_free; /* Low-level free-memory routine */ inquiry tp_is_gc; /* For PyObject_IS_GC */ PyObject *tp_bases; PyObject *tp_mro; /* method resolution order */ PyObject *tp_cache; PyObject *tp_subclasses; PyObject *tp_weaklist; destructor tp_del; /* Type attribute cache version tag. Added in version 2.6 */ unsigned int tp_version_tag; destructor tp_finalize;&#125; PyTypeObject; 这些字段中还包括其他python协议的字段，如下所示。 1.数字协议 - 实现此协议的类型将具有PyNumberMethods *tp_as_number 字段的实现。此字段是对一组实现数字操作的函数的引用，这意味着该类型将支持具有包含在tp_as_number 集合中的实现的算法。例如，非数字set类型在此字段中有一个条目，因为它支持算术运算，例如-，&lt;=等等。 2.序列协议 - 实现此协议的类型将在PySequenceMethods *tp_as_sequence 字段中具有值。这意味着该类型将支持部分或全部的的序列的操作 ，例如len，in等 3.映射协议 - 实现此协议的类型将具有一个值PyMappingMethods *tp_as_mapping。这将使这种类型的实例像python词典一样使用字典下标语法来设置和访问键值映射。 4.迭代器协议 - 实现此协议的类型将在getiterfunc tp_iter 可能的iternextfunc tp_iternext字段中具有值，并且可以使用类型的实例，如python迭代器。 5.缓冲协议 - 实现此协议的类型将在该PyBufferProcs *tp_as_buffer 字段中具有值。这些函数将允许访问类型的实例作为输入/输出缓冲区。 垃圾回收机制源码中, 通过 Py_INCREF(op) 和 Py_DECREF(op) 两个宏来增加和较少引用计数的. 12345678910111213[object.h]#define Py_INCREF(op) ( \\ ((PyObject *)(op))-&gt;ob_refcnt++)#define Py_DECREF(op) \\ do &#123; \\ PyObject *_py_decref_tmp = (PyObject *)(op); \\ if (--(_py_decref_tmp)-&gt;ob_refcnt != 0) \\ _Py_CHECK_REFCNT(_py_decref_tmp) \\ else \\ _Py_Dealloc(_py_decref_tmp); \\ &#125; while (0) 当一个对象的引用计数减少到0后,Py_DECREF(op)会调用该对象”析构函数”进行释放.12#define _Py_Dealloc(op) ( \\(*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python源码阅读","slug":"python源码阅读","permalink":"https://langgithub.github.io/tags/python源码阅读/"}]},{"title":"okhttp逆向","slug":"okhttp逆向","date":"2020-06-09T09:29:21.383Z","updated":"2020-06-09T09:29:21.383Z","comments":true,"path":"2020/06/09/okhttp逆向/","link":"","permalink":"https://langgithub.github.io/2020/06/09/okhttp逆向/","excerpt":"","text":"okhttp逆向RequestBody 转换成String123456789RequestBody d2 = a2.d();Buffer buffer = new Buffer();d2.writeTo(buffer);Charset charset = a;MediaType contentType = d2.contentType();if (contentType != null) &#123; charset = contentType.a(a);&#125;str = this.d.a(a3 + &quot;|&quot; + this.d.a(a3 + &quot;|&quot; + buffer.a(charset) + &quot;|empty|&quot; + this.b));","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://langgithub.github.io/tags/Android/"}]},{"title":"python源码阅读(1)-python代码编译","slug":"python源码阅读(1)-python代码编译","date":"2020-06-09T09:29:21.383Z","updated":"2020-06-09T09:29:21.384Z","comments":true,"path":"2020/06/09/python源码阅读(1)-python代码编译/","link":"","permalink":"https://langgithub.github.io/2020/06/09/python源码阅读(1)-python代码编译/","excerpt":"","text":"python 源码编译 PyTokenizer_FromFile函数位于Parser/parsetok.c从左到右扫描python源文件，从上到下标记文件的内容 解析树生成规则都在Include/token.h（终端）和Include/graminit.h（终端）头文件中指定 PyAST_FromNode函数Python/ast.c处理从给定的解析树生成AST。生成AST后，现在可以从AST生成字节码了 123456789import parsercst = parser.suite(&apos;print &quot;Hello World&quot;&apos;)print cst.tolist()# [257, [267, [268, [269, [272, [1, &apos;print&apos;], [304, [305, [306, [307, [308, [310, [311, [312, [313, [314, [315, [316, [317, [318, [3, &apos;&quot;Hello World&quot;&apos;]]]]]]]]]]]]]]]]], [4, &apos;&apos;]]], [4, &apos;&apos;], [0, &apos;&apos;]] import astastrst = ast.parse(&apos;print &quot;Hello World&quot;&apos;)print ast.dump(astrst)# Module(body=[Print(dest=None, values=[Str(s=&apos;Hello World&apos;)], nl=True)]) 构建符号表（不懂）作用域相关识别 从AST到代码对象(表达式是中序遍历，在计算机运算是采用后序遍历) pyc 概括Python的整体架构可分为3个模块,一个是内建模块. 一个是python内核, 一个是python虚拟机. 内建模块就诸如 import os 时,这个os就是Python的内建模块.Python内核就包括定义Python的对象/类型系统,处理垃圾回收机制等.虚拟机就是解释器,对Python代码进行词法语法分析等.","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python源码阅读","slug":"python源码阅读","permalink":"https://langgithub.github.io/tags/python源码阅读/"}]},{"title":"pymongo","slug":"pymongo","date":"2020-06-09T09:29:21.383Z","updated":"2020-06-09T09:29:21.383Z","comments":true,"path":"2020/06/09/pymongo/","link":"","permalink":"https://langgithub.github.io/2020/06/09/pymongo/","excerpt":"","text":"mongodb 读写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- coding: utf-8 -*-import pymongofrom scrapy import logfrom scrapy.conf import settingsimport threadingfrom openpyxl import Workbookimport redisfrom scrapy.pipelines.images import ImagesPipelinefrom scrapy.exceptions import DropItemimport scrapyimport pymysqlfrom twisted.enterprise import adbapiimport randomimport sys# Define your item pipelines here## Don&apos;t forget to add your pipeline to the ITEM_PIPELINES setting# See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html# 单例模式创建MongoPiplineLock = threading.Lock()class MongoPipeline(object): # 定义静态变量实例 __instance = None def __init__(self): pass def __new__(cls, *args, **kwargs): if not cls.__instance: try: Lock.acquire() # double check if not cls.__instance: cls.client = pymongo.MongoClient(settings[&apos;MONGO_URI&apos;]) cls.db = cls.client[settings[&apos;MONGO_DATABASE&apos;]] cls.__instance = super(MongoPipeline, cls).__new__(cls, *args, **kwargs) finally: Lock.release() return cls.__instance def dorp_connection(self,db_name): #删除数据库 return self.db[db_name].drop() def ensure_index(self,db_name,unique_id): #建立索引 return self.db[db_name].ensure_index(unique_id,unique=True) def insert(self, items, db_name): self.db[db_name].insert(items) def find(self,db_name,conditions,return_range): return self.db[db_name].find(conditions,return_range) def update(self,db_name,conditions,info): return self.db[db_name].update(conditions,info,False) def upsert(self,db_name,conditions,info): return self.db[db_name].update(conditions,info,True) def update_many(self,db_name,conditions,info): return self.db[db_name].update_many(conditions,info,False)","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"ptrace注入","slug":"ptrace注入","date":"2020-06-09T09:29:21.383Z","updated":"2020-06-09T09:29:21.383Z","comments":true,"path":"2020/06/09/ptrace注入/","link":"","permalink":"https://langgithub.github.io/2020/06/09/ptrace注入/","excerpt":"","text":"ptrace注入 frida 修改debuger 的注入ptrace描述 https://langgithub.github.io/file/PTRACE函数代码分析.pdf https://github.com/langgithub/PtraceInject demo地址 1234567891011121314151617181920212223242526272829303132名字ptrace – 进程跟踪形式#include &lt;sys/ptrace.h&gt;int ptrace(int request, int pid, int addr, int data);􏰀述Ptrace 􏰁供了一种父进程可以控制子进程运行，并可以检查和改变它的核心 image。它 主要用于实现断点调试。一个被跟踪的进程运行中，直到发生一个信号。则进程被中止，并 且通知其父进程。在进程中止的状态下，进程的内存空间可以被读写。父进程还可以使子进 程继续执行，并选择是否是否忽略引起中止的信号。Request 参数决定了系统调用的功能: PTRACE_TRACEME本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。PTRACE_PEEKTEXT, PTRACE_PEEKDATA 从内存地址中读取一个字节，内存地址由 addr 给出。PTRACE_PEEKUSR从 USER 区域中读取一个字节，偏移量为 addr。PTRACE_POKETEXT, PTRACE_POKEDATA 往内存地址中写入一个字节。内存地址由 addr 给出。PTRACE_POKEUSR往 USER 区域中写入一个字节。偏移量为 addr。PTRACE_SYSCALL, PTRACE_CONT重新运行。PTRACE_KILL杀掉子进程，使它退出。PTRACE_SINGLESTEP设置单步执行标志PTRACE_ATTACH 跟踪指定 pid 进程。PTRACE_DETACH结束跟踪 Intel386 特有:PTRACE_GETREGS读取寄存器PTRACE_SETREGS设置寄存器PTRACE_GETFPREGS读取浮点寄存器PTRACE_SETFPREGS设置浮点寄存器 注入流程 两种实现 利用shellcode 直接调用dlopen,dlsyn函数 流程 attch到远程进程 -&gt; 保存寄存器环境 -&gt; 远程调用mmap函数申请内存空间 -&gt; 向远程进程内存空间写入加载模块名和调用函数-&gt; 远程调用dlopen函数打开注入模块 -&gt; 远程调用dlsym函数获取需要调用的函数地址 -&gt; 远程调用被注入模块的函数-&gt; 恢复寄存器环境 -&gt; 从远程进程detach总结：远程进程暂停 -&gt; ptrace函数调用,其他函数远程调用 -&gt; 进程恢复 获取模块基址: “/proc/pid/maps”相对偏移地址=本地进程函数地址-本地进程的模块基址获取远程进程函数地址=远程进程模块基址+相对偏移地址 ptrace注入实现： attach 到远程进程 读取和写入寄存器值 远程进程的内存读取和写入数据 远程调用函数 核心 ： 修改pc寄存器为需要执行的函数地址 lr寄存器致为0 mmap “system/lib/libc.so” dlopen,dlsym,dlclose “/system/bin/linker” 恢复寄存器值 detach进程","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"ptrace","slug":"ptrace","permalink":"https://langgithub.github.io/tags/ptrace/"}]},{"title":"openpyxl","slug":"openpyxl","date":"2020-06-09T09:29:21.383Z","updated":"2020-06-09T09:29:21.383Z","comments":true,"path":"2020/06/09/openpyxl/","link":"","permalink":"https://langgithub.github.io/2020/06/09/openpyxl/","excerpt":"","text":"Excel读写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# encoding: utf-8&quot;&quot;&quot;--------------------------------------@describe Excel python 读取@version: 1.0@project: test@file: excel.py@author: yuanlang @time: 2019-03-12 14:53---------------------------------------&quot;&quot;&quot;from openpyxl.reader.excel import load_workbookimport osclass ExcelReader(object): def reader_all_file(self,root_path): path = os.listdir(root_path) for file in path: self.reader_file(root_path+&quot;/&quot;+file) def reader_file(self,path): # 读取excel2007文件 wb = load_workbook(filename=r&apos;&#123;0&#125;&apos;.format(path)) # 显示有多少张表 # print (&quot;Worksheet range(s):&quot;, wb.get_named_ranges()) # print (&quot;Worksheet name(s):&quot;, wb.get_sheet_names()) # 取第一张表 sheetnames = wb.sheetnames ws = wb[sheetnames[0]] # 显示表名，表行数，表列数 # print (&quot;Work Sheet Titile:&quot;, ws.title) # print (&quot;Work Sheet Rows:&quot;, ws.max_row) # print (&quot;Work Sheet Cols:&quot;, ws.max_column) # 建立存储数据的字典 data_dic = &#123;&#125; data_list = [] # 把数据存到字典中 for rx in range(1, ws.max_row + 1): temp_list = [] pid = rx w1 = ws.cell(row=rx, column=1).value w2 = ws.cell(row=rx, column=2).value w3 = ws.cell(row=rx, column=3).value w4 = ws.cell(row=rx, column=4).value temp_list = [w1, w2, w3, w4] data_dic[pid] = temp_list if w2 is not None or w3 is not None or w4 is not None: if w4 != &apos;市辖区&apos; and w1 != &apos;代码&apos;: data_list.append(temp_list) # 打印字典数据个数 # print (&apos;Total:%d&apos; % len(data_dic)) #print(data_list) for _list in data_list: if _list[3] is not None: print(str(_list[0])[:6]+&quot;,&quot;+_list[3]+&quot;,&quot;+str(_list[0])[:3]+&quot;000&quot;) # print (json.dumps(data_dic, encoding=&quot;UTF-8&quot;, ensure_ascii=False))reader=ExcelReader()reader.reader_all_file(os.path.dirname(__file__)+&quot;/5w放款名单-20190312.xlsx&quot;)","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"Netty-learn","slug":"netty-learn","date":"2020-06-09T09:29:21.382Z","updated":"2020-06-09T09:29:21.382Z","comments":true,"path":"2020/06/09/netty-learn/","link":"","permalink":"https://langgithub.github.io/2020/06/09/netty-learn/","excerpt":"","text":".1. Netty-learn Netty-learn Gerneral Nio buffer Nio网络基本流程 Zero copy Reactor设计模式 NioEventLoopGroup Netty 组件间关系 Netty处理器 Tcp的黏包，拆包 Future .1.1. Gerneral.1.1.1. Nio buffer capacity 总数量 limit 用于限制读写 position 下一个读写位置 https://www.bilibili.com/video/av33707223?p=37 节 去掉buffer.clear()注释掉后分析 position&lt;limit&lt;capacity .1.1.2. Nio网络基本流程 selector 办事大厅 获取ServerSocketChannel 设置ServerSocketChannel 属性（是否阻塞） 获取ServerSocket 给ServerSocket绑定端口 将通道注册到selector 循环selecor 获取selectorKey 判断selectorKey类型返回channel 处理 移除selectorKey .1.1.3. Zero copy 缺少由user model缓存到system kernel缓存；由system kernel缓存到user model缓存下内容拷贝2次 (用户态优化) System kernel下kernel buffer到socket buffer内容拷贝改为文件描述符拷贝 FileChannel transferto transferFrom 使用零拷贝 .1.1.4. Reactor设计模式 Handle(句柄和描述符，产生事件)：本质表示一种资源，该资源（如何写入，写出）可表示一个个事件。 Synchronous Evnet demultiplexer(同步事件分离器)：它本身是一个系统调用，用于等待事件的发生（事件可能一个，多个），调用方在调用它的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止，位于linux来说，同步事件分离器就是常用的I/O多路复用机制，比如说select,poll,epoll等，在Java NIO中，同步事件分离器对于组件selector,对于的阻塞方法select。 Event Handler（事件处理器）：本身由多个回调方法构成，这些回调方法构成了与应用相关的对于某个事件的反馈机制。java NIO中没有，netty中有（比如SimpleChannelInBand,SimpleChanneloutBand） Concrete Event Handler（具体事件处理器）：它是事件处理器的实现 ，从而实现特定的逻辑（比如自己写的MyHandler） Initation Dispatcher(初始分发器)：实际上就是Reactor角色，它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又是提供了应用进行事件处理器的注册，删除等，它本身是整个事件处理器的核心所在，initiaion dispathcer会通过同步事件分离器来等待事件的发生，一旦事件发生，Initation Dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调函数来处理这些事件。 .1.1.5. NioEventLoopGroup NioEventLoopGroup extends MultithreadEventLoopGroup ,初始化时需要传入线程数（defalt=Math.max(1, SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, Runtime.getRuntime().availableProcessors() * 2))） 线程数大小极为EventExecutor 数组大小 EventLoopGoup包含多个EventLoop 一个EventLoop在他整个生命周期中都只会与唯一的一个Thread进行绑定 所有的EventLoop所处理的各种I/O事件都将在它所关联的Thread上处理 一个channel在它的整个生命周期中只会注册在一个EventLoop上 一个EventLoop在运行过程中，会被分配给一个或多个channel（多个channel会被注册到一个Selector上） handler中业务是单线程执行，不需要并发控制，因此不能做耗时操作 Channel的实现一定是线程安全的，因此，我们可以存储一个channel 引用，并且在需要向远端发送数据时，通过这个引用来调用channel相关的方法，即使当时有很多线程都在使用它也不会出现多线程问题，而且。消息一定会按照顺序发送出去 在业务开发中，不要将长时间执行的耗时任务放置到EventLoop的执行队列中，因此它会一直阻塞该线程所对于的所有channel上的其他执行任务，如果我们需要阻塞调用或耗时操作，那么我们需要使用一个专门的EventExcutor（业务线程池） 使用 java eventExcutor 借助pipeline中添加channelHandler调用的addLast(group , handler) .1.1.6. Netty 组件间关系 main Reactor 和 sub Reactor分别对于netty 中的bossGroup 和workGroup，selector 对于EventLoop ChannelInitializer（采用模板模式） 继承 ChannelInboundHandlerAdapter 继承 ChannelHandlerAdapter并且实现了ChannelInboundHandler接口，这里采用适配器模式（将ChannelHandlerContext（两空） 转化成ChannelInboundHandler（三空）接口）。以上是ChannelHandler接口转换 ChannelPipline 中存放ChannelHandler，包含InBoundHandler和OutBoundHandler Channel中可以获取其对于的ChannelPipline ，ChannelPipline 也关联着唯一的Channel ChannelHandlerContext 何以获取channel ChannelHandler ChannelPipline ，自身通过双向链表存储 对于netty消息发送方式，写入到channel中的消息会从末尾开始流动，写入ChannelHandlerContext将会从ChannelPipeline中下一个ChannelHandler开始流动 .1.1.7. Netty处理器 netty处理器包含入栈处理器和出栈处理器 入栈处理器顶层ChannelInboundHandler 出栈处理器顶层ChannelOutboundHandler 编码：message -&gt; byte（ChannelOutboundHandler） 解码：byte -&gt; message（ChannelInboundHandler） ReplayingDecoder extends ByteToMessageDecoder 会不断重试判断读取是否满足，因此不需要数据读取大小判断 .1.1.8. Tcp的黏包，拆包 黏包：tcp 在传输消息时，可能数据不够发送条件，需要合并消息 拆包：tcp 在数据接受时候，可能会收到多个消息合并后的数据包 netty 提供前一条消息与下一条消息分割的分割符号识别 .1.1.9. Future JDK提供的Future只能通过手工方式检查结果，而这个操作是会阻塞的；Netty则对ChannelFuture进行了增强，通过ChannelFutrueListener以回调方式来获取执行结果，去除了手工检查阻塞的操作，值得注意的是：ChannelFutureListener的OperationComplete方法是由I/O线程执行的，因此要注意的是不要在这里执行耗时操作，否则需要通过另外的线程或线程池来执行","categories":[{"name":"code-java","slug":"code-java","permalink":"https://langgithub.github.io/categories/code-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://langgithub.github.io/tags/java/"},{"name":"netty","slug":"netty","permalink":"https://langgithub.github.io/tags/netty/"}]},{"title":"netty-sekiro","slug":"netty-sekiro","date":"2020-06-09T09:29:21.382Z","updated":"2020-06-09T09:29:21.382Z","comments":true,"path":"2020/06/09/netty-sekiro/","link":"","permalink":"https://langgithub.github.io/2020/06/09/netty-sekiro/","excerpt":"","text":".1. netty-sekiro netty-sekiro Gerneral sekiro组织架构 人观流程 解决前一版本bug sekiro 基于xposed主动hook demo .1.1. GerneralSEKIRO 是一个android下的API服务暴露框架，可以用在app逆向、app数据抓取、android群控等场景。 sekiro 是用springboot,和netty（nio）开发的高效通讯框架 sekiro 不仅支持短连接，也支持长链接，能实时返回手机是否在线的技术 sekiro 中使用了netty代表异步请求，服务器资源使用少 sekiro 不依赖xposed架构，能与一切hook框架解耦合 .1.1.1. sekiro组织架构 sekiro包含移动端开发和服务器端开发 服务器端是用Springboot管理各种组件，在Springboot bean（InitializingBean）初始化 afterPropertiesSet完成会启动两个nio服务，分别监听5600，5601端口. 5601 端口的nio服务器用于处理http请求，即处理调用接口处理。 RBHttpRequestDecoder 用于http解码 HttpResponseEncoder 用于http编码 HttpObjectAggregator 最大报文处理 HttpRequestDispatcher 对拿到的http请求处理 HttpRequestDispatcher 中接受request请求，封装成SekiroNatMessage 发送给移动端，并且生成一个新任务设置事件回调接口并保存到concurrentmap中. 5600 端口的nio服务器用于处理tcp请求，与移动端数据交互 SekiroMessageEncoder tcp编码 SekiroMessageDecoder tcp解码 ServerIdleCheckHandler 服务器空闲检查 读空闲，写空闲 NatServerChannelHandler 自定义处理与移动端数据交互 pipeline中的handler是依次执行，符合条件执行 SekiroNatMessage 是移动端与服务器交互数据的对象 SekiroNatMessage 目前包含3中类型 SekiroNatMessage.TYPE_HEARTBEAT 用于处理心跳检查 SekiroNatMessage.C_TYPE_REGISTER 用于移动端action注册 SekiroNatMessage.TYPE_INVOKE 用于服务器介绍到客户端hook信息，并将信息返回给调用者 SekiroNatMessage.C_TYPE_REGISTER 实际是将NatClient（封装移动端与服务端的channel，clietid,group信息）保存到natClientMap，poolQueue中 SekiroNatMessage.TYPE_INVOKE 从channel中获取clientid，group，换取task任务，调用回调函数。即sekiroResponseEvent.onSekiroResponse(sekiroNatMessage);是将移动端hook后的返回信息（是否注册手机号）传递给回调函数，回调函数会返回response给调用者 移动端即client客户端包含一下handler SekiroMessageDecoder SekiroMessageEncoder ClientIdleCheckHandler 与服务器连接空闲检查 ClientChannelHandler 自定义处理服务器端发来的数据 ClientChannelHandler将服务器端发来的hook请求取出对于的action 调用 sekiroResponse.success 触发channel.writeAndFlush(sekiroNatMessage); 将hook信息发送到服务端 .1.1.2. 人观流程总结：4（调用者的request）-&gt;7（发送hook请求注册回调）-&gt; 12（移动端寻找action调用） -&gt; 13（返回hook到的信息） -&gt; 10（服务器端收到hook消息回调给调用者） 其中7，10步骤都是异步，不断发送和接受 如何确保同一任务 这里采用 clientId + “—“ + group + “—“ + seq; 代表唯一id .1.1.3. 解决前一版本bugSekiroMessageDecoder 代替原理啊的SekiroNatMessageDecoder（更名为SekiroNatMessageDecoderError） .1.1.4. sekiro 基于xposed主动hook demohttps://github.com/langgithub/hello","categories":[{"name":"code-java","slug":"code-java","permalink":"https://langgithub.github.io/categories/code-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://langgithub.github.io/tags/java/"},{"name":"netty","slug":"netty","permalink":"https://langgithub.github.io/tags/netty/"}]},{"title":"mysql 索引","slug":"mysql 索引","date":"2020-06-09T09:29:21.382Z","updated":"2020-06-09T09:29:21.382Z","comments":true,"path":"2020/06/09/mysql 索引/","link":"","permalink":"https://langgithub.github.io/2020/06/09/mysql 索引/","excerpt":"","text":"从数据结构角度1、B+树索引(O(log(n)))：关于B+树索引，可以参考MySQL索引背后的数据结构及算法原理 http://blog.codinglabs.org/articles/theory-of-mysql-index.html 2、hash索引： a 仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询 b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引 c 只有Memory存储引擎显示支持hash索引 3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了） 4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引） 从物理存储角度1、聚集索引（clustered index） 2、非聚集索引（non-clustered index） 从逻辑角度1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值 2、普通索引或者单列索引 3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合 4、唯一索引或者非唯一索引 5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建 CREATE TABLE table_name[col_name data type][unique|fulltext|spatial][index|key]index_name[asc|desc] 1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引； 2、index和key为同义词，两者作用相同，用来指定创建索引 3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择； 4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值； 5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； 6、asc或desc指定升序或降序的索引值存储 MySQL里的索引类型主要有以下几种。 B-Tree索引 最常见的索引类型，基于B-Tree数据结构。B-Tree的基本思想是，所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。所以B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。 Hash索引 基于hash表。所以这种索引只支持精确查找，不支持范围查找，不支持排序。这意味着范围查找或ORDER BY都要依赖server层的额外工作。目前只有Memory引擎支持显式的hash索引（但是它的hash是nonunique的，冲突太多时也会影响查找性能）。Memory引擎默认的索引类型即是Hash索引，虽然它也支持B-Tree索引。 例子： CREATETABLEtesthash ( fnameVARCHAR(50)NOTNULL, lnameVARCHAR(50)NOTNULL,KEYUSINGHASH(fname))ENGINE=MEMORY; Spatial (R-Tree)（空间）索引 只有MyISAM引擎支持，并且支持的不好。可以忽略。 Full-text索引 主要用来查找文本中的关键字，而不是直接与索引中的值相比较。Full-text索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的WHERE语句的参数匹配。你可以对某列分别进行full-text索引和B-Tree索引，两者互不冲突。Full-text索引配合MATCH AGAINST操作使用，而不是一般的WHERE语句加LIKE。","categories":[{"name":"数据存储-mysql","slug":"数据存储-mysql","permalink":"https://langgithub.github.io/categories/数据存储-mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://langgithub.github.io/tags/mysql/"}]},{"title":"mysql 参数优化","slug":"mysql 参数优化","date":"2020-06-09T09:29:21.382Z","updated":"2020-06-09T09:29:21.382Z","comments":true,"path":"2020/06/09/mysql 参数优化/","link":"","permalink":"https://langgithub.github.io/2020/06/09/mysql 参数优化/","excerpt":"","text":"mysql 参数优化 最大连接数 优化：http://database.51cto.com/art/201010/229936.htm max_connections=1000 表高速缓存区大小 优化地址 ： http://www.cnblogs.com/fjping0606/p/6531292.html table_open_cache=256 开启查询缓存 优化地址：http://www.jb51.net/article/58537.htm query_cache_type=1 查询缓存大小 query_cache_size=1M 临时表大小 优化地址：http://www.jb51.net/article/85341.htm tmp_table_size=32M 线程缓存数 http://www.jb51.net/article/51828.htm thread_cache_size=8 关闭DNS做反向地址查询 http://blog.chinaunix.net/uid-9370128-id-1687475.html skip-name-resolve=1 忘记密码后进行密码重置 skip-grant-tables=1 innodb_flush_log_at_trx_commit和sync_binlog 两个参数是控制MySQL 磁盘写入策略 http://blog.itpub.net/22664653/viewspace-1063134/ innodb_flush_log_at_trx_commit =2 sync_binlog=5000 慢查询配置 12345678910111213141516171819202122232425slow_query_log=1long_query_time=5slow_query_log_file=&quot;D:/MySQL/data/query-slow-file.log&quot;innodb_log_buffer_size=128Minnodb_buffer_pool_size=128Minnodb_log_file_size=10Minnodb_thread_concurrency=16innodb-autoextend-increment=1000join_buffer_size = 128Msort_buffer_size = 32Mread_rnd_buffer_size = 32Mmax_allowed_packet = 32M 关闭警告 http://www.jb51.net/article/71105.htm explicit_defaults_for_timestamp=true sql模式 http://blog.csdn.net/zhaoxuejie/article/details/50844380 sql-mode=”STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION”","categories":[{"name":"数据存储-mysql","slug":"数据存储-mysql","permalink":"https://langgithub.github.io/categories/数据存储-mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://langgithub.github.io/tags/mysql/"}]},{"title":"mongodb 常用脚步","slug":"mongodb 常用脚步","date":"2020-06-09T09:29:21.381Z","updated":"2020-06-09T09:29:21.381Z","comments":true,"path":"2020/06/09/mongodb 常用脚步/","link":"","permalink":"https://langgithub.github.io/2020/06/09/mongodb 常用脚步/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243db.selectname.find(&#123;&#125;).count()db.shiXinPeople.find(&#123;&#125;).count()/**复合索引唯一*db.People.ensureIndex(&#123;&quot;Name&quot;:1,&quot;Age&quot;:1&#125;,&#123;&quot;unique&quot;:true,&quot;dropDups&quot;:true&#125;)*/db.selectname.ensureIndex(&#123;&quot;selectName&quot;:1,&quot;city&quot;:1&#125;,&#123;&quot;unique&quot;:true,&quot;dropDups&quot;:true&#125;)db.shiXinPeople.ensureIndex(&#123;&quot;loc&quot;:1&#125;,&#123;&quot;unique&quot;:true,&quot;dropDups&quot;:true&#125;)/**update 更新操作*db.classes.update(&#123;&quot;count&quot;:&#123;$gt:20&#125;&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;c4&quot;&#125;&#125;,false,true)*/db.selectname.find(&#123;&quot;selectState&quot; : &quot;0&quot;&#125;).limit(2)db.selectname.update(&#123;&#125;,&#123;&quot;$set&quot;:&#123;&quot;start&quot;:0,&quot;selectState&quot;:&quot;0&quot;&#125;&#125;,false,true)db.selectname.update(&#123;&#125;,&#123;&quot;$unset&quot;:&#123;&quot;SelectState&quot;:&quot;&quot;&#125;&#125;,false,true)db.selectname.update(&#123;&#125;,&#123;$set:&#123;&quot;selectState&quot;:&quot;0&quot;&#125;&#125;,false,true)db.selectname.aggregate(&#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&#123;&quot;selectState&quot;:&quot;$selectState&quot;&#125;,&quot;count&quot;:&#123;$sum:1&#125;&#125;&#125;)db.selectname.find(&#123;&quot;selectState&quot;:&quot;1&quot;,&quot;start&quot;:&#123;$gte:1000&#125;&#125;)db.selectname.find(&#123;&quot;selectState&quot;:&quot;1&quot;&#125;)db.shiXinPeople.find(&#123;&#125;).count()db.shiXinPeople.distinct(&apos;loc&apos;)db.shiXinPeople.aggregate([&#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&#123;&quot;loc&quot;:&quot;$loc&quot;&#125;,&quot;count&quot;:&#123;$sum:1&#125;&#125;&#125;,&#123;&quot;$match&quot;:&#123;&quot;count&quot; : &#123;&quot;$gt&quot; : 1&#125;&#125;&#125;],&#123; allowDiskUse: true &#125;)","categories":[{"name":"数据存储-mongodb","slug":"数据存储-mongodb","permalink":"https://langgithub.github.io/categories/数据存储-mongodb/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://langgithub.github.io/tags/mongodb/"}]},{"title":"mysql mac安装","slug":"mysql mac安装","date":"2020-06-09T09:29:21.381Z","updated":"2020-06-09T09:29:21.381Z","comments":true,"path":"2020/06/09/mysql mac安装/","link":"","permalink":"https://langgithub.github.io/2020/06/09/mysql mac安装/","excerpt":"","text":"1.查询mysql安装，brew search mysql 2.安装mysql ，执行 brew install mysql 3.设置密码，执行 mysql_secure_installation （google一下） 4.连接到本机的mysql服务器，执行mysql.serve start 5.登录 mysql -uroot -p 输入密码 此时注意，如果密码修改不成功，可以先用 mysql -uroot 登录 然后修改密码 set password for ‘root‘@’localhost’ = ‘Root_123’; 注意：mysql8版本密码要求较高。 如果其它机器无法连接这台mysql服务器，进行如下修改 vim /usr/local/etc/my.cnf 将里面的127.0.0.1改为0.0.0.0 重启mysql brew services restart mysql 继续修改mysql.user表 实现远程登陆 select user,host from mysql.user; update mysql.user set host=’%’ where user=’root’;","categories":[{"name":"数据存储-mysql","slug":"数据存储-mysql","permalink":"https://langgithub.github.io/categories/数据存储-mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://langgithub.github.io/tags/mysql/"}]},{"title":"mysql sql总结","slug":"mysql sql总结","date":"2020-06-09T09:29:21.381Z","updated":"2020-06-09T09:29:21.381Z","comments":true,"path":"2020/06/09/mysql sql总结/","link":"","permalink":"https://langgithub.github.io/2020/06/09/mysql sql总结/","excerpt":"","text":"1.两张表做积1select * from Students a, Teachers b 2.并列合并两张表12# column数量相同select * from Scores union (select title,status from seed limit 2); 3.生成行标1select a.Score,@num:=@num+1 from Scores a,(select @num := 0) b; 4.排名不跳，连续加1(但是有bug 如果score只有一个且为0)1select a.Score,if(@pre_score!=a.Score,@num:=@num+1,@num),@pre_score:=a.Score from Scores a,(select @pre_score:=0, @num := 0) b order by a.Score desc; 5.排名连续，不连跳1234567891011select d.Score,e.Rank from Scores d join (select b.*,@num:=@num+1 as &quot;Rank&quot; from (select * from (select Score from Scores group by Score) a order by a.Score desc) b,(select @num:=0) c) e on d.Score=e.Score order by d.Score desc;或者select d.Score,e.Rank from Scores d join (select b.*,@num:=@num+1 as &quot;Rank&quot; from (select distinct Score from Scores order by Score desc) b,(select @num:=0) c) e on d.Score=e.Score order by d.Score desc;解题思路：1. 去重排序子表select distinct Score from Scores order by Score desc2. 对子表添加排序select b.*,@num:=@num+1 as &quot;Rank&quot; from (select distinct Score from Scores order by Score desc) b,(select @num:=0) c3. join select d.Score,e.Rank from Scores d join (select b.*,@num:=@num+1 as &quot;Rank&quot; from (select distinct Score from Scores order by Score desc) b,(select @num:=0) c) e on d.Score=e.Score order by d.Score desc;","categories":[{"name":"数据存储-mysql","slug":"数据存储-mysql","permalink":"https://langgithub.github.io/categories/数据存储-mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://langgithub.github.io/tags/mysql/"}]},{"title":"linux压缩工具命令行","slug":"linux压缩工具命令行","date":"2020-06-09T09:29:21.380Z","updated":"2020-06-09T09:29:21.380Z","comments":true,"path":"2020/06/09/linux压缩工具命令行/","link":"","permalink":"https://langgithub.github.io/2020/06/09/linux压缩工具命令行/","excerpt":"","text":"linux压缩工具命令行 Quick Start7z12$ sudo apt-get install p7zip$ brew install p7zip (mac) 123456789$ 7z x manager.7z -r -o /home/xx 这里大家要注意-o后是没有空格的直接接目录# x 代表解压缩文件，并且是按原始目录解压（还有个参数 e 也是解压缩文件，但其会将所有文件都解压到根下，而不是自己原有的文件夹下）manager.7z 是压缩文件，这里大家要换成自己的。如果不在当前目录下要带上完整的目录# -r 表示递归所有的子文件夹# -o 是指定解压到的目录，这里大家要注意-o后是没有空格的直接接目录$ 7z a -t7z -r manager.7z /home/manager/*# a 代表添加文件／文件夹到压缩包# -t 是指定压缩类型 一般我们定为7z# -r 表示递归所有的子文件夹，manager.7z 是压缩好后的压缩包名，/home/manager/* 是要压缩的目录，＊是表示该目录下所有的文件。 zip12345# 压缩$ zip -r filename.zip file1 file2 file3 /usr/work/school # 解压unzip filename.zip rar12345# 压缩$ rar a fileName# 解压$ rar x fileName tar c-创建-create v-复杂输出 f-文件-file x-解压-extract z-gz格式 12345678# 解压jdk到指定文件夹：$ tar -xzvf jdk-8u131-linux-x64.tar.gz -C /usr/local/java# 正常打包$ tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg # 压缩打包$ tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz","categories":[{"name":"辅助工具","slug":"辅助工具","permalink":"https://langgithub.github.io/categories/辅助工具/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://langgithub.github.io/tags/linux/"},{"name":"7z","slug":"7z","permalink":"https://langgithub.github.io/tags/7z/"},{"name":"tar","slug":"tar","permalink":"https://langgithub.github.io/tags/tar/"},{"name":"zip","slug":"zip","permalink":"https://langgithub.github.io/tags/zip/"}]},{"title":"maven使用总结","slug":"maven使用总结","date":"2020-06-09T09:29:21.380Z","updated":"2020-06-09T09:29:21.381Z","comments":true,"path":"2020/06/09/maven使用总结/","link":"","permalink":"https://langgithub.github.io/2020/06/09/maven使用总结/","excerpt":"","text":"maven使用总结 mvn archetype:generate # 构建项目","categories":[{"name":"code-java","slug":"code-java","permalink":"https://langgithub.github.io/categories/code-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://langgithub.github.io/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://langgithub.github.io/tags/maven/"}]},{"title":"linux操作系统","slug":"linux操作系统","date":"2020-06-09T09:29:21.380Z","updated":"2020-06-09T09:29:21.380Z","comments":true,"path":"2020/06/09/linux操作系统/","link":"","permalink":"https://langgithub.github.io/2020/06/09/linux操作系统/","excerpt":"","text":"磁盘分区 MBR分区 存放开机记录和分区表，分区表64bytes最多存储4个分区，这4个分区为主分区和扩展分区。逻辑分区从5开始 GPT分区 GPT 没有扩展分区概念 系统文件 ls 查看信息 drwxr-xr-x 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小 May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有： d：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件时间有以下三种： modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 cd 更换当前目录。 cd [相对路径或绝对路径] mkdir 创建目录。 mkdir [-mp] 目录名称 -m ：配置目录权限 -p ：递归创建目录 rmdir 删除目录，目录必须为空。 rmdir [-p] 目录名称 -p ：递归删除目录 touch 更新文件时间或者建立新文件。 touch [-acdmt] filename -a ： 更新 atime -c ： 更新 ctime，若该文件不存在则不建立新文件 -m ： 更新 mtime -d ： 后面可以接更新日期而不使用当前日期，也可以使用 –date=”日期或时间” -t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] cp 复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。 cp [-adfilprsu] source destination -a ：相当于 -dr –preserve=all -d ：若来源文件为链接文件，则复制链接文件属性而非文件本身 -i ：若目标文件已经存在时，在覆盖前会先询问 -p ：连同文件的属性一起复制过去 -r ：递归复制 -u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制 –preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 rm 删除文件。 rm [-fir] 文件或目录 -r ：递归删除 mv 移动文件。 mv [-fiu] source destination mv [options] source1 source2 source3 …. directory -f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 chmod 可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 chmod [-R] xyz dirname/filename 示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。 chmod 754 .bashrc 也可以使用符号来设定权限。 chmod [ugoa] [+-=] [rwx] dirname/filename u：拥有者 g：所属群组 o：其他人 a：所有人 +：添加权限 -：移除权限 =：设定权限示例：为 .bashrc 文件的所有用户添加写权限。 chmod a+w .bashrc 硬连接与软连接10.1 实体链接在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制：不能跨越文件系统、不能对目录进行链接。 $ ln /etc/crontab .$ ll -i /etc/crontab crontab34474855 -rw-r–r–. 2 root root 451 Jun 10 2014 crontab34474855 -rw-r–r–. 2 root root 451 Jun 10 2014 /etc/crontab10.2 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。 当源文件被删除了，链接文件就打不开了。 因为记录的是路径，所以可以为目录建立符号链接。 $ ll -i /etc/crontab /root/crontab234474855 -rw-r–r–. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 获取文件内容 cat取得文件内容。 $ cat [-AbEnTv] filename-n ：打印出行号，连同空白行也会有行号，-b 不会 tac是 cat 的反向操作，从最后一行开始打印。 more和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。 less和 more 类似，但是多了一个向前翻页的功能。 head取得文件前几行。 $ head [-n number] filename-n ：后面接数字，代表显示几行的意思 tail是 head 的反向操作，只是取得是后几行。 od以字符或者十六进制的形式显示二进制文件。 指令与文件搜索 which指令搜索。 $ which [-a] command-a ：将所有指令列出，而不是只列第一个 whereis文件搜索。速度比较快，因为它只搜索几个特定的目录。 $ whereis [-bmsu] dirname/filename locate文件搜索。可以用关键字或者正则表达式进行搜索。 locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 $ locate [-ir] keyword-r：正则表达式 find文件搜索。可以使用文件的属性和权限进行搜索。 find [basedir] [option]example: find . -name “shadow*” 压缩与打包压缩文件名Linux 底下有很多压缩文件名，常见的如下： 扩展名 压缩程序.Z compress .zip zip.gz gzip .bz2 bzip2.xz xz .tar tar 程序打包的数据，没有经过压缩.tar.gz tar 程序打包的文件，经过 gzip 的压缩 .tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩*.tar.xz tar 程序打包的文件，经过 xz 的压缩压缩指令 gzip gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 $ gzip [-cdtv#] filename -c ：将压缩的数据输出到屏幕上 -d ：解压缩 -t ：检验压缩文件是否出错 -v ：显示压缩比等信息 -# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 bzip2 提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。 $ bzip2 [-cdkzv#] filename -k ：保留源文件 xz 提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。 查看命令：xzcat、xzmore、xzless、xzgrep。 $ xz [-dtlkc#] filename tar打包 压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。 $ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename… ==打包压缩 $ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看 $ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩 -z ：使用 zip； -j ：使用 bzip2； -J ：使用 xz； -c ：新建打包文件； -t ：查看打包文件里面有哪些文件； -x ：解打包或解压缩的功能； -v ：在压缩/解压缩的过程中，显示正在处理的文件名； -f : filename：要处理的文件； -C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 Bash可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。 特性命令历史：记录使用过的命令命令与文件补全：快捷键：tab命名别名：例如 lm 是 ls -al 的别名shell scripts通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件变量操作对一个变量赋值直接使用 =。对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式； 数据流重定向 重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 1 代码 运算符 标准输入 (stdin) 0 &lt; 或 &lt;&lt; 标准输出 (stdout) 1 &gt; 或 &gt;&gt; 标准错误输出 (stderr) 2 2&gt; 或 2&gt;&gt; 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 $ find /home -name .bashrc &gt; list 2&gt;&amp; 管道指令 (cat file | grep “regex” | wc -l)管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。 选取命令:cut.grep cut -d &apos;分隔字符&apos; -f field // 用于分隔字符 cut -c 字符范围 [参数说明] -d : 后面接分隔字符,通常与 -f 一起使用 -f : 根据-d 将信息分隔成数段，-f 后接数字 表示取出第几段 -c : 以字符为单位取出固定字符区间的信息 栗子1： 打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和家目录 [root@izuf6i29flb2df231kt91hz /]# cat etc/passwd | cut -d &apos;:&apos; -f 1,6 root:/root bin:/bin daemon:/sbin adm:/var/adm lp:/var/spool/lpd 栗子2： 打印/etc/passwd文件中每一行的前10个字符： [root@izuf6i29flb2df231kt91hz /]# cat /etc/passwd | cut -c 1-10 root:x:0:0 bin:x:1:1: daemon:x:2 adm:x:3:4: lp:x:4:7:l 排序命令：sort,wc,uniq sort [-fbMnrtuk] [file or stdin] [参数] -f ：忽略大小写的差异，例如A 与a 视为编码相同 -b ：忽略最前面的空格部分 -M ：以月份的名字来排序，例如JAN, DEC 等等的排序方法 -n ：使用『纯数字』进行排序默认是以文字型态来排序的) -r ：反向排序 -u ：就是uniq ，相同的资料中，仅出现一行代表 -t ：分隔符号，预设是用[tab] 键来分隔 -k ：以那个区间(field) 来进行排序的意思 uniq uniq [-ic] [参数] -i ：忽略大小写的不同 -c ：进行计数 wc wc [-lwm] [参数] -l ：仅列出行 -w ：仅列出多少字(英文单字) -m ：多少字符 字符转换命令：tr,col,join,paste,expand 切割命令：split 进程管理 (ps -aux | grep tomcat 指定进程)（netstat -apn | grep 4000）(lsof -i tcp:4000)查看进程 ps查看某个时间点的进程信息。 示例一：查看自己的进程 $ ps -l示例二：查看系统所有进程 $ ps aux示例三：查看特定的进程 $ ps aux | grep threadx pstree查看进程树。 示例：查看所有进程树 $ pstree -A top实时显示进程信息。 示例：两秒钟刷新一次 $ top -d 2 netstat查看占用端口的进程 示例：查看特定端口的进程$ netstat -anp | grep port","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"linux操作系统","slug":"linux操作系统","permalink":"https://langgithub.github.io/tags/linux操作系统/"}]},{"title":"jvm垃圾回收","slug":"jvm垃圾回收","date":"2020-06-09T09:29:21.379Z","updated":"2020-06-09T09:29:21.379Z","comments":true,"path":"2020/06/09/jvm垃圾回收/","link":"","permalink":"https://langgithub.github.io/2020/06/09/jvm垃圾回收/","excerpt":"","text":"程序计数器、虚拟机栈、本地方法栈 3个区域随着线程而生，也随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配的内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收问题，因为方法结束或线程结束时，内存自然跟随着回收了。 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存，后续讨论的“内存”分配回收也是指这一块，尤其需要注意。 对象是否存活 引用计数算法 可达性分析 再谈引用（强、软、弱、虚引用） 强引用：只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收 弱引用：也是用来描述非必需对象，但它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前 虚引用：它是最弱的一种引用关系。也无法通过虚引用来取得一个对象实例。 java堆构成1.","categories":[{"name":"code-java","slug":"code-java","permalink":"https://langgithub.github.io/categories/code-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://langgithub.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https://langgithub.github.io/tags/jvm/"}]},{"title":"jvm内存结构 与 内存溢出异常","slug":"jvm内存结构 与 内存溢出异常","date":"2020-06-09T09:29:21.379Z","updated":"2020-06-09T09:29:21.379Z","comments":true,"path":"2020/06/09/jvm内存结构 与 内存溢出异常/","link":"","permalink":"https://langgithub.github.io/2020/06/09/jvm内存结构 与 内存溢出异常/","excerpt":"","text":"jvm内存结构 1. 类加载器 2. 执行引擎 3. 堆(GC垃圾回收器) 4. 方法区 5. pc程序计数器 6. 虚拟机栈 7. 本地方法栈 类加载器详见&lt;a href=&quot;/2019/06/10/jvm类加载器/&quot;/&gt; 执行引擎&lt;无&gt; 运行时数据区: 堆 方法区 虚拟机栈 本地方法栈 pc先看下内存分析 运行时数据区 解说： 1. java堆(包含GC堆) 此内存区域唯一的目的是存放对象实例 垃圾回收器又叫 “GC堆” -Xmx -Xms （最大堆，初始化堆） 2. 方法区（特殊的堆） 存放的代码，方法，static方法，常量池 3. 虚拟机栈（虚拟机执行java方法） 栈帧是虚拟机方法调用和执行的数据结构 栈帧： 1.存储局部变量表（变量槽）slot （存放方法参数，方法内部定义的局部变量） 2.操作数栈 3.动态链接 （运行期间转化为直接饮用） 4.方法出口等信息 4. 本地方法栈 虚拟机执行native方法 5. pc 选取要执行的下一条指令 备注：堆 方法区（所有线程共享） 虚拟机栈 本地方法栈 pc（线程隔离） 内存溢出异常1. 线程请求的最大深度 &gt; 虚拟机中所允许的最大深度 StackOverflowError（包含虚拟机栈，本地方法栈） 2. 方法区和运行常量池溢出 java.lang.OutOfMemoryError: PermGen space 3. Java堆溢出 java.lang.OutOfMemoryError: Java heap space 4. 本机直接内存溢出 java.lang.OutOfMemoryError","categories":[{"name":"code-java","slug":"code-java","permalink":"https://langgithub.github.io/categories/code-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://langgithub.github.io/tags/java/"}]},{"title":"jvm类加载器","slug":"jvm类加载器","date":"2020-06-09T09:29:21.379Z","updated":"2020-06-09T09:29:21.379Z","comments":true,"path":"2020/06/09/jvm类加载器/","link":"","permalink":"https://langgithub.github.io/2020/06/09/jvm类加载器/","excerpt":"","text":"类装载流程 加载 class字节码（网路流,文本流）加载到jvm 链接 2.1 验证验证class字节码合法性 2.2 准备public static int a=1 -&gt; static变量初始化为0 public static final int a=1 -&gt; static final变量初始化后为1 2.3 解析类，接口，字段的解析 初始化 主要包括执行类构造方法、static变量赋值语句，staic{}语句块 使用 卸载 类加载器 引导类加载器 rt.jar 扩展类加载器 ext目录下 应用程序类加载器 classpath 自定义类加载器 extend classloader","categories":[{"name":"code-java","slug":"code-java","permalink":"https://langgithub.github.io/categories/code-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://langgithub.github.io/tags/java/"}]},{"title":"linux免密钥登陆","slug":"linux免密钥登陆","date":"2020-06-09T09:29:21.379Z","updated":"2020-06-09T09:29:21.379Z","comments":true,"path":"2020/06/09/linux免密钥登陆/","link":"","permalink":"https://langgithub.github.io/2020/06/09/linux免密钥登陆/","excerpt":"","text":"免密钥登陆 Quick Start生成了私钥 id_dsa 和公钥 id_dsa.pub1$ sudo apt install openssh-server 1$ ssh-keygen -t rsa 将该密钥用作认证,进行访问授权1$ cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys 登陆1$ ssh localhost","categories":[{"name":"辅助工具","slug":"辅助工具","permalink":"https://langgithub.github.io/categories/辅助工具/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://langgithub.github.io/tags/linux/"}]},{"title":"js调试技巧","slug":"js调试技巧","date":"2020-06-09T09:29:21.378Z","updated":"2020-06-09T09:29:21.378Z","comments":true,"path":"2020/06/09/js调试技巧/","link":"","permalink":"https://langgithub.github.io/2020/06/09/js调试技巧/","excerpt":"","text":"js调试技巧 巧用debugger，可以是代码可以是断点 查看Event Listeners事件监听 hook xhr (赚到js hook) chrome source板块下 XHR/fetch Breakpoints真的很nice。输入URL运行即刻即可下断","categories":[{"name":"爬虫-js逆向","slug":"爬虫-js逆向","permalink":"https://langgithub.github.io/categories/爬虫-js逆向/"}],"tags":[{"name":"简单图形验证码","slug":"简单图形验证码","permalink":"https://langgithub.github.io/tags/简单图形验证码/"}]},{"title":"js hook","slug":"js hook","date":"2020-06-09T09:29:21.378Z","updated":"2020-06-09T09:29:21.378Z","comments":true,"path":"2020/06/09/js hook/","link":"","permalink":"https://langgithub.github.io/2020/06/09/js hook/","excerpt":"","text":"js hook jquery hook 这是我的油猴插件 12345678910111213141516171819202122232425(function() &#123; &apos;use strict&apos;; //console.log(&quot;hook my xhr&quot;) !function(t)&#123;function r(n)&#123;if(e[n])return e[n].exports;var o=e[n]=&#123;exports:&#123;&#125;,id:n,loaded:!1&#125;;return t[n].call(o.exports,o,o.exports,r),o.loaded=!0,o.exports&#125;var e=&#123;&#125;;return r.m=t,r.c=e,r.p=&quot;&quot;,r(0)&#125;([function(t,r,e)&#123;e(1)(window)&#125;,function(t,r)&#123;t.exports=function(t)&#123;t.hookAjax=function(t)&#123;function r(r)&#123;return function()&#123;var e=this.hasOwnProperty(r+&quot;_&quot;)?this[r+&quot;_&quot;]:this.xhr[r],n=(t[r]||&#123;&#125;).getter;return n&amp;&amp;n(e,this)||e&#125;&#125;function e(r)&#123;return function(e)&#123;var n=this.xhr,o=this,i=t[r];if(&quot;function&quot;==typeof i)n[r]=function()&#123;t[r](o)||e.apply(n,arguments)&#125;;else&#123;var a=(i||&#123;&#125;).setter;e=a&amp;&amp;a(e,o)||e;try&#123;n[r]=e&#125;catch(t)&#123;this[r+&quot;_&quot;]=e&#125;&#125;&#125;&#125;function n(r)&#123;return function()&#123;var e=[].slice.call(arguments);if(!t[r]||!t[r].call(this,e,this.xhr))return this.xhr[r].apply(this.xhr,e)&#125;&#125;window._ahrealxhr=window._ahrealxhr||XMLHttpRequest,XMLHttpRequest=function()&#123;var t=new window._ahrealxhr;Object.defineProperty(this,&quot;xhr&quot;,&#123;value:t&#125;)&#125;;var o=window._ahrealxhr.prototype;for(var i in o)&#123;var a=&quot;&quot;;try&#123;a=typeof o[i]&#125;catch(t)&#123;&#125;&quot;function&quot;===a?XMLHttpRequest.prototype[i]=n(i):Object.defineProperty(XMLHttpRequest.prototype,i,&#123;get:r(i),set:e(i),enumerable:!0&#125;)&#125;return window._ahrealxhr&#125;,t.unHookAjax=function()&#123;window._ahrealxhr&amp;&amp;(XMLHttpRequest=window._ahrealxhr),window._ahrealxhr=void 0&#125;,t.default=t&#125;&#125;]); //js加载完成执行 //console.log(hookAjax) hookAjax(&#123; //拦截回调 onreadystatechange:function(xhr)&#123; console.log(&quot;onreadystatechange called: %O&quot;,xhr) &#125;, onload:function(xhr)&#123; console.log(&quot;onload called: %O&quot;,xhr) &#125;, //拦截方法 open:function(arg,xhr)&#123; console.log(&quot;open called: method:%s,url:%s,async:%s&quot;,arg[0],arg[1],arg[2]) &#125;, setRequestHeader:function(arg,xhr)&#123; console.log(&quot;setRequestHeader called: method:%s,name:%s,value:%s&quot;,arg[0],arg[1],arg[2]) &#125; &#125;) console.log(&quot;hook xhr&quot;) // Your code here...&#125;)(); hook window 函数 1234orig = window.eval;window.eval=function(str)&#123;debugger;orig(str);&#125;// 这段代码防止反hook的检测window.eval.toString = function ()&#123;return orig.toString();&#125; hook 节点 12var dom_get_element = document.getElementById;document.getElementById = function(id)&#123;if(id==&quot;9DhefwqGPrzGxEp9hPaoag&quot;) debugger; dom_get_element(id);&#125;","categories":[{"name":"爬虫-js逆向","slug":"爬虫-js逆向","permalink":"https://langgithub.github.io/categories/爬虫-js逆向/"}],"tags":[{"name":"hook","slug":"hook","permalink":"https://langgithub.github.io/tags/hook/"}]},{"title":"java中的锁","slug":"java中的锁","date":"2020-06-09T09:29:21.378Z","updated":"2020-06-09T09:29:21.378Z","comments":true,"path":"2020/06/09/java中的锁/","link":"","permalink":"https://langgithub.github.io/2020/06/09/java中的锁/","excerpt":"","text":"锁宏观与微观 悲观锁 重量级锁 乐观锁 自旋锁避免用户线程和内核的切换的消耗,无需进入阻塞状态挂起 参数设置： JDK1.6中-XX:+UseSpinning开启； -XX:PreBlockSpin=10 为自旋次数； JDK1.7后，去掉此参数，由jvm控制； 轻量级锁轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； 偏向锁如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁 总结： 在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试 获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞 挂起，直到持有锁的线程执行完同步块唤醒他们； 偏向锁是在无锁争用的情况下使用的，也就是同步开在当前线程没有执行完之前，没有其它线程会执 行该同步块，一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，如果轻量级锁自旋到达阈值 后，没有获取到锁，就会升级为重量级锁； java锁 synchronized 重量级锁 ReentranteLock 重入锁 ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写； ConcurrentHashMap解释：当多线程访问容器里不同数据段的数据时，线程间锁竞争压力小，从而可以有效的提高并发访问效率","categories":[{"name":"code-java","slug":"code-java","permalink":"https://langgithub.github.io/categories/code-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://langgithub.github.io/tags/java/"},{"name":"锁","slug":"锁","permalink":"https://langgithub.github.io/tags/锁/"}]},{"title":"java内存调优","slug":"java内存调优","date":"2020-06-09T09:29:21.378Z","updated":"2020-06-09T09:29:21.378Z","comments":true,"path":"2020/06/09/java内存调优/","link":"","permalink":"https://langgithub.github.io/2020/06/09/java内存调优/","excerpt":"","text":"常见配置汇总 堆设置 -Xmn:新生代大小 占堆大小1/3或1/4 -Xms:初始堆大小 -Xmx:最大堆大小 -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 -XX:MaxPermSize=n:设置持久代大小 栈设置 -Xss1m 栈大小 收集器设置 -XX:+UseSerialGC:设置串行收集器 -XX:+UseParallelGC:设置并行收集器 -XX:+UseParalledlOldGC:设置并行年老代收集器 -XX:+UseConcMarkSweepGC:设置并发收集器 垃圾回收统计信息 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:filename 并行收集器设置 -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) 并发收集器设置 -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。 -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 OOM -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=${目录}。溢出分析","categories":[{"name":"code-java","slug":"code-java","permalink":"https://langgithub.github.io/categories/code-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://langgithub.github.io/tags/java/"}]},{"title":"http缓存机制","slug":"http缓存机制","date":"2020-06-09T09:29:21.377Z","updated":"2020-06-09T09:29:21.377Z","comments":true,"path":"2020/06/09/http缓存机制/","link":"","permalink":"https://langgithub.github.io/2020/06/09/http缓存机制/","excerpt":"","text":"强缓存 Expires 绝对时间 Cache-Control 相对时间 协商缓存 Last-Modify/If-Modify-Since Last-Modify 服务器端返回 最后一次缓存时间 If-Modify-Since 客户端发送的 last-modify 对应的时间 ETag/If-None-Match ETag 服务器端返回 唯一资源标示 If-None-Match 客服端发送 Etag对应的值 既生Last-Modified何生Etag？Etag能解决服务器端资源更新带来的缓存一致问题 总结","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"http","slug":"http","permalink":"https://langgithub.github.io/tags/http/"}]},{"title":"http与https","slug":"http与https","date":"2020-06-09T09:29:21.377Z","updated":"2020-08-06T05:40:04.771Z","comments":true,"path":"2020/06/09/http与https/","link":"","permalink":"https://langgithub.github.io/2020/06/09/http与https/","excerpt":"","text":"http与https General HTTP 2.1. http基本优化 2.2. HTTP1.0和HTTP1.1的一些区别 2.3. HTTP2.0和HTTP1.X HTTPS 3.1. HTTPS握手 3.2. https单向认证和双向认证 1. General主要介绍http,https基本特征，和https在Java中使用方式 2. HTTP2.1. http基本优化 带宽： 如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现 在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只 剩下延迟了。 延迟： 1. 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连 接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会 被阻塞。 2. DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 3. 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但 是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影 响较明显，慢启动则对文件类大请求影响较大。 2.2. HTTP1.0和HTTP1.1的一些区别 【缓存处理】，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 【带宽优化及网络连接的使用】，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 【错误通知的管理】，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 【Host头处理】，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 【长连接】，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启{Connection： keep-alive}一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 2.3. HTTP2.0和HTTP1.X 【新的二进制格式（Binary Format）】，HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 【多路复用（MultiPlexing）】，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 【header压缩】，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 【服务端推送（server push）】，同SPDY一样，HTTP2.0也具有server push功能。 3. HTTPS3.1. HTTPS握手 对称与非对称加密: 对称：加密秘要与解密秘要是同一个 非对称加密：加密秘要与解密秘要不一样 a. 加密 （公钥加密，私钥解密） b. 验证 （私钥签名，公钥验证） 数字签名 数字证书 消息摘要 三者关系 消息摘要：报文通过ca hash转化成消息摘要 数字签名：用ca私钥对消息摘要签名 数字证书：包含报文,数字签名,服务端公钥。发放给服务器端 https请求流程图 总结：a. 客户端请求crt证书b. 客服端返回ca证书c. 客户端验证码CA证书是否有效（对比信息摘要），随机一种对此加密方法的key用公钥加密发送到服务器d. 服务器解密出对称加密的key, 传输数据 3.2. https单向认证和双向认证 单向认证 信任所有 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950单向认证信任所有证书public class HttpsUtils &#123;private MyTrustManager mMyTrustManager; private SSLSocketFactory createSSLSocketFactory() &#123; SSLSocketFactory ssfFactory = null; try &#123; mMyTrustManager = new MyTrustManager(); SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;); sc.init(null, new TrustManager[]&#123;mMyTrustManager&#125;, new SecureRandom()); ssfFactory = sc.getSocketFactory(); &#125; catch (Exception ignored) &#123; ignored.printStackTrace(); &#125; return ssfFactory; &#125; //实现X509TrustManager接口 public class MyTrustManager implements X509TrustManager &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125; &#125; //实现HostnameVerifier接口 private class TrustAllHostnameVerifier implements HostnameVerifier &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125; &#125; public OkHttpClient getTrustAllClient() &#123; OkHttpClient.Builder mBuilder = new OkHttpClient.Builder(); mBuilder.sslSocketFactory(createSSLSocketFactory(), mMyTrustManager) .hostnameVerifier(new TrustAllHostnameVerifier()); return mBuilder.build(); &#125;&#125; 单向认证 验证服务器端证书 12345678910111213141516171819public static SSLSocketFactory getSSLSocketFactory_Certificate(Context context, String str) &#123; try &#123; CertificateFactory instance = CertificateFactory.getInstance(&quot;X.509&quot;); KeyStore instance2 = KeyStore.getInstance(KeyStore.getDefaultType()); instance2.load((KeyStore.LoadStoreParameter) null); int i = 0; for (Certificate certificateEntry : instance.generateCertificates(context.getAssets().open(str))) &#123; instance2.setCertificateEntry(Integer.toString(i), certificateEntry); i++; &#125; TrustManagerFactory instance3 = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); instance3.init(instance2); SSLContext instance4 = SSLContext.getInstance(&quot;TLS&quot;); instance4.init((KeyManager[]) null, instance3.getTrustManagers(), new SecureRandom()); return instance4.getSocketFactory(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125; 双向认证 1234567891011121314151617181920212223242526272829303132public static SSLSocketFactory getSSLSocketFactory_Certificate(Context context, String str) &#123; try &#123; CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;); //通过证书工厂得到自签证书对象集合 Collection&lt;? extends Certificate&gt; certificates = certificateFactory.generateCertificates(in); if (certificates.isEmpty()) &#123; throw new IllegalArgumentException(&quot;expected non-empty set of trusted certificates&quot;); &#125; //为证书设置一个keyStore char[] password = &quot;password&quot;.toCharArray(); // Any password will work. KeyStore keyStore = newEmptyKeyStore(password); int index = 0; //将证书放入keystore中 for (Certificate certificate : certificates) &#123; String certificateAlias = Integer.toString(index++); keyStore.setCertificateEntry(certificateAlias, certificate); &#125; // Use it to build an X509 trust manager. //使用包含自签证书信息的keyStore去构建一个X509TrustManager KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, password); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); SSLContext instance4 = SSLContext.getInstance(&quot;TLS&quot;); instance4.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); return instance4.getSocketFactory(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;&#125;","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"http","slug":"http","permalink":"https://langgithub.github.io/tags/http/"},{"name":"https","slug":"https","permalink":"https://langgithub.github.io/tags/https/"}]},{"title":"ios逆向-应用砸壳","slug":"ios逆向-应用砸壳","date":"2020-06-09T09:29:21.377Z","updated":"2020-06-09T09:29:21.377Z","comments":true,"path":"2020/06/09/ios逆向-应用砸壳/","link":"","permalink":"https://langgithub.github.io/2020/06/09/ios逆向-应用砸壳/","excerpt":"","text":"砸壳原理 加密（appStore加密app） 解密 静态砸壳： Clutch github下载Clutch https://github.com/KJCracks/Clutch.git 拷贝$scp -P 12345 Clutch-2.0.4 root@localhost:/usr/bin 重命名$mv Clutch-2.0.4 Clutch 修改权限$chmod +x Clutch 查看砸壳状态$Clutch -i；砸壳$Clutch -d 2，其中“2”为查看的标示。系统应用不加壳 用iFunBox查找砸壳包，拷贝到电脑桌面解压，找到应用砸壳后的MachO文件 ida64查看MachO文件的加密情况,或者$otool -l WeChat | grep crypt 砸壳后的MachO文件即可以class-dump$class-dump -H WeChat -o ./Headers/ 过程 购买10.2版本一下手机，刷机越狱 通过cydia 下载openssh, 链接wifi保证手机和电脑在同一局域网 ssh root@172.17.2.178 https://www.jianshu.com/p/9fb62c24effc","categories":[{"name":"code-ios","slug":"code-ios","permalink":"https://langgithub.github.io/categories/code-ios/"}],"tags":[{"name":"ios开发","slug":"ios开发","permalink":"https://langgithub.github.io/tags/ios开发/"}]},{"title":"hexo-常用命令","slug":"hexo-常用命令","date":"2020-06-09T09:29:21.377Z","updated":"2020-06-09T09:29:21.377Z","comments":true,"path":"2020/06/09/hexo-常用命令/","link":"","permalink":"https://langgithub.github.io/2020/06/09/hexo-常用命令/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"辅助工具","slug":"辅助工具","permalink":"https://langgithub.github.io/categories/辅助工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://langgithub.github.io/tags/hexo/"}]},{"title":"frida使用总结","slug":"frida使用总结","date":"2020-06-09T09:29:21.376Z","updated":"2020-06-09T09:29:21.376Z","comments":true,"path":"2020/06/09/frida使用总结/","link":"","permalink":"https://langgithub.github.io/2020/06/09/frida使用总结/","excerpt":"","text":"frida使用总结 frida使用总结 Gerneral frida 安装测试 frida 主动抛出异常，monitor查看调用栈（包含日志打印） frida hook 内部类 frida map打印 反射操作 hook toast打印堆栈 app中防止ptrace,会创建子进程ptrace父进程导致无法hook app okhttp一般hook方式 堆栈打印2 特殊字符打印 jni动态注册函数打印 jni各种类型参数打印 动态hook Native函数 Gerneral工作中收集的Frida使用方式方法，帮助快速定位文件位置 frida 安装测试12345678910111213141516171819202122232425import frida, sysdef on_message(message, data): if message[&apos;type&apos;] == &apos;send&apos;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&apos;payload&apos;])) else: print(message)jscode = &quot;&quot;&quot;Java.perform(function () &#123; send(&quot;Success!&quot;) var MainActivity = Java.use(&apos;com.lang.frida.MainActivity&apos;); MainActivity.stringFromJNI.implementation = function () &#123; send(&quot;Hook Start...&quot;); send(&quot;Success!&quot;); return &quot;i love you&quot;; &#125;&#125;);&quot;&quot;&quot;process = frida.get_usb_device().attach(&apos;com.lang.frida&apos;)script = process.create_script(jscode)script.on(&apos;message&apos;, on_message)script.load()sys.stdin.read() frida 主动抛出异常，monitor查看调用栈（包含日志打印）123456789101112131415161718Java.perform(function () &#123; var e=Java.use(&quot;io.dcloud.feature.ui.e&quot;); var exception=Java.use(&quot;java.lang.Exception&quot;); var Logger=Java.use(&quot;io.dcloud.common.adapter.util.Logger&quot;); e.a.overload(&apos;io.dcloud.feature.ui.a&apos;, &apos;io.dcloud.common.DHInterface.IWebview&apos;, &apos;org.json.JSONArray&apos;, &apos;io.dcloud.common.DHInterface.IApp&apos;, &apos;java.lang.String&apos;, &apos;boolean&apos;).implementation=function(v0,v1,v2,v3,v4,v5)&#123; send(&quot;log Hook Start...&quot;); Logger.setOpen(true); //throw exception.$new(&quot;-----hook exception -----------------&quot;); return this.a(v0,v1,v2,v3,v4,v5) &#125; Logger.setOpen.implementation=function(flag)&#123; send(&quot;Logger update Hook Start...&quot;); return this.setOpen(True) &#125; &#125;); frida hook 内部类12345var f = Java.use(&apos;cn.blackfish.android.financialmarketlib.view.activity.FmLoginActivity$f&apos;);f.onClick.implementation = function (arg1) &#123; send(&quot;Hook Start...&quot;); return this.onClick(arg1);&#125; frida map打印12345678910var result = &quot;&quot;;var keyset = arg1.keySet();var it = keyset.iterator();while(it.hasNext())&#123; var keystr = it.next().toString(); var valuestr = arg1.get(keystr).toString(); var map= keystr+&apos;:&apos;+valuestr+&apos; ||&apos;; result+=map&#125;send(result); 反射操作 hook toast打印堆栈123456789101112131415161718192021222324252627282930313233jscode = &quot;&quot;&quot;Java.perform(function () &#123; send(&quot;Success!&quot;) var objectclass= Java.use(&quot;java.lang.Object&quot;); var exception=Java.use(&quot;java.lang.Exception&quot;); var Toast = Java.use(&apos;android.widget.Toast&apos;); var BaseRequest = Java.use(&apos;cn.blackfish.android.financialmarketlib.model.bean.BaseRequest&apos;); var JsonParser=Java.use(&apos;com.google.gson.q&apos;); Toast.show.implementation = function () &#123; send(&quot;Hook show Start...&quot;); //var clazz = Java.cast(&quot;cn.blackfish.android.financialmarketlib.model.bean.BaseRequest&quot;,BaseRequest); var method=BaseRequest.class.getDeclaredMethod(&quot;addSign&quot;,null); var bizParams=BaseRequest.class.getDeclaredField(&quot;bizParams&quot;); method.setAccessible(true) bizParams.setAccessible(true) var jsonParser = JsonParser.$new(); var jsonObject = jsonParser.a(&quot;&#123;&apos;phoneNum&apos;:&apos;17621972154&apos;,&apos;templateId&apos;:0,&apos;thirdAuthType&apos;:0&#125;&quot;); var o = BaseRequest.$new(jsonObject); var mes=method.invoke(o,null) send(mes.toString()) // this.toFlatMap(this.bizParams) var map=o.toFlatMap(bizParams.get(o)) send(map.toString()) //throw exception.$new(&quot;-----hook exception -----------------&quot;); return this.show(); &#125;&#125;); app中防止ptrace,会创建子进程ptrace父进程导致无法hook app1234567891011121314151617181920212223242526272829303132333435import frida, sysdef on_message(message, data): if message[&apos;type&apos;] == &apos;send&apos;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&apos;payload&apos;])) else: print(message)jscode = &quot;&quot;&quot;Java.perform(function () &#123; send(&quot;Success!&quot;) var Config = Java.use(&apos;com.hengchang.baselibrary.utils.LogUtils$Config&apos;); Config.$init.implementation = function (arg1) &#123; send(&quot;Hook show Start...&quot;); return this.$init(arg1); &#125;&#125;);&quot;&quot;&quot;device = frida.get_device_manager().enumerate_devices()[-1]pid = device.spawn([&quot;com.hengchang.client&quot;])session = device.attach(pid)print(&quot;[*] Attach Application id:&quot;,pid)device.resume(pid)print(&quot;[*] Application onResume&quot;)script = session.create_script(jscode)&apos;&apos;&apos;process = frida.get_usb_device().attach(&quot;cn.thecover.www.covermedia&quot;)script = process.create_script(jscode)&apos;&apos;&apos;script.on(&apos;message&apos;, on_message)print(&apos;[*] Running CTF&apos;)script.load()sys.stdin.read() okhttp一般hook方式12345678910111213141516171819var RetryAndFollowUpInterceptor=Java.use(&quot;okhttp3.internal.http.RetryAndFollowUpInterceptor&quot;);var Buffer=Java.use(&quot;okio.Buffer&quot;);var Charset=Java.use(&quot;java.nio.charset.Charset&quot;);var exception=Java.use(&quot;java.lang.Exception&quot;);RetryAndFollowUpInterceptor.intercept.implementation = function (chain) &#123; send(&quot;chain Hook show Start2...&quot;); //throw exception.$new(&quot;----------exception--------------&quot;); var userRequest = chain.request(); var requestBody = userRequest.body(); var buffer = Buffer.$new(); requestBody.writeTo(buffer); var charset = Charset.forName(&quot;UTF-8&quot;); var contentType = requestBody.contentType(); if (contentType != null) &#123; charset = contentType.charset(charset); &#125; send(buffer.readString(charset)) return this.intercept(chain);&#125; 堆栈打印2123456789101112var k=Java.use(&quot;com.yxcorp.retrofit.k&quot;);var Thread=Java.use(&quot;java.lang.Thread&quot;);k.b.implementation = function (map) &#123; send(&quot;Hook show map Start...&quot;); var stack=Thread.currentThread().getStackTrace(); for(var i=0;i&lt;stack.length;i++)&#123; var line=stack[i].getClassName()+&quot;.&quot;+stack[i].getMethodName()+&quot;(&quot;+stack[i].getFileName()+&quot;:&quot;+stack[i].getLineNumber()+&quot;)&quot; send(line) &#125; //throw exception.$new(&quot;-----hook exception -----------------&quot;); return this.a();&#125; 特殊字符打印1send(escape(result)); unescape解密 jni动态注册函数打印123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107var ishook_libart = false;function hook_libart() &#123; if (ishook_libart === true) &#123; return; &#125; var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;); var addrGetStringUTFChars = null; var addrNewStringUTF = null; var addrFindClass = null; var addrGetMethodID = null; var addrGetStaticMethodID = null; var addrGetFieldID = null; var addrGetStaticFieldID = null; var addrRegisterNatives = null; var addrAllocObject = null; var addrCallObjectMethod = null; var addrGetObjectClass = null; var addrReleaseStringUTFChars = null; for (var i = 0; i &lt; symbols.length; i++) &#123; var symbol = symbols[i]; if (symbol.name == &quot;_ZN3art3JNI17GetStringUTFCharsEP7_JNIEnvP8_jstringPh&quot;) &#123; addrGetStringUTFChars = symbol.address; console.log(&quot;GetStringUTFChars is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name == &quot;_ZN3art3JNI12NewStringUTFEP7_JNIEnvPKc&quot;) &#123; addrNewStringUTF = symbol.address; console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name == &quot;_ZN3art3JNI9FindClassEP7_JNIEnvPKc&quot;) &#123; addrFindClass = symbol.address; console.log(&quot;FindClass is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name == &quot;_ZN3art3JNI11GetMethodIDEP7_JNIEnvP7_jclassPKcS6_&quot;) &#123; addrGetMethodID = symbol.address; console.log(&quot;GetMethodID is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name == &quot;_ZN3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jclassPKcS6_&quot;) &#123; addrGetStaticMethodID = symbol.address; console.log(&quot;GetStaticMethodID is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name == &quot;_ZN3art3JNI10GetFieldIDEP7_JNIEnvP7_jclassPKcS6_&quot;) &#123; addrGetFieldID = symbol.address; console.log(&quot;GetFieldID is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name == &quot;_ZN3art3JNI16GetStaticFieldIDEP7_JNIEnvP7_jclassPKcS6_&quot;) &#123; addrGetStaticFieldID = symbol.address; console.log(&quot;GetStaticFieldID is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name == &quot;_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi&quot;) &#123; addrRegisterNatives = symbol.address; console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(&quot;_ZN3art3JNI11AllocObjectEP7_JNIEnvP7_jclass&quot;) &gt;= 0) &#123; addrAllocObject = symbol.address; console.log(&quot;AllocObject is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(&quot;_ZN3art3JNI16CallObjectMethodEP7_JNIEnvP8_jobjectP10_jmethodIDz&quot;) &gt;= 0) &#123; addrCallObjectMethod = symbol.address; console.log(&quot;CallObjectMethod is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(&quot;_ZN3art3JNI14GetObjectClassEP7_JNIEnvP8_jobject&quot;) &gt;= 0) &#123; addrGetObjectClass = symbol.address; console.log(&quot;GetObjectClass is at &quot;, symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(&quot;_ZN3art3JNI21ReleaseStringUTFCharsEP7_JNIEnvP8_jstringPKc&quot;) &gt;= 0) &#123; addrReleaseStringUTFChars = symbol.address; console.log(&quot;ReleaseStringUTFChars is at &quot;, symbol.address, symbol.name); &#125; &#125; if (addrRegisterNatives != null) &#123; Interceptor.attach(addrRegisterNatives, &#123; onEnter: function (args) &#123; console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]); var env = args[0]; var java_class = args[1]; var funcAllocObject = new NativeFunction(addrAllocObject, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); var funcGetMethodID = new NativeFunction(addrGetMethodID, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); var funcCallObjectMethod = new NativeFunction(addrCallObjectMethod, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); var funcGetObjectClass = new NativeFunction(addrGetObjectClass, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); var funcGetStringUTFChars = new NativeFunction(addrGetStringUTFChars, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); var funcReleaseStringUTFChars = new NativeFunction(addrReleaseStringUTFChars, &quot;void&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); var clz_obj = funcAllocObject(env, java_class); var mid_getClass = funcGetMethodID(env, java_class, Memory.allocUtf8String(&quot;getClass&quot;), Memory.allocUtf8String(&quot;()Ljava/lang/Class;&quot;)); var clz_obj2 = funcCallObjectMethod(env, clz_obj, mid_getClass); var cls = funcGetObjectClass(env, clz_obj2); var mid_getName = funcGetMethodID(env, cls, Memory.allocUtf8String(&quot;getName&quot;), Memory.allocUtf8String(&quot;()Ljava/lang/String;&quot;)); var name_jstring = funcCallObjectMethod(env, clz_obj2, mid_getName); var name_pchar = funcGetStringUTFChars(env, name_jstring, ptr(0)); var class_name = ptr(name_pchar).readCString(); funcReleaseStringUTFChars(env, name_jstring, name_pchar); //console.log(class_name); var methods_ptr = ptr(args[2]); var method_count = parseInt(args[3]); for (var i = 0; i &lt; method_count; i++) &#123; var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3)); var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize)); var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2)); var name = Memory.readCString(name_ptr); var sig = Memory.readCString(sig_ptr); var find_module = Process.findModuleByAddress(fnPtr_ptr); console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;module_name:&quot;, find_module.name, &quot;module_base:&quot;, find_module.base, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base)); &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; ishook_libart = true;&#125; jni各种类型参数打印123456789101112131415161718192021222324252627282930313233343536function abc()&#123; var base_address=Module.findBaseAddress(&apos;libcms.so&apos;) if (base_address!=null)&#123; console.log(&quot;param:ok&quot;); var str; Java.perform(function () &#123; str = Java.use(&quot;java.lang.String&quot;); &#125;); Interceptor.attach(base_address.add(0x16e19), &#123; onEnter: function (args) &#123; // console.log(&quot;param1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + args[0].readCString()); // console.log(&quot;param1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + Memory.readUtf16String(args[0])); // readAnsiString console.log(&quot;hook success&quot;); var s3 = Java.cast(args[3], str); var s5 = Java.cast(args[5], str); console.log(&quot;param2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + args[2].toInt32()); console.log(&quot;param3&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + s3); const length = Java.vm.getEnv().getArrayLength(args[4]); var array=[]; for(var i=0;i&lt;length;i++)&#123; var obj=Java.vm.getEnv().getObjectArrayElement (args[4],i) var result=Java.vm.getEnv().stringFromJni(obj) array.push(result); &#125; console.log(&quot;param4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + JSON.stringify(array)); console.log(&quot;param5&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + s5); &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125;&#125;abc(); 动态hook Native函数12345678910111213141516171819202122232425262728293031# Exports[i].name 可通过ida分析找出function c()&#123; const hooks = Module.load(&apos;libcore.so&apos;); var Exports = hooks.enumerateExports(); for(var i = 0; i &lt; Exports.length; i++) &#123; var str; Java.perform(function () &#123; str = Java.use(&quot;java.lang.String&quot;); &#125;); if(Exports[i].name==&quot;Java_com_yxcorp_gifshow_util_CPU_getClock&quot;)&#123; //函数类型 console.log(&quot;type:&quot;,Exports[i].type); //函数名称 console.log(&quot;name:&quot;,Exports[i].name); //函数地址 console.log(&quot;address:&quot;,(Exports[i].address)); Interceptor.attach(Exports[i].address, &#123; onEnter: function (args) &#123; // Java.vm.getEnv().GetObjectClass(args[0]) // console.log(&quot;param1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--------------------------&quot;+Memory.readUtf16String(args[0])); &#125;, onLeave: function (retval) &#123; // console.log(&quot;param1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--------------------------&quot;) // var result=Java.vm.getEnv().newStringUtf(retval) // console.log(&quot;param result&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--------------------------&quot;+Java.cast(retval, str)); &#125; &#125;); &#125; &#125; &#125;","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"frida","slug":"frida","permalink":"https://langgithub.github.io/tags/frida/"}]},{"title":"hadoop windows配置","slug":"hadoop windows配置","date":"2020-06-09T09:29:21.376Z","updated":"2020-06-09T09:29:21.376Z","comments":true,"path":"2020/06/09/hadoop windows配置/","link":"","permalink":"https://langgithub.github.io/2020/06/09/hadoop windows配置/","excerpt":"","text":"参考：http://www.bkjia.com/ASPjc/931209.html 1.hadoop环境配置 2.hadoop bin下添加winutils.exe 3.hadoop.dll放到C:\\Windows\\System32 代码配置 //hadoop执行者 System.setProperty(“HADOOP_USER_NAME”,”root”); //hadoop目录 System.setProperty(“hadoop.home.dir”, “D:\\hadoop\\hadoop-2.5.2”); //集群连接配置 Configuration conf=new Configuration(); conf.set(“fs.defaultFS”, “hdfs://node1:8020”); conf.set(“yarn.resourcemanager.hostname”, “node3”);","categories":[{"name":"数据存储-bigdata","slug":"数据存储-bigdata","permalink":"https://langgithub.github.io/categories/数据存储-bigdata/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://langgithub.github.io/tags/hadoop/"}]},{"title":"hash相关题","slug":"hash相关题","date":"2020-06-09T09:29:21.376Z","updated":"2020-06-09T09:29:21.376Z","comments":true,"path":"2020/06/09/hash相关题/","link":"","permalink":"https://langgithub.github.io/2020/06/09/hash相关题/","excerpt":"","text":"三数之和1234567891011121314151617class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: if len(nums)&lt;3: return [] nums.sort() res=set() for i , x in enumerate(nums[:-2]): if i&gt;=1 and x==nums[i-1]: continue d=&#123;&#125; for j in nums[i+1:]: # 判断 -（x+j）=j if j not in d: d[-x-j]=1 else: res.add((x,-j-x,j)) return map(list,res) 字典树123456789101112131415161718192021222324252627class Trie(): def __init__(self): self.root=&#123;&#125; self.end_word=&quot;#&quot; def insert(self,word): node=self.root for char in word: node=node.setdefault(char,&#123;&#125;) node[self.end_word]=self.end_word def find(self,word): node=self.root for char in word: if char not in node: return False node=node[char] return self.end_word in node def startWith(self,word): node = self.root for char in word: if char not in node: return False node = node[char] return True","categories":[{"name":"面试","slug":"面试","permalink":"https://langgithub.github.io/categories/面试/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://langgithub.github.io/tags/算法/"}]},{"title":"git使用总结","slug":"git使用总结","date":"2020-06-09T09:29:21.376Z","updated":"2020-06-09T09:29:21.376Z","comments":true,"path":"2020/06/09/git使用总结/","link":"","permalink":"https://langgithub.github.io/2020/06/09/git使用总结/","excerpt":"","text":"git使用总结 常用命令 other other git仓库一般三个分支 develop test master git submodule (ServerProject ClientProject Protobuf-java ProtoFile) 4个仓库 分支切换无法实现内部仓库切换 git subtree (ServerProject ClientProject Protobuf-java ProtoFile) 仓库合并 分支切换实现内部仓库切","categories":[{"name":"辅助工具","slug":"辅助工具","permalink":"https://langgithub.github.io/categories/辅助工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://langgithub.github.io/tags/git/"}]},{"title":"go语言开发基础篇","slug":"go语言开发基础篇","date":"2020-06-09T09:29:21.376Z","updated":"2020-06-09T09:29:21.376Z","comments":true,"path":"2020/06/09/go语言开发基础篇/","link":"","permalink":"https://langgithub.github.io/2020/06/09/go语言开发基础篇/","excerpt":"","text":"go语言开发基础篇 go语言特点 ide go语言特点 从C语言中继承了很多概念，包括表达式，控制结构，基本类型，参数传值，指针 引入包的概念 自动垃圾回收 天然并发 实现简单 goroutine,轻量级线程，高效利用多核 基于CPS并发模型（Communitcationg Sequential Processes） 吸收管道通讯机制，形成go语言特有的管道channel 通过channel 可以实现不同的goroute之间的通信 函数可以多个返回值 切片slice，延时执行defer","categories":[{"name":"code-go","slug":"code-go","permalink":"https://langgithub.github.io/categories/code-go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://langgithub.github.io/tags/go/"}]},{"title":"c++指针","slug":"c++指针","date":"2020-06-09T09:29:21.375Z","updated":"2020-06-09T09:29:21.376Z","comments":true,"path":"2020/06/09/c++指针/","link":"","permalink":"https://langgithub.github.io/2020/06/09/c++指针/","excerpt":"","text":"c++指针Gerneral函数指针 先定义函数 再定义函数指针 =&gt; 返回值 （）(参数类型1,参数类型2, …) 或者 返回值 （ptrFunc）(参数类型1,参数类型2, …) 内联函数 在函数申明加 inline 或在函数定义加 inline 宏定义 #define S(num) num*num int result=S(10+5) ==&gt; int result=10+5*10+5 (结果65，和预期不一样) 引用 不可以直接引用常量,可以使用常量的引用 const double&amp; d=12.3 引用并非对象，只是已存在对象的一个别名 引用更接近const指针，一旦与某变量关联起来，就将一直效忠与它 将引用变量用作参数，函数将使用原始数据，而非副本 当数据所在内存比较大，建议使用引用 返回引用1：函数中不要返回局部变量的引用，因为局部变量回回收，可能被别人使用 返回引用2: 函数可以不返回值，默认返回传入的应用对象本身（最后一个计算） 返回引用3: 要求函数参数中包含返回的引用对象 引用bug 解决办法是将返回类型改为const int&amp; （int &amp;num1,&amp;num2）123int num=10int&amp; result=sum(num);sum(num)=55; 默认的参数 默认参数和参数不能交替出现 函数模版 函数定义时不指定具体的数据类型（用虚拟类型代替） 函数被调用时编译器根据实参反推数据类型1234template &lt;typename arg1,typename arg2,...&gt;返回值类型 函数名称()&#123; // 函数体&#125; c++中的类123456789101112class Land&#123;public: Land(); ~Land(); String name; long score; int cards[10]; void TouchCard(int[]); bool PlayCard(int[]); void ShowScore();&#125; 访问修饰符，默认是private 构造函数 this返回当前对象的引用 return *this 运算符重载 使用operator 修饰符修饰 const const 修饰谁，谁就不能被修改 const返回值，如果返回局部变量，返回值就不能是&amp; 引用。若要是返回引用，就不能返回局部变量 复制构造函数 对象复制 str2=str1 是浅复制，str对象有指针，只是复制了指针，修改指针的内容，两个都会变 因此需要重载赋值运算 类型转换 自动类型转换 强制类型转换 其他类型转换为当前类型 当前类型转化为其他类型 operator type(){return XXX} 继承多态 基类引用指向派生类 People&amp; people= peo 基类指针指向派生类 People* people= &amp;peo 父类引用/指针指向子类 Man&amp; man=(Man&amp;)people","categories":[{"name":"code-c++","slug":"code-c","permalink":"https://langgithub.github.io/categories/code-c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://langgithub.github.io/tags/c/"}]},{"title":"asyncio剖析—认识awaitable(一)","slug":"asyncio剖析—认识awaitable(一)","date":"2020-06-09T09:29:21.375Z","updated":"2020-06-09T09:29:21.375Z","comments":true,"path":"2020/06/09/asyncio剖析—认识awaitable(一)/","link":"","permalink":"https://langgithub.github.io/2020/06/09/asyncio剖析—认识awaitable(一)/","excerpt":"","text":"Asyncio 我的理解 __await__ 协议是啥？ 为啥Awaitable，Coroutine，Future，Task都有 __await__ asyncio 调用栈都有哪些,具体包含那几部 Awaitable源码12345678910111213class Awaitable(metaclass=ABCMeta): __slots__ = () @abstractmethod def __await__(self): yield @classmethod def __subclasshook__(cls, C): if cls is Awaitable: return _check_methods(C, &quot;__await__&quot;) return NotImplemented Coroutine源码123456789101112131415161718192021222324252627282930313233343536373839404142class Coroutine(Awaitable): __slots__ = () @abstractmethod def send(self, value): &quot;&quot;&quot;Send a value into the coroutine. Return next yielded value or raise StopIteration. &quot;&quot;&quot; raise StopIteration @abstractmethod def throw(self, typ, val=None, tb=None): &quot;&quot;&quot;Raise an exception in the coroutine. Return next yielded value or raise StopIteration. &quot;&quot;&quot; if val is None: if tb is None: raise typ val = typ() if tb is not None: val = val.with_traceback(tb) raise val def close(self): &quot;&quot;&quot;Raise GeneratorExit inside coroutine. &quot;&quot;&quot; try: self.throw(GeneratorExit) except (GeneratorExit, StopIteration): pass else: raise RuntimeError(&quot;coroutine ignored GeneratorExit&quot;) @classmethod def __subclasshook__(cls, C): if cls is Coroutine: return _check_methods(C, &apos;__await__&apos;, &apos;send&apos;, &apos;throw&apos;, &apos;close&apos;) return NotImplementedCoroutine.register(coroutine) Future源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223class Future: &quot;&quot;&quot;This class is *almost* compatible with concurrent.futures.Future. Differences: - This class is not thread-safe. - result() and exception() do not take a timeout argument and raise an exception when the future isn&apos;t done yet. - Callbacks registered with add_done_callback() are always called via the event loop&apos;s call_soon(). - This class is not compatible with the wait() and as_completed() methods in the concurrent.futures package. (In Python 3.4 or later we may be able to unify the implementations.) &quot;&quot;&quot; # Class variables serving as defaults for instance variables. _state = _PENDING _result = None _exception = None _loop = None _source_traceback = None # This field is used for a dual purpose: # - Its presence is a marker to declare that a class implements # the Future protocol (i.e. is intended to be duck-type compatible). # The value must also be not-None, to enable a subclass to declare # that it is not compatible by setting this to None. # - It is set by __iter__() below so that Task._step() can tell # the difference between `yield from Future()` (correct) vs. # `yield Future()` (incorrect). _asyncio_future_blocking = False _log_traceback = False def __init__(self, *, loop=None): &quot;&quot;&quot;Initialize the future. The optional event_loop argument allows explicitly setting the event loop object used by the future. If it&apos;s not provided, the future uses the default event loop. &quot;&quot;&quot; if loop is None: self._loop = events.get_event_loop() else: self._loop = loop self._callbacks = [] if self._loop.get_debug(): self._source_traceback = events.extract_stack(sys._getframe(1)) _repr_info = base_futures._future_repr_info def __repr__(self): return &apos;&lt;%s %s&gt;&apos; % (self.__class__.__name__, &apos; &apos;.join(self._repr_info())) # On Python 3.3 and older, objects with a destructor part of a reference # cycle are never destroyed. It&apos;s not more the case on Python 3.4 thanks # to the PEP 442. if compat.PY34: def __del__(self): if not self._log_traceback: # set_exception() was not called, or result() or exception() # has consumed the exception return exc = self._exception context = &#123; &apos;message&apos;: (&apos;%s exception was never retrieved&apos; % self.__class__.__name__), &apos;exception&apos;: exc, &apos;future&apos;: self, &#125; if self._source_traceback: context[&apos;source_traceback&apos;] = self._source_traceback self._loop.call_exception_handler(context) def cancel(self): &quot;&quot;&quot;Cancel the future and schedule callbacks. If the future is already done or cancelled, return False. Otherwise, change the future&apos;s state to cancelled, schedule the callbacks and return True. &quot;&quot;&quot; self._log_traceback = False if self._state != _PENDING: return False self._state = _CANCELLED self._schedule_callbacks() return True def _schedule_callbacks(self): &quot;&quot;&quot;Internal: Ask the event loop to call all callbacks. The callbacks are scheduled to be called as soon as possible. Also clears the callback list. &quot;&quot;&quot; callbacks = self._callbacks[:] if not callbacks: return self._callbacks[:] = [] for callback in callbacks: self._loop.call_soon(callback, self) def cancelled(self): &quot;&quot;&quot;Return True if the future was cancelled.&quot;&quot;&quot; return self._state == _CANCELLED # Don&apos;t implement running(); see http://bugs.python.org/issue18699 def done(self): &quot;&quot;&quot;Return True if the future is done. Done means either that a result / exception are available, or that the future was cancelled. &quot;&quot;&quot; return self._state != _PENDING def result(self): &quot;&quot;&quot;Return the result this future represents. If the future has been cancelled, raises CancelledError. If the future&apos;s result isn&apos;t yet available, raises InvalidStateError. If the future is done and has an exception set, this exception is raised. &quot;&quot;&quot; if self._state == _CANCELLED: raise CancelledError if self._state != _FINISHED: raise InvalidStateError(&apos;Result is not ready.&apos;) self._log_traceback = False if self._exception is not None: raise self._exception return self._result def exception(self): &quot;&quot;&quot;Return the exception that was set on this future. The exception (or None if no exception was set) is returned only if the future is done. If the future has been cancelled, raises CancelledError. If the future isn&apos;t done yet, raises InvalidStateError. &quot;&quot;&quot; if self._state == _CANCELLED: raise CancelledError if self._state != _FINISHED: raise InvalidStateError(&apos;Exception is not set.&apos;) self._log_traceback = False return self._exception def add_done_callback(self, fn): &quot;&quot;&quot;Add a callback to be run when the future becomes done. The callback is called with a single argument - the future object. If the future is already done when this is called, the callback is scheduled with call_soon. &quot;&quot;&quot; if self._state != _PENDING: self._loop.call_soon(fn, self) else: self._callbacks.append(fn) # New method not in PEP 3148. def remove_done_callback(self, fn): &quot;&quot;&quot;Remove all instances of a callback from the &quot;call when done&quot; list. Returns the number of callbacks removed. &quot;&quot;&quot; filtered_callbacks = [f for f in self._callbacks if f != fn] removed_count = len(self._callbacks) - len(filtered_callbacks) if removed_count: self._callbacks[:] = filtered_callbacks return removed_count # So-called internal methods (note: no set_running_or_notify_cancel()). def set_result(self, result): &quot;&quot;&quot;Mark the future done and set its result. If the future is already done when this method is called, raises InvalidStateError. &quot;&quot;&quot; if self._state != _PENDING: raise InvalidStateError(&apos;&#123;&#125;: &#123;!r&#125;&apos;.format(self._state, self)) self._result = result self._state = _FINISHED self._schedule_callbacks() def set_exception(self, exception): &quot;&quot;&quot;Mark the future done and set an exception. If the future is already done when this method is called, raises InvalidStateError. &quot;&quot;&quot; if self._state != _PENDING: raise InvalidStateError(&apos;&#123;&#125;: &#123;!r&#125;&apos;.format(self._state, self)) if isinstance(exception, type): exception = exception() if type(exception) is StopIteration: raise TypeError(&quot;StopIteration interacts badly with generators &quot; &quot;and cannot be raised into a Future&quot;) self._exception = exception self._state = _FINISHED self._schedule_callbacks() if compat.PY34: self._log_traceback = True else: self._tb_logger = _TracebackLogger(self, exception) # Arrange for the logger to be activated after all callbacks # have had a chance to call result() or exception(). self._loop.call_soon(self._tb_logger.activate) def __iter__(self): if not self.done(): self._asyncio_future_blocking = True yield self # This tells Task to wait for completion. assert self.done(), &quot;yield from wasn&apos;t used with future&quot; return self.result() # May raise too. if compat.PY35: __await__ = __iter__ # make compatible with &apos;await&apos; expression Task源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240class Task(futures.Future): &quot;&quot;&quot;A coroutine wrapped in a Future.&quot;&quot;&quot; # An important invariant maintained while a Task not done: # # - Either _fut_waiter is None, and _step() is scheduled; # - or _fut_waiter is some Future, and _step() is *not* scheduled. # # The only transition from the latter to the former is through # _wakeup(). When _fut_waiter is not None, one of its callbacks # must be _wakeup(). # Weak set containing all tasks alive. _all_tasks = weakref.WeakSet() # Dictionary containing tasks that are currently active in # all running event loops. &#123;EventLoop: Task&#125; _current_tasks = &#123;&#125; # If False, don&apos;t log a message if the task is destroyed whereas its # status is still pending _log_destroy_pending = True @classmethod def current_task(cls, loop=None): &quot;&quot;&quot;Return the currently running task in an event loop or None. By default the current task for the current event loop is returned. None is returned when called not in the context of a Task. &quot;&quot;&quot; if loop is None: loop = events.get_event_loop() return cls._current_tasks.get(loop) @classmethod def all_tasks(cls, loop=None): &quot;&quot;&quot;Return a set of all tasks for an event loop. By default all tasks for the current event loop are returned. &quot;&quot;&quot; if loop is None: loop = events.get_event_loop() return &#123;t for t in cls._all_tasks if t._loop is loop&#125; def __init__(self, coro, *, loop=None): assert coroutines.iscoroutine(coro), repr(coro) super().__init__(loop=loop) if self._source_traceback: del self._source_traceback[-1] self._coro = coro self._fut_waiter = None self._must_cancel = False self._loop.call_soon(self._step) self.__class__._all_tasks.add(self) # On Python 3.3 or older, objects with a destructor that are part of a # reference cycle are never destroyed. That&apos;s not the case any more on # Python 3.4 thanks to the PEP 442. if compat.PY34: def __del__(self): if self._state == futures._PENDING and self._log_destroy_pending: context = &#123; &apos;task&apos;: self, &apos;message&apos;: &apos;Task was destroyed but it is pending!&apos;, &#125; if self._source_traceback: context[&apos;source_traceback&apos;] = self._source_traceback self._loop.call_exception_handler(context) futures.Future.__del__(self) def _repr_info(self): return base_tasks._task_repr_info(self) def get_stack(self, *, limit=None): &quot;&quot;&quot;Return the list of stack frames for this task&apos;s coroutine. If the coroutine is not done, this returns the stack where it is suspended. If the coroutine has completed successfully or was cancelled, this returns an empty list. If the coroutine was terminated by an exception, this returns the list of traceback frames. The frames are always ordered from oldest to newest. The optional limit gives the maximum number of frames to return; by default all available frames are returned. Its meaning differs depending on whether a stack or a traceback is returned: the newest frames of a stack are returned, but the oldest frames of a traceback are returned. (This matches the behavior of the traceback module.) For reasons beyond our control, only one stack frame is returned for a suspended coroutine. &quot;&quot;&quot; return base_tasks._task_get_stack(self, limit) def print_stack(self, *, limit=None, file=None): &quot;&quot;&quot;Print the stack or traceback for this task&apos;s coroutine. This produces output similar to that of the traceback module, for the frames retrieved by get_stack(). The limit argument is passed to get_stack(). The file argument is an I/O stream to which the output is written; by default output is written to sys.stderr. &quot;&quot;&quot; return base_tasks._task_print_stack(self, limit, file) def cancel(self): &quot;&quot;&quot;Request that this task cancel itself. This arranges for a CancelledError to be thrown into the wrapped coroutine on the next cycle through the event loop. The coroutine then has a chance to clean up or even deny the request using try/except/finally. Unlike Future.cancel, this does not guarantee that the task will be cancelled: the exception might be caught and acted upon, delaying cancellation of the task or preventing cancellation completely. The task may also return a value or raise a different exception. Immediately after this method is called, Task.cancelled() will not return True (unless the task was already cancelled). A task will be marked as cancelled when the wrapped coroutine terminates with a CancelledError exception (even if cancel() was not called). &quot;&quot;&quot; self._log_traceback = False if self.done(): return False if self._fut_waiter is not None: if self._fut_waiter.cancel(): # Leave self._fut_waiter; it may be a Task that # catches and ignores the cancellation so we may have # to cancel it again later. return True # It must be the case that self._step is already scheduled. self._must_cancel = True return True def _step(self, exc=None): assert not self.done(), \\ &apos;_step(): already done: &#123;!r&#125;, &#123;!r&#125;&apos;.format(self, exc) if self._must_cancel: if not isinstance(exc, futures.CancelledError): exc = futures.CancelledError() self._must_cancel = False coro = self._coro self._fut_waiter = None self.__class__._current_tasks[self._loop] = self # Call either coro.throw(exc) or coro.send(None). try: if exc is None: # We use the `send` method directly, because coroutines # don&apos;t have `__iter__` and `__next__` methods. result = coro.send(None) else: result = coro.throw(exc) except StopIteration as exc: if self._must_cancel: # Task is cancelled right before coro stops. self._must_cancel = False self.set_exception(futures.CancelledError()) else: self.set_result(exc.value) except futures.CancelledError: super().cancel() # I.e., Future.cancel(self). except Exception as exc: self.set_exception(exc) except BaseException as exc: self.set_exception(exc) raise else: blocking = getattr(result, &apos;_asyncio_future_blocking&apos;, None) if blocking is not None: # Yielded Future must come from Future.__iter__(). if result._loop is not self._loop: self._loop.call_soon( self._step, RuntimeError( &apos;Task &#123;!r&#125; got Future &#123;!r&#125; attached to a &apos; &apos;different loop&apos;.format(self, result))) elif blocking: if result is self: self._loop.call_soon( self._step, RuntimeError( &apos;Task cannot await on itself: &#123;!r&#125;&apos;.format( self))) else: result._asyncio_future_blocking = False result.add_done_callback(self._wakeup) self._fut_waiter = result if self._must_cancel: if self._fut_waiter.cancel(): self._must_cancel = False else: self._loop.call_soon( self._step, RuntimeError( &apos;yield was used instead of yield from &apos; &apos;in task &#123;!r&#125; with &#123;!r&#125;&apos;.format(self, result))) elif result is None: # Bare yield relinquishes control for one event loop iteration. self._loop.call_soon(self._step) elif inspect.isgenerator(result): # Yielding a generator is just wrong. self._loop.call_soon( self._step, RuntimeError( &apos;yield was used instead of yield from for &apos; &apos;generator in task &#123;!r&#125; with &#123;!r&#125;&apos;.format( self, result))) else: # Yielding something else is an error. self._loop.call_soon( self._step, RuntimeError( &apos;Task got bad yield: &#123;!r&#125;&apos;.format(result))) finally: self.__class__._current_tasks.pop(self._loop) self = None # Needed to break cycles when an exception occurs. def _wakeup(self, future): try: future.result() except Exception as exc: # This may also be a cancellation. self._step(exc) else: # Don&apos;t pass the value of `future.result()` explicitly, # as `Future.__iter__` and `Future.__await__` don&apos;t need it. # If we call `_step(value, None)` instead of `_step()`, # Python eval loop would use `.send(value)` method call, # instead of `__next__()`, which is slower for futures # that return non-generator iterators from their `__iter__`. self._step() self = None # Needed to break cycles when an exception occurs. 问题1 Awaitable obj1234567891011121314151617Coroutine 继承AwaitableFuture 实现__await__ 协议 if compat.PY35: __await__ = __iter__ # make compatible with &apos;await&apos; expressionTask 继承Future我的理解 所有 Awaitable都可以变为coroutinetasks.py 中如下：@coroutinedef _wrap_awaitable(awaitable): &quot;&quot;&quot;Helper for asyncio.ensure_future(). Wraps awaitable (an object with __await__) into a coroutine that will later be wrapped in a Task by ensure_future(). &quot;&quot;&quot; return (yield from awaitable.__await__()) 问题二 asyncio 调用栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647asyncio 调用栈asyncio.get_event_loop() #根据操作系统生成select轮询 命名loop | | | vasyncio.ensure_future(start_server) | 函数作用： | 1.future直接返回 | 2.iscoroutine封装成task | 3.__await__对象 调用_wrap_awaitable封装成coroutine | v task = tasks.Task(coro, loop=self) | | | self=loop,callback是coro包装成的TaskStepMethWrapper | v handle = events.Handle(callback, args, self) #将task封装成event 放入loop 循环中 yeild future 挂起future自身等待轮询 | | 重点（类似代码）： | self.coro.send(future.result) #初始化task，启动协程 | | | v | yield from connect(sock, (&apos;example.com&apos;, 80)) #委托生成器到connect | | | v | selector.register(sock.fileno(), EVENT_WRITE,on_connected) #注册event 到loop | yield from f #委托生成器到future | | | v | def __iter__(self): | yield self #挂起future自己，直到loop轮询过来进入下一步 | return self.result | | v return task | | | | vloop.run_until_complete() 启动loop 国外大神剖析 http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html 学习博客 https://hatboy.github.io/archives/page/2/ github async demo：https://github.com/langgithub/async-aiotutorial","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"asyncio剖析—Task作用(二)","slug":"asyncio剖析—Task作用(二)","date":"2020-06-09T09:29:21.375Z","updated":"2020-06-09T09:29:21.375Z","comments":true,"path":"2020/06/09/asyncio剖析—Task作用(二)/","link":"","permalink":"https://langgithub.github.io/2020/06/09/asyncio剖析—Task作用(二)/","excerpt":"","text":"函数调用伪代码图 ensure_future wait gather 协程链原因 Collection.deque+动态进行过程中将hand 挂在deque队列中1234567#案例一async def hello2(): print(&quot;hello&quot;) await asyncio.sleep(.0)loop=asyncio.get_event_loop()loop.run_until_complete(hello2()) 123456789101112131415161718192021#案例二async def hello2(): print(&quot;hello2 start&quot;) # await pause(hello2.__name__) print(&quot;hello2 end&quot;)async def pause(name): print(&quot;pause&quot;,name)async def hello(): print(&quot;hello start&quot;) # await pause(hello.__name__) print(&quot;hello end&quot;)loop=asyncio.get_event_loop()loop.run_until_complete(asyncio.wait([hello(),hello2(),pause(&quot;pasue&quot;),hello()]))#asyncio.wait 核心# fs = &#123;ensure_future(f, loop=loop) for f in set(fs)&#125; task乱序# return (yield from _wait(fs, timeout, return_when, loop)) 协程生成器# waiter = loop.create_future() 创建中断协程,标志这wait 协程任务已经完成 123456789101112131415161718192021222324案例三async def hello2(): print(&quot;hello2 start&quot;) # await pause(hello2.__name__) print(&quot;hello2 end&quot;)async def pause(name): print(&quot;pause&quot;,name)async def hello(): print(&quot;hello start&quot;) # await pause(hello.__name__) print(&quot;hello end&quot;)loop=asyncio.get_event_loop()tasks=[]for i in range(2): if i==0: tasks.append(asyncio.ensure_future(hello())) else: tasks.append(asyncio.ensure_future(hello2()))loop.run_until_complete(asyncio.gather(*tasks))","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"android逆向实战","slug":"android逆向实战","date":"2020-06-09T09:29:21.375Z","updated":"2020-06-09T09:29:21.375Z","comments":true,"path":"2020/06/09/android逆向实战/","link":"","permalink":"https://langgithub.github.io/2020/06/09/android逆向实战/","excerpt":"","text":"android逆向实战 android逆向实战 Gerneral 逆向基础 各种文件转换 AS环境搭建 window逆向工具 Mac逆向工具 window，Mac通用逆向工具 Android虚拟机调试器原理与实现 apk调试设置方式 逆向相关脚步 调试 smali调试 IDA调试 Gerneral逆向过程中一些使用方法方式积累 逆向基础各种文件转换 整体来看 局部（反编译部分） 局部（生成apk) AS环境搭建 目前Android studio 已升级到3.x 。本人用3.0版本。3.0版本以上兼容较差，坑较多。 本人jdk版本1.8.0_101。尽量选这个jdk版本左右的版本。不然monitor启动不了，全是因为eclipse插件原因 安装好AS后让其自己下载Android sdk 。不然又是各种坑 Android sdk模拟器貌似只支持Intel。amd处理好像无法启动sdk中的模拟器 window逆向工具 Android killer，一款集打包，编译，逆向的工具。只有window版本 Mac逆向工具 AndroidCrackTool mac 打包，编译，签名，dex2jar（不好用） window，Mac通用逆向工具 JEB(很强大) jadx (免费，定时有更新) Android虚拟机调试器原理与实现 https://www.freebuf.com/articles/terminal/114869.html apk调试设置方式 修改xml的android:debuggable=”true”属性，重新打包。 利用xposed安装BuildProp Enhancer pak,修改ro.debuggable=1 使用工具mprop修改 我们使用的工具是mprop，这里所有的条件是手机必须root adb push “你下载好的mprop目录的mprop文件” /data/local/tmp/ 执行shell123456# 启动$ data/local/tmp/mprop # 设置$ setprop ro.debuggable 1# 恢复init默认逻辑，之后就无法再修改ro属性了$ /data/local/tmp/mprop -r 逆向相关脚步 java -jar ../../baksmali-2.2.6.jar d blackfish/classes7.dex -o xiaohei/src （提取smail代码） java -jar smali.jar a out -o modify.dex 将smali合并成dex 调试smali调试 smailidea.jar 下载并添加到idea java -jar baksmali-2.0.3.jar disassemble XX.apk -o ./XX adb shell am start -D -n 应用包名/Activity具体类名 adb forward tcp:8700 jdwp:18896 加入断点，run remote debug 8700（这里的端口查看monitor） IDA调试 开启android_server 1$ ./android_server 端口转发 123# 接通adb,端口转发adb forward tcp:23946 tcp:23946# 注意：so反调试会检查文件名或端口。尽量改到名称和端口 启动app 1$ adb shell am start -D -n XXXX/XXX 开启ida,debugger option选项,附加进程 运行jdb调试 12jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=xxx# 注意：其中xxx为monitor中处于debug状态的端口 导入结构体jni.h，动态识别函数名称.","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"https://langgithub.github.io/tags/Android逆向/"}]},{"title":"Numpy","slug":"Numpy","date":"2020-06-09T09:29:21.374Z","updated":"2020-06-09T09:29:21.374Z","comments":true,"path":"2020/06/09/Numpy/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Numpy/","excerpt":"","text":"转载1.https://www.toutiao.com/a6458488956890645005/2.https://www.toutiao.com/a6350804864013271298/ 数组属性方法总结 作用 1基本属性 a.dtype数组元素类型float32,uint8,… a.shape数组形状(m,n,o,…) a.size数组元素数 a.itemsize每个元素占字节数 a.nbytes所有元素占的字节 a.ndim数组维度 2形状相关 a.flat所有元素的迭代器 a.flatten()返回一个1维数组的复制 a.ravel()返回一个1维数组，高效 a.resize(new_size)改变形状 a.swapaxes(axis1, axis2)交换两个维度的位置 a.transpose(*axex)交换所有维度的位置 a.T转置，a.transpose() a.squeeze()去除所有长度为1的维度 3填充复制 a.copy()返回数组的一个复制 a.fill(value)将数组的元组设置为特定值 4转化 a.tolist()将数组转化为列表 a.tostring()转换为字符串 a.astype(dtype)转化为指定类型 a.byteswap(False)转换大小字节序 a.view(type_or_dtype)生成一个使用相同内存，但使用不同的表示方法的数组 5复数 a.imag虚部 a.real实部 a.conjugate()复共轭 a.conj()复共轭（缩写） 6保存 a.dump(file)将二进制数据存在file中 a.dump()将二进制数据表示成字符串 a.tofile(fid, sep=””,format=”%s”)格式化ASCⅡ码写入文件 7查找排序 a.nonzero()返回所有非零元素的索引 a.sort(axis=-1)沿某个轴排序 a.argsort(axis=-1)沿某个轴，返回按排序的索引 a.searchsorted(b)返回将b中元素插入a后能保持有序的索引值 8元素数学操作 a.clip(low, high)将数值限制在一定范围内 a.round(decimals=0)近似到指定精度 a.cumsum(axis=None)累加和 a.cumprod(axis=None)累乘积 9约简操作 a.sum(axis=None)求和 a.prod(axis=None)求积 a.min(axis=None)最小值 a.max(axis=None)最大值 a.argmin(axis=None)最小值索引 a.argmax(axis=None)最大值索引 a.ptp(axis=None)最大值减最小值 a.mean(axis=None)平均值 a.std(axis=None)标准差 a.var(axis=None)方差 a.any(axis=None)只要有一个不为0，返回真，逻辑或 a.all(axis=None)所有都不为0，返回真，逻辑与 案例《一》 123456789101112131415161718192021import numpy as np#array=np.array([[1,2],[5,2]],dtype=np.float32)#array=np.zeros((3,4),dtype=np.int16)#array=np.empty((3,4))#array=np.arange(2,12,2)#array=np.arange(12).reshape((3,4))#array=np.linspace(2,10,4)#array=10*np.sin(array)#print(array&lt;2)#array2=np.arange(4).reshape((2,2))#print(np.dot(array,array2)) #随机数求和 123456789101112131415161718192021222324252627282930313233array=np.random.random((2,4))print(array)#print(np.sum(array,axis=1))#print(np.min(array,axis=0))#print(np.max(array))#统计A=np.argmax(array)B=np.argmin(array)C=np.average(array)D=np.median(array) #中位数print(D)print(np.diff(array))print(np.nonzero(array))print(np.sort(array))print(np.transpose(array)) #行列转换print(np.clip(A,5,9))print(np.mean(array,axis=1)) 案例《二》","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"Spark","slug":"Spark","date":"2020-06-09T09:29:21.374Z","updated":"2020-06-09T09:29:21.374Z","comments":true,"path":"2020/06/09/Spark/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Spark/","excerpt":"","text":"RDD五大特征：https://blog.csdn.net/wyqwilliam/article/details/81606602 Spark缓存策略：https://www.cnblogs.com/EnzoDin/p/8552267.html宽窄依赖：https://blog.csdn.net/houmou/article/details/52531205 【原】Learning Spark (Python版) 学习笔记(一)—-RDD 基本概念与命令 【原】Learning Spark (Python版) 学习笔记(二)—-键值对、数据读取与保存、共享特性 【原】Learning Spark (Python版) 学习笔记(三)—-工作原理、调优与Spark SQL 【原】Learning Spark (Python版) 学习笔记(四)—-Spark Sreaming与MLlib机器学习 【原】Spark之机器学习(Python版)(一)——聚类 【原】Spark之机器学习(Python版)(二)——分类 转换算子是 RDD-&gt;RDD,行为算子是RDD-&gt;值reduce是行为算子，reduceByKey是转换算子","categories":[{"name":"数据存储-bigdata","slug":"数据存储-bigdata","permalink":"https://langgithub.github.io/categories/数据存储-bigdata/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://langgithub.github.io/tags/hadoop/"}]},{"title":"WSGI","slug":"WSGI","date":"2020-06-09T09:29:21.374Z","updated":"2020-06-09T09:29:21.374Z","comments":true,"path":"2020/06/09/WSGI/","link":"","permalink":"https://langgithub.github.io/2020/06/09/WSGI/","excerpt":"","text":"WSGI&amp;UWSGI（不考虑uwsgi协议） WSGI：全称是Web Server Gateway Interface，WSGI不是服务器，python模块，框架，API或者任何软件，只是一种规范，描述web server如何与web application通信的规范。server和application的规范在PEP3333中有具体描述。要实现WSGI协议，必须同时实现web server和web application，当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。 uWSGI：是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。 最简单的WSGI实现123456789101112131415[server.py]from wsgiref.simple_server import make_serverfrom app import applicationif __name__==&quot;__main__&quot;: s=make_server(&quot;127.0.0.1&quot;,8888,application) s.serve_forever()[app.py]def application(environ,start_response): status=&apos;200 ok&apos; response_header=[(&apos;Content-type&apos;,&apos;text/plain&apos;)] start_response(status,response_header) return [b&apos;hello world\\n&apos;] 手写简单的web framewok框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151[server.py]from wsgiref.simple_server import make_server# from my.app import applicationfrom my.app import appif __name__==&quot;__main__&quot;: s=make_server(&quot;127.0.0.1&quot;,8888,app) s.serve_forever()[framework.py]# encoding: utf-8&quot;&quot;&quot;--------------------------------------@describe @version: 1.0@project: zen@file: framwork.py@author: yuanlang @time: 2019-06-27 10:00---------------------------------------&quot;&quot;&quot;class HTTPNotFound(Exception): &quot;&quot;&quot;&quot;&quot;&quot;class HTTPError(Exception): &quot;&quot;&quot;&quot;&quot;&quot;class Request(): def __init__(self,environ): self.environ=environ @property def method(self): return self.environ[&quot;REQUEST_METHOD&quot;] @property def path_info(self): return self.environ[&quot;PATH_INFO&quot;] @property def query_string(self): return self.environ[&quot;QUERY_STRING&quot;] @property def args(self): if self.query_string==&quot;&quot; or self.method!=&quot;GET&quot;: return None kv_args=&#123;&#125; querys=self.query_string.split(&quot;&amp;&quot;) for query in querys: kv=query.split(&quot;=&quot;) kv_args[kv[0]]=kv[1] return kv_args @property def form(self): passclass Response(): def __init__(self): self.status=200 self._headers = [] self.body=b&quot;&quot; @property def headers(self): return self._headers @headers.setter def headers(self,headers): self._headers =headersresponse_status=&#123;&quot;200&quot;:&quot;ok&quot;,&quot;404&quot;:&quot;not found&quot;&#125;class FramWork(): def __init__(self): self.route_list=[] def __call__(self,environ,start_response): # print(environ) request=Request(environ) response=Response() matched = False for (path, method, func) in self.route_list: if request.path_info==path and request.method==method: matched = True response.status = f&quot;200 &#123;response_status[&apos;200&apos;]&#125;&quot; response.headers = [(&apos;Content-type&apos;, &apos;text/plain&apos;)] result=bytes(func(request),encoding=&quot;utf8&quot;) if result is None: raise HTTPError response.body=result if request.path_info==&quot;/favicon.ico&quot;: matched = True if not matched: raise HTTPNotFound start_response(&quot;200 ok&quot;,response.headers) return [response.body] def route(self,path,method): if method is None: method=&quot;GET&quot; def _decoration(func): self.route_list.append((path,method,func)) return _decoration def get(self,path): self.route(path,&quot;GET&quot;) def post(self,path): self.route(path,&quot;POST&quot;)[app.py]# encoding: utf-8&quot;&quot;&quot;--------------------------------------@describe @version: 1.0@project: zen@file: app.py@author: yuanlang @time: 2019-06-26 16:51---------------------------------------&quot;&quot;&quot;import jsonfrom framwork import FramWork,Requestapp=FramWork()@app.route(&quot;/index&quot;,&quot;GET&quot;)def index(request:Request): print(request.args) return &quot;index&quot;@app.route(&apos;/find&apos;,&quot;POST&quot;)def find(request:Request): params=request.form return json.dumps(params) 核心思路：","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"},{"name":"WSGI","slug":"WSGI","permalink":"https://langgithub.github.io/tags/WSGI/"}]},{"title":"NLP—HMM","slug":"NlP—HMM","date":"2020-06-09T09:29:21.374Z","updated":"2020-06-09T09:29:21.374Z","comments":true,"path":"2020/06/09/NlP—HMM/","link":"","permalink":"https://langgithub.github.io/2020/06/09/NlP—HMM/","excerpt":"","text":"经典的blog ：https://www.cnblogs.com/skyme/p/4651331.html基本思想：根据观察序列找出最有可能的隐藏状态序列个人理解 1.什么是马尔科夫链？ 具有马尔科夫行为过程 2.什么是马尔科夫过程 ？ 未来取决于现在不取决于过去","categories":[{"name":"算法-NLP","slug":"算法-NLP","permalink":"https://langgithub.github.io/categories/算法-NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://langgithub.github.io/tags/NLP/"}]},{"title":"NLP—博客推荐","slug":"NLP—博客推荐","date":"2020-06-09T09:29:21.373Z","updated":"2020-06-09T09:29:21.373Z","comments":true,"path":"2020/06/09/NLP—博客推荐/","link":"","permalink":"https://langgithub.github.io/2020/06/09/NLP—博客推荐/","excerpt":"","text":"NLP词法、句法、语义、语篇综合系列：NLP+词法系列（一）︱中文分词技术小结、几大分词引擎的介绍与比较NLP+词法系列（二）︱中文分词技术及词性标注研究现状（CIPS2016）NLP+句法结构（三）︱中文句法结构研究现状（CIPS2016）NLP+语义分析（四）︱中文语义分析研究现状（CIPS2016）NLP+语篇分析（五）︱中文语篇分析研究现状（CIPS2016） 转载：https://blog.csdn.net/sinat_26917383/article/details/55682577","categories":[{"name":"算法-NLP","slug":"算法-NLP","permalink":"https://langgithub.github.io/categories/算法-NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://langgithub.github.io/tags/NLP/"}]},{"title":"Matplotlib","slug":"Matplotlib","date":"2020-06-09T09:29:21.373Z","updated":"2020-06-09T09:29:21.373Z","comments":true,"path":"2020/06/09/Matplotlib/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Matplotlib/","excerpt":"","text":"一：基本知识 第一层是底层的容器层，主要包括Canvas（画板）、Figure（画布）、Axes（绘画区） 第二层是辅助显示层，主要包括Axis（坐标）、Spines（边框线）、Tick（刻度）、Grid（网格）、Legend（图例）、Title（标题）等 第三层为图像层，即通过plot（折线）、hist（直方图）、contour、bar（条形图）、barbs、scatter（散点），pie(饼图)等方法绘制的图像。 基本概念 绘图参数《一》 绘图参数《二》 二.案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import matplotlib.pyplotaspltimportnumpyasnpfig=plt.figure()fig.set_figwidth(1200)########饼图############axes=fig.add_subplot(2,3,1)labels=&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;fracs=[15,30,45,10]axes.set_aspect(aspect=1)#plt.axes(aspect=1)使x y轴比例相同explode=[0,0.05,0,0]#突出某一部分区域axes.pie(x=fracs,labels=labels,autopct=&apos;%.0f%%&apos;,explode=explode)#autopct显示百分比########线图###########axes=fig.add_subplot(2,3,2)x=np.arange(1,5)y=x*2axes.plot(x,y)axes.grid(True,color=&apos;g&apos;,linestyle=&apos;--&apos;,linewidth=&apos;1&apos;)#########多条线#########axes=fig.add_subplot(2,3,3)x=np.arange(1,11,1)axes.plot(x,x*2)axes.plot(x,x*3)axes.plot(x,x*4)axes.legend([&apos;Normal&apos;,&apos;Fast&apos;,&apos;Faster&apos;])########散点图##########axes=fig.add_subplot(2,3,4)x=np.random.randn(1000)y=x+np.random.randn(1000)*0.5axes.scatter(x,y,s=5,marker=&apos;&lt;&apos;)# s表示面积，marker表示图形#########条形图##########axes=fig.add_subplot(2,3,5)y=[20,10,40,25,15]index=np.arange(5)axes.bar(left=index,height=y,color=&apos;green&apos;)#########箱形图##########axes=fig.add_subplot(2,3,6)data=np.random.normal(size=(1000,4),loc=0,scale=1)#标准整体分布labels=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]axes.boxplot(data,labels=labels)plt.show()#########直方图##########mu=100sigma=20x=mu+sigma*np.random.randn(20000)#样本数量plt.hist(x,bins=100,color=&apos;green&apos;,normed=True)# bins显示有几个直方,normed是否对数据进行标准化plt.show()#########等高线###########定义等高线图的横纵坐标x，y#从左边取值为从-3到3，各取5个点，一共取5*5 = 25个点x=np.linspace(-3,3,5)y=np.linspace(-3,3,5)#将原始数据变成网格数据X, Y=np.meshgrid(x, y)#各地点对应的高度数据#Height是个5*5的数组，记录地图上25个点的高度汇总Height= [[0,0,1,2,2],[0,-2,-2,1,5],[4,2,6,8,1],[3,-3,-3,0,5],[1,-5,-2,0,3]]#填充颜色plt.contourf(X, Y, Height,10,alpha=0.6,cmap=plt.cm.hot)#绘制等高线C=plt.contour(X, Y, Height,10,colors=&apos;black&apos;,linewidth=0.5)#显示各等高线的数据标签plt.clabel(C,inline=True,fontsize=10)plt.show() figure布局figure图2figure图3 三.自定义函数图形12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455importmatplotlib.pyplotaspltimportnumpyasnpx=np.linspace(-3,3,50)y1=2*x+1y2=x**2# plt.figure()# plt.plot(x,y1)plt.figure()l1=plt.plot(x,y2,label=&apos;up&apos;)l2=plt.plot(x,y1,color=&apos;red&apos;,linewidth=1.0,linestyle=&apos;--&apos;,label=&apos;down&apos;)plt.xlim((-1,2))plt.ylim((-3,5))plt.ylabel(&apos;I am y&apos;)plt.xlabel(&apos;I am x&apos;)new_ticks=np.linspace(-1,2,5)print(new_ticks)plt.xticks(new_ticks)plt.yticks([-2,-1.8,-1,1,3],[r&apos;$re\\ bad$&apos;,r&apos;$re2\\alpha$&apos;,r&apos;$re3$&apos;,&apos;re4&apos;,&apos;re5&apos;])ax=plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)#ax.xaxis.set_ticks_position(&apos;bottom&apos;)#ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;,0))ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))plt.legend()#plt.legend(handles=[l1,],labels=[&apos;aa&apos;,],loc=&apos;best&apos;)plt.show()","categories":[{"name":"code-python","slug":"code-python","permalink":"https://langgithub.github.io/categories/code-python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://langgithub.github.io/tags/python/"}]},{"title":"NLP—Word2vec词向量表达","slug":"NLP—Word2vec词向量表达","date":"2020-06-09T09:29:21.373Z","updated":"2020-06-09T09:29:21.373Z","comments":true,"path":"2020/06/09/NLP—Word2vec词向量表达/","link":"","permalink":"https://langgithub.github.io/2020/06/09/NLP—Word2vec词向量表达/","excerpt":"","text":"原理：word2vec原理(一) CBOW与Skip-Gram模型基础word2vec原理(二) 基于Hierarchical Softmax的模型word2vec原理(三) 基于Negative Sampling的模型 实验：转载：https://www.zybuluo.com/hanxiaoyang/note/472184 个人理解：自然语言向量表达，用于比较词的相识度，位置词预测过程： one hot 编码-》构建共现矩阵-》（巧妙采用Huffman编码树【离根节点近的节点出现概率越大】来做神经网络输出函数）-》调整theta 的值计算缺失的词（CBOW）或句子（Skip-Gram）后期优化：负采样代替Huffman编码 问题：矩阵的svd分解意义","categories":[{"name":"算法-NLP","slug":"算法-NLP","permalink":"https://langgithub.github.io/categories/算法-NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://langgithub.github.io/tags/NLP/"}]},{"title":"NLP—分词发展","slug":"NLP—分词发展","date":"2020-06-09T09:29:21.373Z","updated":"2020-06-09T09:29:21.373Z","comments":true,"path":"2020/06/09/NLP—分词发展/","link":"","permalink":"https://langgithub.github.io/2020/06/09/NLP—分词发展/","excerpt":"","text":"1基本信息背景存在中文分词技术，是由于中文在基本文法上有其特殊性，具体表现在： 1．以英文为代表的拉丁语系语言相比，英文以空格作为天然的分隔符，而中文由于继承自古代汉语的传统，词语之间没有分隔。 古代汉语中除了连绵词和人名地名等，词通常就是单个汉字，所以当时没有分词书写的必要。而现代汉语中双字或多字词居多，一个字不再等同于一个词。 2．在中文里，“词”和“词组”边界模糊 现代汉语的基本表达单元虽然为“词”，且以双字或者多字词居多，但由于人们认识水平的不同，对词和短语的边界很难去区分。 例如：“对随地吐痰者给予处罚”，“随地吐痰者”本身是一个词还是一个短语，不同的人会有不同的标准，同样的“海上”“酒厂”等等，即使是同一个人也可能做出不同判断，如果汉语真的要分词书写，必然会出现混乱，难度很大。 中文分词的方法其实不局限于中文应用，也被应用到英文处理，如手写识别，单词之间的空格就很清楚，中文分词方法可以帮助判别英文单词的边界。 作用中文分词是文本挖掘的基础，对于输入的一段中文，成功的进行中文分词，可以达到电脑自动识别语句含义的效果。 中文分词技术属于自然语言处理技术范畴，对于一句话，人可以通过自己的知识来明白哪些是词，哪些不是词，但如何让计算机也能理解？其处理过程就是分词算法。 影响[1]中文分词对于搜索引擎来说，最重要的并不是找到所有结果，因为在上百亿的网页中找到所有结果没有太多的意义，没有人能看得完，最重要的是把最相关的结果排在最前面，这也称为相关度排序。中文分词的准确与否，常常直接影响到对搜索结果的相关度排序。从定性分析来说，搜索引擎的分词算法不同，词库的不同都会影响页面的返回结果。 2算法分类现有的分词算法可分为三大类：基于字符串匹配的分词方法、基于理解的分词方法和基于统计的分词方法。按照是否与词性标注过程相结合，又可以分为单纯分词方法和分词与标注相结合的一体化方法。 字符匹配这种方法又叫做机械分词方法，它是按照一定的策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行配，若在词典中找到某个字符串，则匹配成功（识别出一个词）。按照扫描方向的不同，串匹配分词方法可以分为正向匹配和逆向匹配；按照不同长度优先匹配的情况，可以分为最大（最长）匹配和最小（最短）匹配；常用的几种机械分词方法如下： 1）正向最大匹配法（由左到右的方向）； 2）逆向最大匹配法（由右到左的方向）； 3）最少切分（使每一句中切出的词数最小）； 4）双向最大匹配法（进行由左到右、由右到左两次扫描） 还可以将上述各种方法相互组合，例如，可以将正向最大匹配方法和逆向最大匹配方法结合起来构成双向匹配法。由于汉语单字成词的特点，正向最小匹配和逆向最小匹配一般很少使用。一般说来，逆向匹配的切分精度略高于正向匹配，遇到的歧义现象也较少。统计结果表明，单纯使用正向最大匹配的错误率为1/169，单纯使用逆向最大匹配的错误率为1/245。但这种精度还远远不能满足实际的需要。实际使用的分词系统，都是把机械分词作为一种初分手段，还需通过利用各种其它的语言信息来进一步提高切分的准确率。 一种方法是改进扫描方式，称为特征扫描或标志切分，优先在待分析字符串中识别和切分出一些带有明显特征的词，以这些词作为断点，可将原字符串分为较小的串再来进机械分词，从而减少匹配的错误率。另一种方法是将分词和词类标注结合起来，利用丰富的词类信息对分词决策提供帮助，并且在标注过程中又反过来对分词结果进行检验、调整，从而极大地提高切分的准确率。 对于机械分词方法，可以建立一个一般的模型，在这方面有专业的学术论文，这里不做详细论述。 理解法这种分词方法是通过让计算机模拟人对句子的理解，达到识别词的效果。其基本思想就是在分词的同时进行句法、语义分析，利用句法信息和语义信息来处理歧义现象。它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断，即它模拟了人对句子的理解过程。这种分词方法需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式，因此目前基于理解的分词系统还处在试验阶段。 统计法从形式上看，词是稳定的字的组合，因此在上下文中，相邻的字同时出现的次数越多，就越有可能构成一个词。因此字与字相邻共现的频率或概率能够较好的反映成词的可信度。可以对语料中相邻共现的各个字的组合的频度进行统计，计算它们的互现信息。定义两个字的互现信息，计算两个汉字X、Y的相邻共现概率。互现信息体现了汉字之间结合关系的紧密程度。当紧密程度高于某一个阈值时，便可认为此字组可能构成了一个词。这种方法只需对语料中的字组频度进行统计，不需要切分词典，因而又叫做无词典分词法或统计取词方法。但这种方法也有一定的局限性，会经常抽出一些共现频度高、但并不是词的常用字组，例如“这一”、“之一”、“有的”、“我的”、“许多的”等，并且对常用词的识别精度差，时空开销大。实际应用的统计分词系统都要使用一部基本的分词词典（常用词词典）进行串匹配分词，同时使用统计方法识别一些新的词，即将串频统计和串匹配结合起来，既发挥匹配分词切分速度快、效率高的特点，又利用了无词典分词结合上下文识别生词、自动消除歧义的优点。 另外一类是基于统计机器学习的方法。首先给出大量已经分词的文本，利用统计机器学习模型学习词语切分的规律（称为训练），从而实现对未知文本的切分。我们知道，汉语中各个字单独作词语的能力是不同的，此外有的字常常作为前缀出现，有的字缺常常作为后缀（“者”“性”），结合两个字相临时是否成词的信息，这样就得到了许多与分词有关的知识。这种方法就是充分利用汉语组词的规律来分词。这种方法的最大缺点是需要有大量预先分好词的语料作支撑，而且训练过程中时空开销极大。 到底哪种分词算法的准确度更高，目前并无定论。对于任何一个成熟的分词系统来说，不可能单独依靠某一种算法来实现，都需要综合不同的算法。例如，海量科技的分词算法就采用“复方分词法”，所谓复方，就是像中西医结合般综合运用机械方法和知识方法。对于成熟的中文分词系统，需要多种算法综合处理问题。 转载：https://blog.csdn.net/likika2012/article/details/17026935?locationNum=6&amp;fps=1","categories":[{"name":"算法-NLP","slug":"算法-NLP","permalink":"https://langgithub.github.io/categories/算法-NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://langgithub.github.io/tags/NLP/"}]},{"title":"Linux-进程间通信","slug":"Linux-进程间通信","date":"2020-06-09T09:29:21.372Z","updated":"2020-06-09T09:29:21.372Z","comments":true,"path":"2020/06/09/Linux-进程间通信/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-进程间通信/","excerpt":"","text":"Linux-进程间通信 管道 消息队列 信号 共享内存模型和信号量 管道a. 匿名管道1234567891011121314151617181920212223242526272829303132333435// 1. 管道是父子进程间的通信// 2. fd[0] 代表读；fd[1] 代表写。一般是子进程写，即：先关闭fd[0]，在写入fd[1]。父进程读，即：先关闭fd[1],读取fd[0]#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; int fds[2]; if (pipe(fds) == -1) perror(&quot;pipe error&quot;); pid_t pid; pid = fork(); if (pid == -1) perror(&quot;fork error&quot;); if (pid == 0)&#123; close(fds[0]); char msg[] = &quot;hello world&quot;; write(fds[1], msg, strlen(msg) + 1); close(fds[1]); exit(0); &#125; else &#123; close(fds[1]); char msg[128]; read(fds[0], msg, 128); close(fds[0]); printf(&quot;message : %s\\n&quot;, msg); return 0; &#125;&#125; b. linux 管道原理 (ps -ef|grep 进程|awk ‘{print $2}’|xargs kill -9)12345678910111213141516171819202122232425262728293031323334// 控制台标准输入转化成标准输出 写入到fd[1]端，另一个进程标准输入来自fd[0]端#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[])&#123; int fds[2]; if (pipe(fds) == -1) perror(&quot;pipe error&quot;); pid_t pid; pid = fork(); if (pid == -1) perror(&quot;fork error&quot;); if (pid == 0)&#123; dup2(fds[1], STDOUT_FILENO); close(fds[1]); close(fds[0]); execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-ef&quot;, NULL); &#125; else &#123; dup2(fds[0], STDIN_FILENO); close(fds[0]); close(fds[1]); execlp(&quot;grep&quot;, &quot;grep&quot;, &quot;systemd&quot;, NULL); &#125; return 0;&#125; 消息队列a. ipcs -q 就能看到上面我们创建的消息队列对象。b. msgget 函数创建消息队列123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/msg.h&gt;int main() &#123; int messagequeueid; key_t key; if((key = ftok(&quot;/root/messagequeue/messagequeuekey&quot;, 1024)) &lt; 0) &#123; perror(&quot;ftok error&quot;); exit(1); &#125; printf(&quot;Message Queue key: %d.\\n&quot;, key); if ((messagequeueid = msgget(key, IPC_CREAT|0777)) == -1) &#123; perror(&quot;msgget error&quot;); exit(1); &#125; printf(&quot;Message queue id: %d.\\n&quot;, messagequeueid);&#125; c. msgsnd发送msg到消息队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/msg.h&gt;#include &lt;getopt.h&gt;#include &lt;string.h&gt;struct msg_buffer &#123; long mtype; char mtext[1024];&#125;;int main(int argc, char *argv[]) &#123; int next_option; const char* const short_options = &quot;i:t:m:&quot;; const struct option long_options[] = &#123; &#123; &quot;id&quot;, 1, NULL, &apos;i&apos;&#125;, &#123; &quot;type&quot;, 1, NULL, &apos;t&apos;&#125;, &#123; &quot;message&quot;, 1, NULL, &apos;m&apos;&#125;, &#123; NULL, 0, NULL, 0 &#125; &#125;; int messagequeueid = -1; struct msg_buffer buffer; buffer.mtype = -1; int len = -1; char * message = NULL; do &#123; next_option = getopt_long (argc, argv, short_options, long_options, NULL); switch (next_option) &#123; case &apos;i&apos;: messagequeueid = atoi(optarg); break; case &apos;t&apos;: buffer.mtype = atol(optarg); break; case &apos;m&apos;: message = optarg; len = strlen(message) + 1; if (len &gt; 1024) &#123; perror(&quot;message too long.&quot;); exit(1); &#125; memcpy(buffer.mtext, message, len); break; default: break; &#125; &#125;while(next_option != -1); if(messagequeueid != -1 &amp;&amp; buffer.mtype != -1 &amp;&amp; len != -1 &amp;&amp; message != NULL)&#123; if(msgsnd(messagequeueid, &amp;buffer, len, IPC_NOWAIT) == -1)&#123; perror(&quot;fail to send message.&quot;); exit(1); &#125; &#125; else &#123; perror(&quot;arguments error&quot;); &#125; return 0;&#125; d. msgrcv接受消息队列消息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/msg.h&gt;#include &lt;getopt.h&gt;#include &lt;string.h&gt;struct msg_buffer &#123; long mtype; char mtext[1024];&#125;;int main(int argc, char *argv[]) &#123; int next_option; const char* const short_options = &quot;i:t:&quot;; const struct option long_options[] = &#123; &#123; &quot;id&quot;, 1, NULL, &apos;i&apos;&#125;, &#123; &quot;type&quot;, 1, NULL, &apos;t&apos;&#125;, &#123; NULL, 0, NULL, 0 &#125; &#125;; int messagequeueid = -1; struct msg_buffer buffer; long type = -1; do &#123; next_option = getopt_long (argc, argv, short_options, long_options, NULL); switch (next_option) &#123; case &apos;i&apos;: messagequeueid = atoi(optarg); break; case &apos;t&apos;: type = atol(optarg); break; default: break; &#125; &#125;while(next_option != -1); if(messagequeueid != -1 &amp;&amp; type != -1)&#123; if(msgrcv(messagequeueid, &amp;buffer, 1024, type, IPC_NOWAIT) == -1)&#123; perror(&quot;fail to recv message.&quot;); exit(1); &#125; printf(&quot;received message type : %d, text: %s.&quot;, buffer.mtype, buffer.mtext); &#125; else &#123; perror(&quot;arguments error&quot;); &#125; return 0;&#125; 信号a. 信号值位于SIGRTMIN(=32)和SIGRTMAX(=63)之间的信号都是可靠信号,其他为不可靠信号b. 信号注册与使用 c. 信号在操作系统中处理流程 共享内存模型和信号量a. 通过程序创建的共享内存和信号量集合，我们可以通过命令 ipcs 查看。当然，我们也可以通过 ipcrm 进行删除。b. 共享内存与信号量初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;string.h&gt;#define MAX_NUM 128struct shm_data &#123; int data[MAX_NUM]; int datalength;&#125;;union semun &#123; int val; struct semid_ds *buf; unsigned short int *array; struct seminfo *__buf; &#125;; int get_shmid()&#123; int shmid; key_t key; if((key = ftok(&quot;/root/sharememory/sharememorykey&quot;, 1024)) &lt; 0)&#123; perror(&quot;ftok error&quot;); return -1; &#125; shmid = shmget(key, sizeof(struct shm_data), IPC_CREAT|0777); return shmid;&#125;int get_semaphoreid()&#123; int semid; key_t key; if((key = ftok(&quot;/root/sharememory/semaphorekey&quot;, 1024)) &lt; 0)&#123; perror(&quot;ftok error&quot;); return -1; &#125; semid = semget(key, 1, IPC_CREAT|0777); return semid;&#125;int semaphore_init (int semid) &#123; union semun argument; unsigned short values[1]; values[0] = 1; argument.array = values; return semctl (semid, 0, SETALL, argument); &#125;int semaphore_p (int semid) &#123; struct sembuf operations[1]; operations[0].sem_num = 0; operations[0].sem_op = -1; operations[0].sem_flg = SEM_UNDO; return semop (semid, operations, 1); &#125;int semaphore_v (int semid) &#123; struct sembuf operations[1]; operations[0].sem_num = 0; operations[0].sem_op = 1; operations[0].sem_flg = SEM_UNDO; return semop (semid, operations, 1); &#125; c. 生成者1234567891011121314151617181920212223242526272829303132333435363738#include &quot;share.h&quot;int main() &#123; void *shm = NULL; struct shm_data *shared = NULL; int shmid = get_shmid(); int semid = get_semaphoreid(); int i; shm = shmat(shmid, (void*)0, 0); if(shm == (void*)-1)&#123; exit(0); &#125; shared = (struct shm_data*)shm; memset(shared, 0, sizeof(struct shm_data)); semaphore_init(semid); while(1)&#123; semaphore_p(semid); if(shared-&gt;datalength &gt; 0)&#123; semaphore_v(semid); sleep(1); &#125; else &#123; printf(&quot;how many integers to caculate : &quot;); scanf(&quot;%d&quot;,&amp;shared-&gt;datalength); if(shared-&gt;datalength &gt; MAX_NUM)&#123; perror(&quot;too many integers.&quot;); shared-&gt;datalength = 0; semaphore_v(semid); exit(1); &#125; for(i=0;i&lt;shared-&gt;datalength;i++)&#123; printf(&quot;Input the %d integer : &quot;, i); scanf(&quot;%d&quot;,&amp;shared-&gt;data[i]); &#125; semaphore_v(semid); &#125; &#125;&#125; d. 消费者1234567891011121314151617181920212223242526272829303132333435#include &quot;share.h&quot;int main() &#123; void *shm = NULL; struct shm_data *shared = NULL; int shmid = get_shmid(); int semid = get_semaphoreid(); int i; shm = shmat(shmid, (void*)0, 0); if(shm == (void*)-1)&#123; exit(0); &#125; shared = (struct shm_data*)shm; while(1)&#123; semaphore_p(semid); if(shared-&gt;datalength &gt; 0)&#123; int sum = 0; for(i=0;i&lt;shared-&gt;datalength-1;i++)&#123; printf(&quot;%d+&quot;,shared-&gt;data[i]); sum += shared-&gt;data[i]; &#125; printf(&quot;%d&quot;,shared-&gt;data[shared-&gt;datalength-1]); sum += shared-&gt;data[shared-&gt;datalength-1]; printf(&quot;=%d\\n&quot;,sum); memset(shared, 0, sizeof(struct shm_data)); semaphore_v(semid); &#125; else &#123; semaphore_v(semid); printf(&quot;no tasks, waiting.\\n&quot;); sleep(1); &#125; &#125;&#125; e. 消费者与生成者结果图 f. 共享内存原理 g. 信号量的本质","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"Linux-进程调度","slug":"Linux-进程调度","date":"2020-06-09T09:29:21.372Z","updated":"2020-06-09T09:29:21.372Z","comments":true,"path":"2020/06/09/Linux-进程调度/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-进程调度/","excerpt":"","text":"Linux-进程调度 进程调度算法 cpu如何进行进程调度 主动调度与抢占调度 进程调度算法 stop_sched_class 优先级最高的任务使用这种调度策略，会中断其他线程，不会被其他任务打断 dl_sched_class 对于deadline调度算法，DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务调度执行 rt_sched_class 对于RR算法（时间片轮转）和FIFO算法（先进先出） fair_sched_class 就是普通进程调度策略（完全公平调度算法） idle_sehed_class 空闲进程的调度算法 cpu如何进行进程调度 cpu 会轮询进程调度类stop_sched_class，dl_sched_class，rt_sched_class，fair_sched_class，idle_sehed_class获取其中的rq队列，次rq队列是红黑树实现 获取当前红黑树最左叶子节点，每一个叶子节点都是一个sched_entiry.每个sched_entry里面都是有一个task_struct,每一个task_struct 都有实现了响应调度算法类的函数 主动调度与抢占调度","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"Linux-输入输出设备","slug":"Linux-输入输出设备","date":"2020-06-09T09:29:21.372Z","updated":"2020-06-09T09:29:21.372Z","comments":true,"path":"2020/06/09/Linux-输入输出设备/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-输入输出设备/","excerpt":"","text":"Linux-输入输出设备 快设备在操作系统中的数据结构","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"Linux-虚拟文件系统","slug":"Linux-虚拟文件系统","date":"2020-06-09T09:29:21.372Z","updated":"2020-06-09T09:29:21.372Z","comments":true,"path":"2020/06/09/Linux-虚拟文件系统/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-虚拟文件系统/","excerpt":"","text":"虚拟文件系统 文件系统结构图 文件系统挂载 虚拟文件底层代码结构 文件系统结构图a. 文件读写进入内核态调用相应sys_open ,sys_read,sys_writeb. 内核态通过文件描述符找到struc file。判断file operation 文件系统挂载c. struct file 如何关联struck dentry和struc mount的数据结构d. struct dentry中存有inode相关信息 虚拟文件底层代码结构f. 先look_up 然后找到最总的文件操作","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"Linux-网络通讯","slug":"Linux-网络通讯","date":"2020-06-09T09:29:21.372Z","updated":"2020-06-09T09:29:21.372Z","comments":true,"path":"2020/06/09/Linux-网络通讯/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-网络通讯/","excerpt":"","text":"Linux-网络通讯 tcp 三次握手建立链接 socket write socket read 四次挥手释放链接 三次握手建立链接 socket write socket read","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"Linux-gcc编译","slug":"Linux-gcc编译","date":"2020-06-09T09:29:21.371Z","updated":"2020-06-09T09:29:21.371Z","comments":true,"path":"2020/06/09/Linux-gcc编译/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-gcc编译/","excerpt":"","text":"Linux-gcc编译 gcc编译流程 ELF文件分类 总结 gcc编译流程a. 头文件.h和.c源文件 通过gcc 编译成.o可重定位文件目标文件（如：gcc -c -fPIC process.c）b. 可重定位文件.o 通过ar归档生成静态链接库.a文件（如：ar cr libstaticprocess.a process.o）。可执行程序编译： gcc -o staticcreateprocess createprocess.o -L. -lstaticprocessc. 或者将.o文件编译成动态链接库.so文件 （如：gcc -shared -fPIC -o libdynamicprocess.so process.o）。可执行程序编译 （gcc -o dynamiccreateprocess createprocess.o -L. -ldynamicprocess）。执行需要添加环境变量 export LD_LIBRARY_PATH=.d. 静态链接库.a 在编译过程就将函数调用情况链接。动态链接库.so在运行工作中动态链接函数 ELF文件分类a. 第一种.o可重定位目标文件 * .text 放编译好的二进制可执行代码 * .data 已经初始化好的全局变量 * .rodata 只读数据，例如字符串常量、const 的变量 * .bss 未初始化全局变量，运行时会置 0 * .symtab 符号表，记录的则是函数和变量 * .strtab 字符串表、字符串常量和变量名 * .rel .text 与重定位相关 * .rel .data 与重定位相关 b. 第二种可执行文件 section节被分成了需要加载到内存里面的代码段、数据段和不需要加载到内存里面的部分，将小的 section 合成了大的段 segment，并且在最前面加一个段头表（Segment Header Table）。在 ELF 头里面，有一项 e_entry，也是个虚拟地址，是这个程序运行的入口。c. 第三种动态链接库，也就是共享对象文件 * 首先，多了一个.interp 的 Segment，这里面是 ld-linux.so，这是动态链接器，也就是说，运行时的链接动作都是它做的。 * ELF 文件中还多了两个 section，一个是.plt，过程链接表（Procedure Linkage Table，PLT），一个是.got.plt，全局偏移量表（Global Offset Table，GOT） 总结","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"Linux-系统调用","slug":"Linux-系统调用","date":"2020-06-09T09:29:21.371Z","updated":"2020-06-09T09:29:21.371Z","comments":true,"path":"2020/06/09/Linux-系统调用/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-系统调用/","excerpt":"","text":"Linux-系统调用 什么是系统调用? 系统调用流程 什么是系统调用系统调用是操作系统提供给程序开发人员使用系统服务接口 系统调用流程Linux 提供了 glibc 库, 它封装了系统调用接口, 对上层更友好的提供服务, 系统调用最终都会通过 DO_CALL 发起, 这是一个宏定义, 其 32 位和 64 位的定义是不同的 32位系统调用用户态a. 将请求参数保存到寄存器b. 将系统调用名称转换为调用号保存到eax中c. 通过软中断ENTER_RETURN 进入内核态 内核态a. 将用户态的寄存器保存到pt_regs中b. 在系统调用表 sys_call_table中根据调用号找到响应函数c. 执行函数，将返回值写入pt_regs中ax位置d. 通过INTERRUPT_RETURN 根据pt_regs恢复用户态进程 64位系统调用用户态a. 将请求参数保存到寄存器b. 将系统调用名称转换为系统调用号保存到寄存器rax中c. 通过syscall进入内核态 内核态a. 将用户态寄存器保存到pt_regs中b. 在系统调用表sys_call_table 中根据调用号查找对于函数c. 执行函数，将返回值写入pt_regs中的ax位置d. 通过sysretq返回用户态","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"Linux-线程和进程","slug":"Linux-线程和进程","date":"2020-06-09T09:29:21.371Z","updated":"2020-06-09T09:29:21.371Z","comments":true,"path":"2020/06/09/Linux-线程和进程/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-线程和进程/","excerpt":"","text":"Linux-线程和进程 多线程编程与互斥 进程底层原理 进程与线程底层原理 多线程编程与互斥 进程底层原理 进程与线程底层原理总结：创建进程的话，调用的系统调用是fork,在copy_process函数里面，会将五大结构，file_struct,fs_struct,sighand_struct,signal_struct,mm_struct都会复制一遍，从此父进程和子进程各用各的数据结构，而创建线程的话，调用的是系统调用clone，在copy_process函数里面，五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。tgid此时是进程的id,pid是线程id","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"Linux-系统初始化","slug":"Linux-系统初始化","date":"2020-06-09T09:29:21.371Z","updated":"2020-06-09T09:29:21.371Z","comments":true,"path":"2020/06/09/Linux-系统初始化/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Linux-系统初始化/","excerpt":"","text":"Linux-系统初始化 cpu工作流程 操作系统引导 linux内核启动 cpu工作流程图一 a. cpu 包含运算单元，控制单元，数据单元（控制单元如将数据单元中的代码，数据加载到运算单元运算） 图二 a. 8086架构cpu中有8个16位寄存器用于存放临时数据。通用寄存器（AX,BX,CX,DX）,指针变址寄存器（SP，BP，SI，DI）b. cpu中的控制单元有ip指令指针寄存器，将指令加载到指令队列交给运算单元计算c. cs代码段寄存器，DS数据段寄存器。8086架构中CS和BS 都是基地址。代码段，数据段偏移地址分别放在ip寄存器和通用寄存器。基地址+偏移地址=要加载（代码或数据）。8086的地址总线为20位，寄存器为16位，所以计算目标位置函数=（CS或DS）寄存器中值&lt;4位+通用寄存器的值或IP寄存器中d. 32位cpu CS,DS存放的不是基地址，是寻找基地址的指针 操作系统引导a. BIOS通电，检查硬件设备b. 加载0x7c00 启动boot.img,boot.img 加载core.img,boot.img将控制权交给disboot.img,执行lzma_decompress.img（建立分段分页，打开地址线）。执行kernel.img,最后启动内核 linux内核启动a. 内核入口在init/main.c文件中start_kernel()b. start_kernel启动了init_task第一个进程pid=0的任务。接着是启动trap_init()中断管理,mm_init()内存分配,shed_init()进程调度c. 最后进入reset_init(),通过kernel_thread 初始化kernel_init用户态进程pid=1和kthreadadd内核态进程pid=2。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://langgithub.github.io/tags/Linux/"}]},{"title":"IDA使用总结","slug":"IDA使用总结","date":"2020-06-09T09:29:21.371Z","updated":"2020-06-09T09:29:21.371Z","comments":true,"path":"2020/06/09/IDA使用总结/","link":"","permalink":"https://langgithub.github.io/2020/06/09/IDA使用总结/","excerpt":"","text":"IDA使用总结Gerneral工作中对IDA使用总结 快捷键使用 esc 回退到上一步 g 代码跳转 如果无法反汇编 先跳到指定位置nop上一行 u c p重新分析，即可进来 插件介绍 keypatch安装（https://www.cnblogs.com/lsgxeva/p/8948113.html） ####","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"IDA","slug":"IDA","permalink":"https://langgithub.github.io/tags/IDA/"}]},{"title":"HADOOP——MapReduce","slug":"HADOOP——MapReduce","date":"2020-06-09T09:29:21.370Z","updated":"2020-06-09T09:29:21.370Z","comments":true,"path":"2020/06/09/HADOOP——MapReduce/","link":"","permalink":"https://langgithub.github.io/2020/06/09/HADOOP——MapReduce/","excerpt":"","text":"问题导读 1.hadoop1.x中mapreduce框架与yarn有什么共同点？2.它们有什么不同点？3.yarn中有哪些改变？4.yarn中有哪些术语？ 原文：Hadoop2.x 让你真正明白yarn yarn是比较难懂的一个地方，也是很重要的一个组件，不止hadoop使用yarn，spark，storm也可以使用yarn。因此yarn的理解是非常重要的。如果刚开始学习，其实还是挺难懂的。因为很多的概念比较抽象。如果一时理解不了，也是正常的，这时候就需要我们不断的接触和思考，不断的找资料，强化，通过时间，慢慢就能熟记并且理解。下面是个人总结，希望对大家有所帮助。 相同点hadoop2.x的发展是由于hadoop1.x的问题造成的。那么是什么问题造成的。比较流行的说法是jobtracker的问题，比如单点故障，任务过重。我们知道了除了Jobtracker，同时还有一个TaskTracker。我们看下图： 上图中，有一个JobTracker，多个TaskTracker。 Yarn比较我们在来看yarn 我们看到有一个ResourceManager，多个NodeManager。也就是说hadoop1.x mapreduce框架与hadoop2.x yarn，他们的框架相同之处，都是分布式的。再次总结相同处：JobTracker一个，TaskTracker多个resourceManager一个,NodeManager多个 不同点既然他们框架结构是相同的，那么到底是什么原因，淘汰JobTracker机制。这时候我们就需要看看JobTracker到底干了哪些事情。 再看上图：JobTacker概述JobTacker其承担的任务有：接受任务、计算资源、分配资源、与DataNode进行交流。在hadoop中每个应用程序被表示成一个作业，每个作业又被分成多个任务，JobTracker的作业控制模块则负责作业的分解和状态监控。*最重要的是状态监控：主要包括TaskTracker状态监控、作业状态监控和任务状态监控。主要作用：容错和为任务调度提供决策依据。TaskTracker概述TaskTracker是JobTracker和Task之间的桥梁：一方面，从JobTracker接收并执行各种命令：运行任务、提交任务、杀死任务等；另一方面，将本地节点上各个任务的状态通过心跳周期性汇报给JobTracker。TaskTracker与JobTracker和Task之间采用了RPC协议进行通信 TaskTracker的功能：1.汇报心跳：Tracker周期性将所有节点上各种信息通过心跳机制汇报给JobTracker。这些信息包括两部分：机器级别信息：节点健康情况、资源使用情况等。 任务级别信息：任务执行进度、任务运行状态等。2.执行命令：JobTracker会给TaskTracker下达各种命令，主要包括：启动任务(LaunchTaskAction)、提交任务(CommitTaskAction)、杀死任务(KillTaskAction)、杀死作业(KillJobAction)和重新初始化(TaskTrackerReinitAction)。 资源slot概述slot不是CPU的Core，也不是memory chip，它是一个逻辑概念，一个节点的slot的数量用来表示某个节点的资源的容量或者说是能力的大小，因而slot是 Hadoop的资源单位。 hadoop中什么是slotshttp://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=7562 yarn详解Yarn的基本思想是拆分资源管理的功能，作业调度/监控到单独的守护进程这里面出现了很多名词：ResourceManager，NodeManager，ApplicationMaster，Container,同样下面亦是yarn结构图。ResourceManager是全局的，负责对于系统中的所有资源有最高的支配权。ApplicationMaster 每一个job有一个ApplicationMaster 。NodeManager，NodeManager是基本的计算框架。NodeManager 是客户端框架负责 containers, 监控他们的资源使用 (cpu, 内存, 磁盘, 网络) 和上报给 ResourceManager/Scheduler.ApplicationMaster首先它是一个框架库，它的功能官网说的不够系统，大意，由于NodeManager 执行和监控任务需要资源，所以通过ApplicationMaster与ResourceManager沟通，获取资源。换句话说，ApplicationMaster起着中间人的作用。转换为更专业的术语：AM负责向ResourceManager索要NodeManager执行任务所需要的资源容器，更具体来讲是ApplicationMaster负责从Scheduler申请资源，以及跟踪这些资源的使用情况以及任务进度的监控。 ResourceManager有两个组件：调度器和应用程序管理器。调度器（Scheduler）是可插拔的，比如有Fair Scheduler、Capacity Scheduler等，当然调度器也可以自定义。更多相关内容：Hadoop YARN配置参数剖析(4)—Fair Scheduler、Capacity Scheduler相关参数http://www.aboutyun.com/forum.php?mod=viewthread&amp;tid=5864 应用程序管理器负责接收提交的任务，指定ApplicationMaster申请资源（container） ，协调并提供在ApplicationMaster容器失败时的重启功能。 而下图也是官网提供内容，大家可以参考下。 总结 为了更好的理解，我们就需要跟hadoop1.x比较：为何要使用yarn。我们看到JobTracker的功能被分散到各个进程中包括ResourceManager和NodeManager：比如监控功能，分给了NodeManager，和Application Master。ResourceManager里面又分为了两个组件：调度器及应用程序管理器。也就是说Yarn重构后，JobTracker的功能，被分散到了各个进程中。同时由于这些进程可以被单独部署所以这样就大大减轻了单点故障，及压力。 同时我们还看到Yarn使用了Container，而hadoop1.x中使用了slot。slot存在的缺点比如只能map或则reduce用。Container则不存在这个问题。这也是Yarn的进步。 转载 http://","categories":[{"name":"数据存储-bigdata","slug":"数据存储-bigdata","permalink":"https://langgithub.github.io/categories/数据存储-bigdata/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://langgithub.github.io/tags/hadoop/"}]},{"title":"HADOOP——HDFS","slug":"HADOOP——HDFS","date":"2020-06-09T09:29:21.370Z","updated":"2020-06-09T09:29:21.370Z","comments":true,"path":"2020/06/09/HADOOP——HDFS/","link":"","permalink":"https://langgithub.github.io/2020/06/09/HADOOP——HDFS/","excerpt":"","text":"Namenode主要维护两个文件，一个是fsimage，一个是editlog。 ### ###fsimage保存了最新的元数据检查点，包含了整个HDFS文件系统的所有目录和文件的信息。对于文件来说包括了数据块描述信息、修改时间、访问时间等；对于目录来说包括修改时间、访问权限控制信息(目录所属用户，所在组)等。 editlog主要是在NameNode已经启动情况下对HDFS进行的各种更新操作进行记录，HDFS客户端执行所有的写操作都会被记录到editlog中。 简单来想，NameNode维护了文件与数据块的映射表以及数据块与数据节点的映射表，什么意思呢？就是一个文件，它切分成了几个数据块，以及这些数据块分别存储在哪些datanode上，namenode一清二楚。Fsimage就是在某一时刻，整个hdfs 的快照，就是这个时刻hdfs上所有的文件块和目录，分别的状态，位于哪些个datanode，各自的权限，各自的副本个数。然后客户端对hdfs所有的更新操作，比如说移动数据，或者删除数据，都会记录在editlog中。 为了避免editlog不断增大，secondary namenode会周期性合并fsimage和edits成新的fsimage，新的操作记录会写入新的editlog中，这个周期可以自己设置（editlog到达一定大小或者定时）。 可以很清晰看出，第一步：将hdfs更新记录写入一个新的文件——edits.new。 第二步：将fsimage和editlog通过http协议发送至secondary namenode。 第三步：将fsimage与editlog合并，生成一个新的文件——fsimage.ckpt。这步之所以要在secondary namenode中进行，是因为比较耗时，如果在namenode中进行，或导致整个系统卡顿。 第四步：将生成的fsimage.ckpt通过http协议发送至namenode。 第五步：重命名fsimage.ckpt为fsimage，edits.new为edits。 这样的话，fsimage与editlog合并的过程就完成了。所以如果namenode宕机，其实secondary namenode还保存这一份不久前的fsimage，还能挽回一些损失吧。 另外上篇中说，一旦有datanode挂掉了（宕机或者是网络阻塞），namenode能很快感知到，并且将宕机的节点上的数据块转移至其余空闲节点。这点是因为hdfs中心跳机制（heartbeat）。 心跳机制默认3s中一次，datanode会向namenode发送一次一跳，告知namenode当前节点上存放的数据文件是什么。如果namenode中记录的是该datanode存放了文件A的两个数据块和文件B的一个数据块，但是心跳中只有文件A的一个数据块信息，namenode就会知道该datanode数据块损坏了，会把损坏的数据块在别的datanode上补充。 转载：http://","categories":[{"name":"数据存储-bigdata","slug":"数据存储-bigdata","permalink":"https://langgithub.github.io/categories/数据存储-bigdata/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://langgithub.github.io/tags/hadoop/"}]},{"title":"HADOOP——HA","slug":"HADOOP——HA","date":"2020-06-09T09:29:21.369Z","updated":"2020-06-09T09:29:21.370Z","comments":true,"path":"2020/06/09/HADOOP——HA/","link":"","permalink":"https://langgithub.github.io/2020/06/09/HADOOP——HA/","excerpt":"","text":"一概述 （一）HDFS 1）基础架构 （1）NameNode（Master） 命名空间管理：命名空间支持对HDFS中的目录、文件和块做类似文件系统的创建、修改、删除、列表文件和目录等基本操作。 块存储管理 （2）DataNode（Slaver） namenode和client的指令进行存储或者检索block，并且周期性的向namenode节点报告它存了哪些文件的block 2）HA架构 使用Active NameNode，Standby NameNode 两个结点解决单点问题，两个结点通过JounalNode共享状态，通过ZKFC 选举Active ，监控状态，自动备援。 （1）Active NameNode： 接受client的RPC请求并处理，同时写自己的Editlog和共享存储上的Editlog，接收DataNode的Block report, block location updates和heartbeat； （2）Standby NameNode： 同样会接到来自DataNode的Block report, block location updates和heartbeat，同时会从共享存储的Editlog上读取并执行这些log操作，使得自己的NameNode中的元数据（Namespcae information + Block locations map）都是和Active NameNode中的元数据是同步的。所以说Standby模式的NameNode是一个热备（Hot Standby NameNode），一旦切换成Active模式，马上就可以提供NameNode服务 （3）JounalNode： 用于Active NameNode ， Standby NameNode 同步数据，本身由一组JounnalNode结点组成，该组结点基数个，支持Paxos协议，保证高可用，是CDH5唯一支持的共享方式（相对于CDH4 促在NFS共享方式） （4）ZKFC： 监控NameNode进程，自动备援。 （二）YARN 1）基础架构 （1）ResourceManager(RM) 接收客户端任务请求，接收和监控NodeManager(NM)的资源情况汇报，负责资源的分配与调度，启动和监控ApplicationMaster(AM)。 （2）NodeManager 节点上的资源管理，启动Container运行task计算，上报资源、container情况给RM和任务处理情况给AM。 （3）ApplicationMaster 单个Application(Job)的task管理和调度，向RM进行资源的申请，向NM发出launch Container指令，接收NM的task处理状态信息。NodeManager （4）Web Application Proxy 用于防止Yarn遭受Web攻击，本身是ResourceManager的一部分，可通过配置独立进程。ResourceManager Web的访问基于守信用户，当Application Master运行于一个非受信用户，其提供给ResourceManager的可能是非受信连接，Web Application Proxy可以阻止这种连接提供给RM。 （5）Job History Server NodeManager在启动的时候会初始化LogAggregationService服务, 该服务会在把本机执行的container log (在container结束的时候)收集并存放到hdfs指定的目录下. ApplicationMaster会把jobhistory信息写到hdfs的jobhistory临时目录下, 并在结束的时候把jobhisoty移动到最终目录, 这样就同时支持了job的recovery.History会启动web和RPC服务, 用户可以通过网页或RPC方式获取作业的信息 2）HA架构 ResourceManager HA 由一对Active，Standby结点构成，通过RMStateStore存储内部数据和主要应用的数据及标记。目前支持的可替代的RMStateStore实现有：基于内存的MemoryRMStateStore，基于文件系统的FileSystemRMStateStore，及基于zookeeper的ZKRMStateStore。 ResourceManager HA的架构模式同NameNode HA的架构模式基本一致，数据共享由RMStateStore，而ZKFC成为 ResourceManager进程的一个服务，非独立存在。 转载：http://shihlei.iteye.com/blog/2084711","categories":[{"name":"数据存储-bigdata","slug":"数据存储-bigdata","permalink":"https://langgithub.github.io/categories/数据存储-bigdata/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://langgithub.github.io/tags/hadoop/"}]},{"title":"ELF文件静态感染注入","slug":"ELF文件静态感染注入","date":"2020-06-09T09:29:21.369Z","updated":"2020-06-09T09:29:21.369Z","comments":true,"path":"2020/06/09/ELF文件静态感染注入/","link":"","permalink":"https://langgithub.github.io/2020/06/09/ELF文件静态感染注入/","excerpt":"","text":"ELF文件静态感染注入http://www.520monkey.com/archives/561 要修改的位置 ELF Header Start of program headers Number of program headers Program Headers PT_LOAD: 描述程序加载时内存存储信息动态节区 .dynamic(PT_DYNAMIC),包含了程序动态链接和依赖库信息（libhello.so） typedef struct{ ELF32_Sword d_tag; union{ ELF32_Word d_val; ELF32_Addr d_ptr; }} d_tag类型：dt_null,dt_needed,dt_strtab,dt_strsz 感染ELF文件注入实现：1. 在dt_strtab指向的字符串中添加自定义so模块名称，将字符串表移动到文件末尾 2. 添加一个pt_load表，用于能够内存映射我们添加的字符串，phdr移动到文件末尾 3. 修改dt_strtab,dt_strsz,添加dt_needed 4. 修改ELF Header关于段头表的信息字段，偏移，大小","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"ptrace","slug":"ptrace","permalink":"https://langgithub.github.io/tags/ptrace/"}]},{"title":"CDH安装","slug":"CDH安装","date":"2020-06-09T09:29:21.368Z","updated":"2020-06-09T09:29:21.369Z","comments":true,"path":"2020/06/09/CDH安装/","link":"","permalink":"https://langgithub.github.io/2020/06/09/CDH安装/","excerpt":"","text":"系统环境准备 1、网络配置 vi /etc/sysconfig/network vi /etc/hosts 2、SSH免密钥登录 虚拟机的环境准备非常重要：免密钥的master需要和slave免密钥；那么cloudera manager的server需要和agent免密钥； 那么具体的软件比如hdfs的namenode所在的节点就需要和它的datanode节点免密钥； 全部会话 ：ssh-keygen -t rsa -P ‘’ -f ~/.ssh/id_rsa ssh-copy-id node11/node12/node13 3、防火墙关闭 Service iptables stop Chkconfig iptables off 4、SELINUX关闭 setenforce 0 vi /etc/selinux/config (SELINUX=disabled) 5.安装JDK配置环境变量 三台机器都需要 将jdk上传到node11的/home/tools目录下 Node11执行：scp jdk+Tab node12:pwd scp jdk+Tab node13:pwd 全部会话：rpm -ivh jdk* 修改 vi/etc/profile 添加环境变量（一个一个添加） source ./etc/profile export JAVA_HOME=/usr/java/default //注意java的路径 export PATH=JAVAHOME/bin:JAVAHOME/bin:PATH 6.安装NTP Yum install ntp -y 设置开机启动 chkconfig ntpd on 设置时间同步 – ntpdate -u s2c.time.edu.cn（全部会话） 7.安装配置mysql yum install mysql-server -y 设置开机启动：chkconfig mysqld on 启动mysql： service mysqld start 查看状态： service mysqld status mysql 进入 use mysql select host,user from user 修改 mysql 权限： GRANT ALL PRIVILEGES ON . TO ‘root‘@’%’ IDENTIFIED BY ‘123’ WITH GRANT OPTION; 刷新：flush privileges; 删除多余会对权限造成影响的数据：delete from user where host !=’%’; 刷新权限 select host,user from user; quit 退出 重新登录：mysql -u root -p 密码：123 8.下载第三方依赖包 最后一步安装第三方依赖包的时候，主要针对的是centos，公司中还是要看使用的linux发行版缺少那些版本； yum install chkconfig python bind-utils psmisc libxslt zlib sqlite cyrus-sasl-plain cyrus-sasl-gssapi fuse fuse-libs redhat-lsb -y CM安装 安装Cloudera Manager Server、Agent 上传到/home/toolsx下 (三台机器都要安装) mkdir /opt/cloudera-manager tar xvzf cloudera-manager*.tar.gz -C /opt/cloudera-manager 创建用户cloudera-scm 全部会话：useradd –system –no-create-home –shell=/bin/false –comment “Cloudera SCM User” cloudera-scm 配置CM Agent cm的安装包的server和agent都是同一个包，启动的时候启动命令指定为server还是agent；cm有一个工作目录，需要 我们来创建；创建一个用户；修改agent的配置，给它指定server的位置；那个端口7182是server和agent通信的端口； server_host配置为server的名字； 修改文件/opt/cloudera-manager/cm-5.4.3/etc/cloudera-scm-agent/config.ini中 server_host(三台机器) 配置CM Server数据库 拷贝mysql jar文件到目录 /usr/share/java/ 注意jar包名称要修改为mysql-connector-java.jar mysql -u root -p use mysql; grant all on . to ‘temp‘@’%’ identified by ‘temp’ with grant option; cd /opt/cloudera-manager/cm-5.4.3/share/cmf/schema/ ./scm_prepare_database.sh mysql temp -h CDH1 -utemp -ptemp –scm-host CDH1 scm scm scm 格式：数据库类型、数据库、数据库服务器、用户名、密码、cm server服务器 创建Parcel目录 创建parcel目录，这些目录是server和agent用来接收和发送数据的目录，server端的parcel-repo这个目录会把所有 的安装文件全部下载到此目录，而agent也需要安装包，parcels就是用来存储指定的安装包的，当然需要有权限能操作 这些目录； Server节点 – mkdir -p /opt/cloudera/parcel-repo – chown cloudera-scm:cloudera-scm /opt/cloudera/parcel-repo Agent节点 – mkdir -p /opt/cloudera/parcels – chown cloudera-scm:cloudera-scm /opt/cloudera/parcels 制作CDH本地源 下载好文件CDH-5.4.0-1.cdh5.4.0.p0.27-el6.parcel以及manifest.json，将这两个文件放到server节点的 /opt/cloudera/parcel-repo下。 实际上这个三个文件 打开manifest.json文件，里面是json格式的配置，找到与下载版本相对应的hash码，新建文件，文件名与你的 parel包名一致，并加上.sha后缀，将hash码复制到文件中保存。 关机做快照。 init 0 || power off 启动CM Server、Agent 我们的系统需要预留内存；保证自己的系统能够跑起来，关闭所有的安全卫士；保证第一台节点的内存很多，以后可以 在cdh1有很多东西；虚拟机默认都采用单核单线，如果cpu可以，采用双核双线；老师使用的是16g内存，虚拟机在固态 硬盘上面，启动cloudera manager都需要几分钟，如果机器不好，可能需要启动一节课；如果实在不行，就需要单台转载 所有节点的功能； 当我们使用server start 会立马返回一个ok，这个只是表明该命令提交成功而已；毕竟server会在linux和mysql中创建 目录和数据库表，所以第一次启动的时候如果时间很长，千万不要关闭；不然下一次启动的话，依旧会创建这些目录 然后就会冲突；启动成功与否，可以通过一个日志文件来查看；当看到以下命令的时候，说明启动完成： 先确保启动了mysql service mysqld start 全部会话：cd /opt/cloudera-manager/cm-5.4.3/etc/init.d/ CDH1:执行./cloudera-scm-server start CDH1,2,3执行：./cloudera-scm-agent start 观察启动server的日志 cd /opt/cloudera-manager/cm-5.4.3/log/cloudera-scm-server tail -f 上面目录下的log的文件 出现如下内容表明启动成功 2017-02-22 19:57:04,638 INFO WebServerImpl:org.mortbay.log: Started SelectChannelConnector@0.0.0.0:7180 2017-02-22 19:57:04,638 INFO WebServerImpl:com.cloudera.server.cmf.WebServerImpl: Started Jetty server. 进入web浏览器进行访问，端口号：7180 至此。CM安装成功。 9.关闭CDH 先关闭浏览器页面的服务。 上下两个一次关闭。 再关闭虚拟机命令行的服务。 搭建CDH集群 通过CM把CDH集群部署起来，部署的方式有四种：cm,yum,rpm,tarball,其中我们采用的是离线cdh 下面所有的操作都是在web界面上操作的；9个步骤， 如果不小心点击了外网的版本，那么就会从外网下载，这个时候点击返回，依旧会下载，那么唯一的解决办法 就是停掉server,进去之后会出现已下载，也就是我们早就下载好到了parcels-repo，当然会是100%；然后第二 个步骤是分配，就是把parcels-repo里面的软件分发到agent的parcel目录去； cloudera建议我们的/proc/sys/vm/swappiness交换内存为0，将这个文件设置为0即可；当然这样修改只是本次开机 下次开机依旧不会改成这样；可以改另一个文件； 我们后面看到的图表，监控都是来自于CM service;从最开始那个ppt图上面可以看到 在使用cm配置cdh的时候，默认是没有给我们做高可用，虽然我们使用的是cm版本五，使用的hadoop是2.x,但是 还是会有snn，只有在做了高可用之后snn才会消失；当我们只在cm上面安装hadoop的时候，有一个步骤，数据库检测 ，由于安装hadoop不需要数据库，所以会一闪而过； 以下利用CM搭建CDH Jar包存放位置： /opt/cloudera/parcels/CDH-5.4.0-1.cdh5.4.0.p0.27 查看任务管理器–观察内存使用状况 注：添加新主机需重在新主机上装agent，步骤与上述步骤一样","categories":[{"name":"数据存储-bigdata","slug":"数据存储-bigdata","permalink":"https://langgithub.github.io/categories/数据存储-bigdata/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://langgithub.github.io/tags/hadoop/"}]},{"title":"","slug":"Android脱壳系列-腾讯加固分析","date":"2020-06-09T09:29:21.367Z","updated":"2020-06-09T09:29:21.367Z","comments":true,"path":"2020/06/09/Android脱壳系列-腾讯加固分析/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android脱壳系列-腾讯加固分析/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android自曝签名剖析","slug":"Android自曝签名剖析","date":"2020-06-09T09:29:21.367Z","updated":"2020-06-09T09:29:21.367Z","comments":true,"path":"2020/06/09/Android自曝签名剖析/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android自曝签名剖析/","excerpt":"","text":"注:本次解读是对尼古拉斯赵四项目中自曝签名解读12345678910111213141516171819202122232425262728293031/** *content: Activity *signed:签名信息 */public static void hookPMS(Context context, String signed)&#123; try&#123; Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;); Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;); Object currentActivityThread = currentActivityThreadMethod.invoke(null); Field sPackageManagerField = activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;); sPackageManagerField.setAccessible(true); Object sPackageManager = sPackageManagerField.get(currentActivityThread); Class&lt;?&gt; iPackageManagerInterface = Class.forName(&quot;android.content.pm.IPackageManager&quot;); // 代码编号1 Object proxy = Proxy.newProxyInstance( iPackageManagerInterface.getClassLoader(), new Class&lt;?&gt;[] &#123; iPackageManagerInterface &#125;, new PmsHookBinderInvocationHandler(sPackageManager, signed)); //代码编号2 sPackageManagerField.set(currentActivityThread, proxy); PackageManager pm = context.getPackageManager(); Log.i(&quot;jw&quot;, &quot;pm:&quot;+pm); Field mPmField = pm.getClass().getDeclaredField(&quot;mPM&quot;); mPmField.setAccessible(true); mPmField.set(pm, proxy); &#125;catch (Exception e)&#123; Log.d(&quot;jw&quot;, &quot;hook pms error:&quot;+Log.getStackTraceString(e)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.pm.Signature;import android.util.Log;/** * 动态代理 */public class PmsHookBinderInvocationHandler implements InvocationHandler&#123; private Object base; private String SIGN; public PmsHookBinderInvocationHandler(Object base, String sign) &#123; try &#123; this.base = base; this.SIGN = sign; &#125; catch (Exception e) &#123; Log.d(&quot;jw&quot;, &quot;error:&quot;+Log.getStackTraceString(e)); &#125; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try&#123; if(&quot;getPackageInfo&quot;.equals(method.getName()))&#123; String pkgName = (String)args[0]; Integer flag = (Integer)args[1]; if(flag == PackageManager.GET_SIGNATURES &amp;&amp; &quot;lang.com.douyin&quot;.equals(pkgName))&#123; Signature sign = new Signature(SIGN); PackageInfo info = (PackageInfo) method.invoke(base, args); info.signatures[0] = sign; return info; &#125; &#125; &#125;catch(Exception e)&#123; &#125; return method.invoke(base, args); &#125;&#125; 代码编号1-理解动态代理 核心原理：在内存中生存继承PmsHookBinderInvocationHandler代理类，实现iPackageManagerInterface接口的类 代码编号2-替换pm 替换系统中的PackageManager 里面设计到的ActivityThread，IPackageManager等貌似不能Android代码中导入，还需要进一步调试Android源码，查明原因","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"Android签名","slug":"Android签名","permalink":"https://langgithub.github.io/tags/Android签名/"}]},{"title":"Android脱壳系列-阿里加固分析","slug":"Android脱壳系列-阿里加固分析","date":"2020-06-09T09:29:21.367Z","updated":"2020-06-09T09:29:21.367Z","comments":true,"path":"2020/06/09/Android脱壳系列-阿里加固分析/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android脱壳系列-阿里加固分析/","excerpt":"","text":"。。。","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"脱壳","slug":"脱壳","permalink":"https://langgithub.github.io/tags/脱壳/"}]},{"title":"Android脱壳系列-背景","slug":"Android脱壳系列-背景","date":"2020-06-09T09:29:21.367Z","updated":"2020-06-09T09:29:21.367Z","comments":true,"path":"2020/06/09/Android脱壳系列-背景/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android脱壳系列-背景/","excerpt":"","text":"背景 app存在的危险 代码修改（广告植入，替换广告id） 资源修改（界面替换广告，链接替换） 破解（应用收费，内购） 篡改数据（无效金币，砖石） 加入恶意代码（木马，隐私，交易） 动态注入，数据拦截，窃取，修改 协议修改 加固目的 需要防止逆向分析（防逆向）–防止核心代码被反编译 控制二次打包（防篡改）– 校验完整性，签名，防止盗版 防止调试和注入（防调试）–防止动态调试，注入获取关键数据 防止应用数据窃取（防窃取）– 加密敏感数据 防止协议直接被盗刷–加密协议通信 常用加固方式 类加载技术 针对apk中的classes.dex文件进行处理，放入特定的文件中，通过native代码来运行进行解密（爱加密，梆梆） 方法替换技术 将class.dex文件中的方法代码进行提取，抽取方法，在运行时对器进行动态解密还原 脱壳手法 修改系统源码自动脱壳 通过hook对关键函数进行脱壳 开源工具zjdroid,dexhunter进行脱壳 利用IDA或者GDB动态调试进行脱壳 壳进化 第一代壳 dex 加密 dex字符串加密 资源加密 对抗反调试 反调试 自定义dexClassLoader 第二代壳 dex抽取和so加固 dex代码抽取到外部 dex动态加载 so加密 第三代壳 dex动态解密和So混淆 dex代码动态解密 so代码混淆 脱壳思路第一代壳1. 内存dump，内存中寻址dex.035 或dex.036 2. 文件监视法 dex优化生成odex 监视文件变化（notifywait-for-Android） 监视dexOpt输出（notifywait-for-Android） 3. hook法 hook dvmDexFileOpenPartial 4. 定制安卓系统 第二代壳1. hook dexFileParse dexFileOpenFromMD 2. 定制系统 dexHunter defineClassNative 绕过3进程反调试一系列系统源码 断点mmap, dexopt优化时，dvmContinueOptimization()-&gt;mmap() 第三代壳 方法指令抽取dex2oat ART模式下，dex2oat生成oat时，内存中的dex是完整的定制系统 hook Dalvik_dalvik_system_DexFile_defineClassNative dexHunter 枚举所有DexClassDef，对所有class,调用dvmDefineClass进行强制加载 第四代壳so+vmp动态调试+人肉还原 总结爱加密 脱壳点 dvmDexFileOpenPartial 壳特点(“libsecexe.so”, “梆梆加固免费版”);(“libsecmain.so”, “梆梆加固免费版”);(“libSecShell.so”, “梆梆加固免费版”);(“secData0.jar”, “梆梆加固免费版”);(“libSecShell-x86.so”, “梆梆加固免费版”); (“libDexHelper.so”, “梆梆企业版”);(“libDexHelper-x86.so”, “梆梆企业版”);(“classes.jar”, “梆梆加固定制版”);(“DexHelper.so”, “梆梆加固定制版”); (“libtup.so”, “腾讯加固”);(“libshell.so”, “腾讯加固”);(“mix.dex”, “腾讯加固”);(“mixz.dex”, “腾讯加固”);(“libshella-xxxx.so”, “腾讯加固”);(“libshellx-xxxx.so”, “腾讯加固”); (“libtosprotection.armeabi-v7a.so”, “腾讯御安全”);(“libtosprotection.armeabi.so”, “腾讯御安全”);(“libtosprotection.x86.so”, “腾讯御安全”);(“tosversion”, “腾讯御安全”);(“libTmsdk-xxx-mfr.so”, “腾讯御安全”); (“aliprotect.dat”, “阿里加固”);(“libsgmain.so”, “阿里加固”);(“libsgsecuritybody.so”, “阿里加固”);(“libmobisec.so”, “阿里加固”);(“libfakejni.so”, “阿里加固”);(“libzuma.so”, “阿里加固”);(“libzumadata.so”, “阿里加固”);(“libpreverify1.so”, “阿里加固”); (“kdpdata.so”, “几维加固”);(“dex.dat”, “几维加固”);(“libkdp.so”, “几维加固”);(“libkwscmm.so”, “几维加固”);(“libkwscr.so”, “几维加固”);(“libkwslinker.so”, “几维加固”); (“libexec.so”, “爱加密”);(“libexecmain.so”, “爱加密”);(“ijiami.dat”, “爱加密”);(“ijiami.ajm”, “爱加密”);(“af.bin”, “爱加密”);(“signed.bin”, “爱加密”); (“libchaosvmp.so”, “娜迦”);(“libddog.so”, “娜迦”);(“libfdog.so”, “娜迦”);(“libedog.so”, “娜迦”); (“libprotectClass.so”, “360加固”);(“libjiagu.so”, “360加固”);(“libjiagu_art.so”, “360加固”);(“libjiagu_x86.so”, “360加固”); (“libcmvmp.so”, “中国移动安全加固”);(“libmogosec_dex.so”, “中国移动安全加固”);(“libmogosec_sodecrypt.so”, “中国移动安全加固”);(“libmogosecurity.so”, “中国移动安全加固”); (“libbaiduprotect.so”, “百度加固”);(“baiduprotect1.jar”, “百度加固”);(“baiduprotect.jar”, “百度加固”); (“libuusafe.jar.so”, “UU安全加固”);(“libuusafe.so”, “UU安全加固”);(“libuusafeempty.so”, “UU安全加固”); (“dp.arm-v7.so.dat”, “DexProtect加固”);(“dp.arm.so.dat”, “DexProtect加固”); (“libegis.so”, “通付盾加固”);(“libNSaferOnly.so”, “通付盾加固”); (“libreincp.so”, “珊瑚灵御加固”);(“libreincp_x86.so”, “珊瑚灵御加固”); (“libnqshield.so”, “网秦加固”); (“libnesec.so”, “网易易盾”); (“libAPKProtect.so”, “APKProtect加固”); (“libx3g.so”, “顶象技术加固”); (“libitsec.so”, “海云安加固”); (“libapssec.so”, “盛大加固”); (“librsprotect.so”, “瑞星加固”); (“libapktoolplus_jiagu.so”, “apktoolplus加固”);","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"脱壳","slug":"脱壳","permalink":"https://langgithub.github.io/tags/脱壳/"}]},{"title":"Android脱壳系列-百度加固分析","slug":"Android脱壳系列-百度加固分析","date":"2020-06-09T09:29:21.367Z","updated":"2020-06-09T09:29:21.367Z","comments":true,"path":"2020/06/09/Android脱壳系列-百度加固分析/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android脱壳系列-百度加固分析/","excerpt":"","text":"。。。","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"脱壳","slug":"脱壳","permalink":"https://langgithub.github.io/tags/脱壳/"}]},{"title":"Android脱壳系列-爱加密加固分析","slug":"Android脱壳系列-爱加密分析","date":"2020-06-09T09:29:21.366Z","updated":"2020-06-09T09:29:21.367Z","comments":true,"path":"2020/06/09/Android脱壳系列-爱加密分析/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android脱壳系列-爱加密分析/","excerpt":"","text":"给fopen fgets下段过反调试 在dvmDexFileOpenPartial dump 流程 https://www.52pojie.cn/thread-505999-1-1.html","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"脱壳","slug":"脱壳","permalink":"https://langgithub.github.io/tags/脱壳/"}]},{"title":"Android脱壳系列-加固技术总结","slug":"Android脱壳系列-加固技术总结","date":"2020-06-09T09:29:21.366Z","updated":"2020-06-09T09:29:21.366Z","comments":true,"path":"2020/06/09/Android脱壳系列-加固技术总结/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android脱壳系列-加固技术总结/","excerpt":"","text":"","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"脱壳","slug":"脱壳","permalink":"https://langgithub.github.io/tags/脱壳/"}]},{"title":"Android脱壳系列-360加固分析","slug":"Android脱壳系列-360加固分析","date":"2020-06-09T09:29:21.366Z","updated":"2020-06-09T09:29:21.366Z","comments":true,"path":"2020/06/09/Android脱壳系列-360加固分析/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android脱壳系列-360加固分析/","excerpt":"","text":"二代壳 只有com.qihoo.util拖360第一代壳 mmap下段过反调试 https://blog.csdn.net/jiangwei0910410003/article/details/51769447 第三代壳 两个包StupApp拖360第一代壳 mmap下段过反调试 https://mp.weixin.qq.com/s/xSe2Zrv9Ev4qRaN99YmnRA","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"脱壳","slug":"脱壳","permalink":"https://langgithub.github.io/tags/脱壳/"}]},{"title":"Android类加载","slug":"Android类加载","date":"2020-06-09T09:29:21.366Z","updated":"2020-06-09T09:29:21.366Z","comments":true,"path":"2020/06/09/Android类加载/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android类加载/","excerpt":"","text":"android中的classloader BootClassLoader，Android系统启动时会使用BootClassLoader来预加载常用类，与Java中的Bootstrap ClassLoader不同的是，它并不是由C/C++代码实现，而是由Java实现的。BootClassLoader是ClassLoader的一个内部类。 PathClassLoader，全名是dalvik/system.PathClassLoader，可以加载已经安装的Apk，也就是/data/app/package 下的apk文件，也可以加载/vendor/lib, /system/lib下的nativeLibrary。 DexClassLoader，全名是dalvik/system.DexClassLoader，可以加载一个未安装的apk文件。 App系统类加载器是PathClassLoader，而BootClassLoader是其parent类加载器。 android中class类加载过程 BaseDexClassLoader DexPathList makeDexElements loadDexFile loadDex loadClassBinaryName defineClass android热修复问题因为存放dex是一个数组DexElements ，在加载class类对象是按顺序从dex中加载，所以将修复的dex放在数组前面可完成热修复问题","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android脱壳系列-梆梆加固分析","slug":"Android脱壳系列-梆梆加固分析","date":"2020-06-09T09:29:21.366Z","updated":"2020-06-09T09:29:21.366Z","comments":true,"path":"2020/06/09/Android脱壳系列-梆梆加固分析/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android脱壳系列-梆梆加固分析/","excerpt":"","text":"。。。","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"},{"name":"脱壳","slug":"脱壳","permalink":"https://langgithub.github.io/tags/脱壳/"}]},{"title":"Android源码(8)-Binder理解篇","slug":"Android源码(8)-Binder理解篇","date":"2020-06-09T09:29:21.365Z","updated":"2020-06-09T09:29:21.366Z","comments":true,"path":"2020/06/09/Android源码(8)-Binder理解篇/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android源码(8)-Binder理解篇/","excerpt":"","text":"这是关于Android Binder机制的一篇文章，Binder是Android里面非常重要的组成，也是最难理解的一块知识点，学习Binder最好的方法是深入源码阅读，因为Binder相关的知识错综复杂，一般初学者也很容易迷失在源码的汪洋里，本文旨在梳理Binder的架构和流程，并且试着以实用的角度来看待Binder。 一、为什么需要Binder机制？Android系统中，每个应用程序是由Android的Activity，Service，Broadcast，ContentProvider这四剑客的中一个或多个组合而成，这四剑客所涉及的多进程间的通信底层都是依赖于Binder IPC机制。例如当进程A中的Activity要向进程B中的Service通信，这便需要依赖于Binder IPC。如果熟悉Android源码，其实可以知道整个Android系统架构中，也大量采用了Binder机制作为IPC（进程间通信）方案。Android是在Linux内核的基础上设计的。而在Linux中，已经拥有”管道/消息队列/共享内存/信号量/Socket等等”众多的IPC通信手段；但是，Google为什么单单选择了Binder，可见Binder肯定有自己独特的优势： 1.1 Binder能很好的实现C/S架构Android系统，很大一部分都是居于Client-Server架构的设计。Client端有什么需求，直接发送给Server端去完成，Server处理完毕再将反馈内容发送给Client。Server端与Client端相对独立，稳定性较好。传统的CS架构只有Socket，但是Socket通信效率相对于其他IPC来说又太低效，而Binder正是基于C/S架构设计的。 1.2 Binder传输效率高Binder只需要进行一次拷贝，把Client端的用户空间的数据即copy_from_user()到内核空间，然后将内核空间的数据映射到Server端的用户空间。Binder性能上仅仅次于Linux 共享内存的方式，但是共享内存的方式，进程间同步又是一个难题。 1.3 Binder安全性极高Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限。Client-Server通信过程中，Binder内核会为每个Client进程分配了UID/PID来作为鉴别身份的标示，并且在Binder通信时会根据UID/PID进行有效性检测。而如果是传统的IPC只能由在数据包当中填入UID/PID，这个并不是一个可靠的方法。 知乎上有一位答主讲得很好，可以看看: 为什么 Android 要采用 Binder 作为 IPC 机制?(https://www.zhihu.com/question/39440766) 二、Binder原理 Binder采用Client-Server架构，包含Client,Server,ServiceManager,Binder驱动四个组件 应用程序都运行在用户控件，每个应用程序都有它自己独立的内存空间，若不同的应用程序之间涉及到通讯，需要通过内核进行中转，因为要用到内核的copy_from_user()和copy_to_user()等函数 Server进程要先注册Service 到ServiceManager,Client进程使用Server的Service前，需先向ServiceManager中获取相应的Service,然后使用Service 三、Binder驱动层 当用户空间调用open()方法，最终会调用binder驱动的binder_open()方法；mmap()/ioctl()方法也是同理，从用户态进入内核态，都依赖于系统调用过程。 3.1 binder_init注册misc设备，指定相应文件操作方法 3.2 binder_open创建binder_proc对象，并把当前进程等信息保存bind_proc对象，改对象管理IPC所需的各种信息并拥有其他结构体的根结构体，再把bind_proc对象保存到文件filp,以及把bind_proc加入到全局链表binder_procs 3.3 binder_mmap在内核虚拟地址空间，申请一块于用户虚拟内存相同大小的内存；然后再申请1个page大小的物理内存，再将同一块物理内存映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的buffer和内核空间的buffer同步操作的功能 3.4 binder_ioctl负责在两个进程间收发IPC数据和IPC reply数据，调用流程：123456789101112//step 1:binder_write_read bwr;ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) // step 2: binder_ioctl(filp, BINDER_WRITE_READ, &amp;bwr) // step 3: binder_ioctl_write_read(filp, BINDER_WRITE_READ, &amp;bwr, thread) // step 4: copy_from_user(&amp;bwr, ubuf, sizeof(bwr)) binder_thread_write(proc, thread, bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); copy_to_user(...) binder_thread_write(): 处理binder请求码，以“BC_”开头，建成后bc码，用于IPC层传递到Binder Driver层；binder_thread_read(): 生成Binder响应吗，以“BR_”开头，简称BR码，用于Binder Driver层传递到IPC层 四. Binder通信流程例如当名为BatteryStatsService的Client向ServiceManager注册服务的过程中，IPC层的数据组成为：Handle=0，RPC代码为ADD_SERVICE_TRANSACTION，RPC数据为BatteryStatsService，Binder协议为BC_TRANSACTION。整个流程图大致如下： handle为0正是指向ServiceManager。 五、启动ServiceManagerServiceManager启动时序图： 打开binder驱动，并调用mmap()方法分配128k内存映射空间: binder_open() 通知binder驱动使其成为守护进程: binder_become_context_manager() 验证selinux权限，判断进程是否有注册或查看指定服务 进入循环状态，等待client端的请求：binder_loop() 六、获取ServiceManager获取Service Manager是通过defaultServiceManager()方法来完成，当进程注册服务(addService)或 获取服务(getService)的过程之前，都需要先调用defaultServiceManager()方法来获取gDefaultServiceManager对象。 获取ProcessState对象，在其构造函数中调用open_driver函数打开binder驱动，并将句柄保存到mDriverFD; 调用gProcess-&gt;getContextObject函数来获得一个句柄值为0得binder引用，即BpBinder 通过interface_cast构造一个BpServiceManger对象，所以gDefaultServiceManager最终为new BpServicemanager(new BpBinder(0)) 七、addService以Native层的服务以media服务为例，注册MediaPlayerService的时序图如下： defaultServiceManager()返回的是BpServiceManager，会调用BpServiceManager.addService方法 addService()通过remote()中保存的BpBinder调用到IPCThreadState的transact方法； IPCThreadState::transact会调用writeTransactionData()传输数据传输数据，然后和驱动交互，驱动把请求转发给ServiceManager执行真正的注册服务； 得到驱动的返回后，调用BBinder，最终调用到BnMediaPlayerService的onTransact方法； 开启两个线程不断和Binder进行交互，获取Client请求。 获取服务的流程基本也是差不多的，不再累述。 八、Binder架构binder在framework层，采用JNI技术来调用native(C/C++)层的binder架构，从而为上层应用程序提供服务。 我们知道native层中，binder是C/S架构，分为Bn端(Server)和Bp端(Client)。对于java层在命名与架构上非常相近，同样实现了一套IPC通信架构。 BinderProxy类代表Client端，Binder类代表Server端 framework层的Binder逻辑是建立在Native层架构基础之上的，核心逻辑是交予Native层方法来处理 比如addService流程： java层通过getIServiceManager获得ServiceManagerProxy对象，通过该对象BinderProxy,最终会调用BpBinder对象，由BpBinder来完成通讯。 Binder驱动将Client端的请求转发给BBinder的transact方法，然后由其子类JavaBBinder调用。后者调用指定Service的方法，并返回给驱动 九、Binder类图9.1 Native Binder类图 9.2 Framework Binder类图 十、Binder其他介绍一些Binder其他比较重要的点，方便理清Binder的一些疑问。比如Binder实体和引用，比如ProcessState和IPCThreadState，比如数据结构怎么传递等。 10.1 Binder中各个角色的关系 1. Binder实体 : binder_nodeBinder实体，是各个Server以及ServiceManager在内核中的存在形式。Binder实体实际上是内核中 binder_node 结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。 2. Binder引用 : binder_ref所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。Binder实体和Binder引用都是内核(即Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。 3. 远程服务Server都是以服务的形式注册到ServiceManager中进行管理的。如果将Server本身看作是”本地服务”的话，那么Client中的”远程服务”就是本地服务的代理。如果你对代理模式比较熟悉的话，就很容易理解了，远程服务就是本地服务的一个代理，通过该远程服务Client就能和Server进行通信。 10.2 进程和线程的关系图解： Binder驱动通过binder_procs链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应。 每个进程有且只有一个ProcessState对象，这是通过单例模式来保证的。 每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是Binder_thread结构体。在binder_proc结构体中通过成员变量rb_root threads，来记录当前进程内所有的binder_thread。 Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。 10.3 Binder数据传输 用户空间的进程调用ioctl(fd,BINDER_WRITE_READ,&amp;bwr)时传递给Binder驱动的信息。fd是Binder驱动的文件句柄，BINDER_WRITE_READ是ioctl()的一个标识，而bwr是传递的数据，write_buffer是请求数据的内容，而write_consumed是用来记录请求数据中已经被Binder驱动处理过的数据的大小。 ioctl会走到binder_thread_write和binder_thread_read。这层的数据是”事务指令”+”binder_transaction_data结构体”组成的。data是保存事务中具体数据的内存地址。具体调用流程可以参考#3.4章节 这层是有效数据。如果该请求是传递给ServiceManager进行处理的，则有效数据是：消息头+”Server的相关信息”。消息头是用来进行有效性检查的，而”Server的相关信息”则是请求要处理的信息。 十一、源码目录从上之下, 整个Binder架构所涉及的总共有以下5个目录:12345/framework/base/core/java/ (Java)/framework/base/core/jni/ (JNI)/framework/native/libs/binder (Native)/framework/native/cmds/servicemanager/ (Native)/kernel/drivers/staging/android (Driver) 11.1 Java framework12345678910111213/framework/base/core/java/android/os/ - IInterface.java - IBinder.java - Parcel.java - IServiceManager.java - ServiceManager.java - ServiceManagerNative.java - Binder.java /framework/base/core/jni/ - android_os_Parcel.cpp - AndroidRuntime.cpp - android_util_Binder.cpp (核心类) 11.2 Native framework123456789101112/framework/native/libs/binder - IServiceManager.cpp - BpBinder.cpp - Binder.cpp - IPCThreadState.cpp (核心类) - ProcessState.cpp (核心类)/framework/native/include/binder/ - IServiceManager.h - IInterface.h/framework/native/cmds/servicemanager/ - service_manager.c - binder.c 11.3 Kernel123/kernel/drivers/staging/android/ - binder.c - uapi/binder.h","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android源码(7)-Android系统build阶段签名机制","slug":"Android源码(7)-Android系统build阶段签名机制","date":"2020-06-09T09:29:21.365Z","updated":"2020-06-09T09:29:21.365Z","comments":true,"path":"2020/06/09/Android源码(7)-Android系统build阶段签名机制/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android源码(7)-Android系统build阶段签名机制/","excerpt":"","text":"本文介绍Android系统build阶段的签名机制。 一、系统build阶段签名机制 系统中有4组key用于build阶段对apk进行签名： Media Platform Shared Testkey default key是放在Android源码的/build/target/product/security目录下: media.pk8与media.x509.pem； platform.pk8与platform.x509.pem； shared.pk8与shared.x509.pem； testkey.pk8与testkey.x509.pem；其中，.pk8文件为私钥，.x509.pem文件为公钥，这需要去了解非对称加密方式。 在apk的android.mk文件中会指定LOCAL_CERTIFICATE 变量： LOCAL_CERTIFICATE可设置的值如下：12345LOCAL_CERTIFICATE := testkey # 普通APK，默认情况下使用LOCAL_CERTIFICATE := platform # 该APK完成一些系统的核心功能,这种方式编译出来的APK所在进程的UID为systemLOCAL_CERTIFICATE := shared # 该APK是media/download系统中的一环LOCAL_CERTIFICATE := media # 该APK是media/download系统中的一环如果不指定，默认使用testkey。 对应的，除了在Android.mk指定上述的值，还需要在APK源码的AndroidManifest.xml文件的manifest节点里面申明权限：123android:sharedUserId=&quot;android.uid.system&quot;android:sharedUserId=&quot;android.uid.shared&quot;android:sharedUserId=&quot;android.media&quot; Build规则是Build/core/prebuilt.mk。 在build/core/config.mk中，DEFAULT_SYSTEM_DEV_CERTIFICATE可以通过PRODUCT_DEFAULT_DEV_CERTIFICATE去指定各家厂商的key path。 我们可以看到，默认为build/target/product/security/testkey。123456# The default key if not set as LOCAL_CERTIFICATEifdef PRODUCT_DEFAULT_DEV_CERTIFICATE DEFAULT_SYSTEM_DEV_CERTIFICATE := $(PRODUCT_DEFAULT_DEV_CERTIFICATE)else DEFAULT_SYSTEM_DEV_CERTIFICATE := build/target/product/security/testkeyendif 二、自定义系统签名的key上面介绍了系统有默认四组key，那么如果我们要制作自己的key，需要怎么做呢？在build/target/product/security/目录下有一个README，里面有说明怎么制作这些key并且使用。 进入Development/tools/ 目录 使用make_key工具生成签名文件：1sh make_key releasekey &apos;/C=CN/ST=Guangdong/L=Shenzhen/O=Mediatek/OU=MTK/CN=fzll/emailAddress=maoao530@foxmail.com&apos; 其中： C : Country Name (2 letter code)ST : State or Province Name (full name)L : Locality Name (eg, city)O : Organization Name (eg, company)OU : Organizational Unit Name (eg, section)CN : Common Name (eg, your name or your server’s hostname)emailAddress : Contact email address 用ls命令发现目录下多了两个文件：releasekey.x509.pem 和 releasekey.pk8 同样的步骤生成platform / shared / media 用自定义的key替换build/target/product/security/目录下面的key。 三、对APK进行系统签名为了使apk有system权限，通常我们需要对其进行系统签名： 1、在应用程序的AndroidManifest.xml中的manifest节点中加入1android:sharedUserId=&quot;android.uid.system&quot;这个属性。 2、修改它的Android.mk文件，加入12LOCAL_CERTIFICATE := platform重新编译，生成的apk就有修改system权限了,我们通过ps命令查看APK所在进程的UID，发现值为system。 三. Android签名机制之—签名过程详解 两种签名方式 jarsigner signapk 签名流程机制源码位置：com/android/signapk/sign.java通过上面的签名时我们可以看到，Android签名apk之后，会有一个META-INF文件夹，这里有三个文件：MANIFEST.MFCERT.RSACERT.SF下面来看看这三个文件到底是干啥的？ MANIFEST.MF开下源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194【main】public static void main(String[] args) &#123; if (args.length &lt; 4) usage(); sBouncyCastleProvider = new BouncyCastleProvider(); Security.addProvider(sBouncyCastleProvider); boolean signWholeFile = false; int argstart = 0; if (args[0].equals(&quot;-w&quot;)) &#123; signWholeFile = true; argstart = 1; &#125; if ((args.length - argstart) % 2 == 1) usage(); int numKeys = ((args.length - argstart) / 2) - 1; if (signWholeFile &amp;&amp; numKeys &gt; 1) &#123; System.err.println(&quot;Only one key may be used with -w.&quot;); System.exit(2); &#125; String inputFilename = args[args.length-2]; String outputFilename = args[args.length-1]; JarFile inputJar = null; FileOutputStream outputFile = null; int hashes = 0; try &#123; File firstPublicKeyFile = new File(args[argstart+0]); X509Certificate[] publicKey = new X509Certificate[numKeys]; try &#123; for (int i = 0; i &lt; numKeys; ++i) &#123; int argNum = argstart + i*2; publicKey[i] = readPublicKey(new File(args[argNum])); hashes |= getAlgorithm(publicKey[i]); &#125; &#125; catch (IllegalArgumentException e) &#123; System.err.println(e); System.exit(1); &#125; // Set the ZIP file timestamp to the starting valid time // of the 0th certificate plus one hour (to match what // we&apos;ve historically done). long timestamp = publicKey[0].getNotBefore().getTime() + 3600L * 1000; PrivateKey[] privateKey = new PrivateKey[numKeys]; for (int i = 0; i &lt; numKeys; ++i) &#123; int argNum = argstart + i*2 + 1; privateKey[i] = readPrivateKey(new File(args[argNum])); &#125; inputJar = new JarFile(new File(inputFilename), false); // Don&apos;t verify. outputFile = new FileOutputStream(outputFilename); if (signWholeFile) &#123; SignApk.signWholeFile(inputJar, firstPublicKeyFile, publicKey[0], privateKey[0], outputFile); &#125; else &#123; JarOutputStream outputJar = new JarOutputStream(outputFile); // For signing .apks, use the maximum compression to make // them as small as possible (since they live forever on // the system partition). For OTA packages, use the // default compression level, which is much much faster // and produces output that is only a tiny bit larger // (~0.1% on full OTA packages I tested). outputJar.setLevel(9); Manifest manifest = addDigestsToManifest(inputJar, hashes); copyFiles(manifest, inputJar, outputJar, timestamp); signFile(manifest, inputJar, publicKey, privateKey, outputJar); outputJar.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); System.exit(1); &#125; finally &#123; try &#123; if (inputJar != null) inputJar.close(); if (outputFile != null) outputFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); System.exit(1); &#125; &#125; &#125;【signWholeFile中调用 signFile】private static void signFile(Manifest manifest, JarFile inputJar, X509Certificate[] publicKey, PrivateKey[] privateKey, JarOutputStream outputJar) throws Exception &#123; // Assume the certificate is valid for at least an hour. long timestamp = publicKey[0].getNotBefore().getTime() + 3600L * 1000; // MANIFEST.MF JarEntry je = new JarEntry(JarFile.MANIFEST_NAME); je.setTime(timestamp); outputJar.putNextEntry(je); manifest.write(outputJar); int numKeys = publicKey.length; for (int k = 0; k &lt; numKeys; ++k) &#123; // CERT.SF / CERT#.SF je = new JarEntry(numKeys == 1 ? CERT_SF_NAME : (String.format(CERT_SF_MULTI_NAME, k))); je.setTime(timestamp); outputJar.putNextEntry(je); ByteArrayOutputStream baos = new ByteArrayOutputStream(); writeSignatureFile(manifest, baos, getAlgorithm(publicKey[k])); byte[] signedData = baos.toByteArray(); outputJar.write(signedData); // CERT.RSA / CERT#.RSA je = new JarEntry(numKeys == 1 ? CERT_RSA_NAME : (String.format(CERT_RSA_MULTI_NAME, k))); je.setTime(timestamp); outputJar.putNextEntry(je); writeSignatureBlock(new CMSProcessableByteArray(signedData), publicKey[k], privateKey[k], outputJar); &#125;&#125; 【main函数中 addDigestsToManifest】/** * Add the hash(es) of every file to the manifest, creating it if * necessary. */private static Manifest addDigestsToManifest(JarFile jar, int hashes) throws IOException, GeneralSecurityException &#123; Manifest input = jar.getManifest(); Manifest output = new Manifest(); Attributes main = output.getMainAttributes(); if (input != null) &#123; main.putAll(input.getMainAttributes()); &#125; else &#123; main.putValue(&quot;Manifest-Version&quot;, &quot;1.0&quot;); main.putValue(&quot;Created-By&quot;, &quot;1.0 (Android SignApk)&quot;); &#125; MessageDigest md_sha1 = null; MessageDigest md_sha256 = null; if ((hashes &amp; USE_SHA1) != 0) &#123; md_sha1 = MessageDigest.getInstance(&quot;SHA1&quot;); &#125; if ((hashes &amp; USE_SHA256) != 0) &#123; md_sha256 = MessageDigest.getInstance(&quot;SHA256&quot;); &#125; byte[] buffer = new byte[4096]; int num; // We sort the input entries by name, and add them to the // output manifest in sorted order. We expect that the output // map will be deterministic. TreeMap&lt;String, JarEntry&gt; byName = new TreeMap&lt;String, JarEntry&gt;(); for (Enumeration&lt;JarEntry&gt; e = jar.entries(); e.hasMoreElements(); ) &#123; JarEntry entry = e.nextElement(); byName.put(entry.getName(), entry); &#125; for (JarEntry entry: byName.values()) &#123; String name = entry.getName(); if (!entry.isDirectory() &amp;&amp; (stripPattern == null || !stripPattern.matcher(name).matches())) &#123; InputStream data = jar.getInputStream(entry); while ((num = data.read(buffer)) &gt; 0) &#123; if (md_sha1 != null) md_sha1.update(buffer, 0, num); if (md_sha256 != null) md_sha256.update(buffer, 0, num); &#125; Attributes attr = null; if (input != null) attr = input.getAttributes(name); attr = attr != null ? new Attributes(attr) : new Attributes(); if (md_sha1 != null) &#123; attr.putValue(&quot;SHA1-Digest&quot;, new String(Base64.encode(md_sha1.digest()), &quot;ASCII&quot;)); &#125; if (md_sha256 != null) &#123; attr.putValue(&quot;SHA-256-Digest&quot;, new String(Base64.encode(md_sha256.digest()), &quot;ASCII&quot;)); &#125; output.getEntries().put(name, attr); &#125; &#125; return output;&#125; 总结：生成三个文件 MANIFEST.MF，CERT.SF，CERT.RSA // MANIFEST.MFJarEntry je = new JarEntry(JarFile.MANIFEST_NAME);je.setTime(timestamp);outputJar.putNextEntry(je);manifest.write(outputJar);除了三个文件(MANIFEST.MF,CERT.RSA,CERT.SF)，其他的文件都会对文件内容做一次SHA1算法，就是计算出文件的摘要信息,然后用Base64进行编码即可，保存到MANIFEST.MF // CERT.SF / CERT#.SFje = new JarEntry(numKeys == 1 ? CERT_SF_NAME : (String.format(CERT_SF_MULTI_NAME, k))); je.setTime(timestamp);outputJar.putNextEntry(je);ByteArrayOutputStream baos = new ByteArrayOutputStream();writeSignatureFile(manifest, baos, getAlgorithm(publicKey[k]));byte[] signedData = baos.toByteArray();outputJar.write(signedData);1》计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下2》逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest“ // CERT.RSA / CERT#.RSAje = new JarEntry(numKeys == 1 ? CERT_RSA_NAME :(String.format(CERT_RSA_MULTI_NAME, k)));je.setTime(timestamp);outputJar.putNextEntry(je);writeSignatureBlock(new CMSProcessableByteArray(signedData),publicKey[k], privateKey[k], outputJar);我们看到，这里会把之前生成的 CERT.SF文件， 用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。CERT.RSA是一个满足PKCS7格式的文件。 四. 画个图表示","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android源码(6)-Android消息机制","slug":"Android源码(6)-Android消息机制","date":"2020-06-09T09:29:21.365Z","updated":"2020-06-09T09:29:21.365Z","comments":true,"path":"2020/06/09/Android源码(6)-Android消息机制/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android源码(6)-Android消息机制/","excerpt":"","text":"本文介绍Android的消息机制。 一、引言假设现在我们有这样的需求，点一下图中的button，然后去获取一些数据（假设这个步骤是一个耗时的操作），然后获取完后将得到的数据返回显示到屏幕上。为了避免产生ANR(Application Not Response)问题，通常我们会在新的线程去做耗时的操作，然后在UI线程里面更新组件，所以Handler就是类似这样子一个机制。 那么我们会怎么去实现呢？可以参考如下：12345678910111213141516171819202122232425262728293031323334353637383940public class TestDriverActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv = (TextView)findViewById(R.id.tv); btn = (Button)findViewById(R.id.btn); // 接收并处理消息 mHandler = new Handler()&#123; @Override public void handleMessage(Message msg)&#123; if (message.what == 0x11)&#123; Toast.makeText(getApplicationContext(), &quot;mHandler handleMessage&quot; ); tv.setText(&quot;mHandler is receive message&quot;) &#125; &#125; &#125;; // 监听 btn.setOnClickListener(new View.onClickListener()&#123; @Override public void onClick(View v)&#123; MyThread t = new MyThread(mHandler); t.start(); &#125; &#125;); &#125;&#125;class MyThread extends Thread&#123; Handler handler; public MyThread(Handler handler) &#123; super(); this.handler = handler; &#125; @Override public void run()&#123; super.run(); mHandler.sendEmptyMessage(0x11); //发送消息 &#125;&#125; 这只是一种实现的方式，如果在子线程而不是ui线程去初始化handler，则需要初始化handler前调用Looper.prepare()，初始化结束后调用Looper.loop()。 二、相关概念学习Android的消息处理机制，有几个概念（类）必须了解： Message消息，理解为线程间通讯的数据单元。例如后台线程在处理数据完毕后需要更新UI，则可发送一条包含更新信息的Message给UI线程。 Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。 HandlerHandler是Message的主要处理者，负责将Message添加到消息队列以及对消息队列中的Message进行处理。 Looper循环器，扮演Message Queue和Handler之间桥梁的角色，循环取出Message Queue里面的Message，并交付给相应的Handler进行处理。Thread5.UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。三、LooperLooper被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程。使用Looper类创建Looper线程很简单： 123456789101112public class LooperThread extends Thread &#123; @Override public void run() &#123; // 将当前线程初始化为Looper线程 Looper.prepare(); // ...其他处理，如实例化handler // 开始循环处理消息队列 Looper.loop(); &#125;&#125; 3.1 Looper.prepare()当执行了Looper.prepare()后，当前线程就会升级为Looper线程： 一个Thread只能有一个Looper对象线程中有一个Looper对象，它的内部维护了一个消息队列MessageQueue3.2 Looper.loop()当调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MQ中取出队头的消息(也叫任务)执行。 那么，我们如何往MQ上添加消息呢？下面有请Handler 四、HandlerHandler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即往MQ上添加消息的时候执行sendMessage，并在loop到自己的时候处理消息执行handleMessage，整个过程是异步的。 Handler创建时会关联一个looper，默认关联当前线程的looper。 1234567891011121314151617public class LooperThread extends Thread &#123; private Handler handler1; private Handler handler2; @Override public void run() &#123; // 将当前线程初始化为Looper线程 Looper.prepare(); // 实例化两个handler handler1 = new Handler(); handler2 = new Handler(); // 开始循环处理消息队列 Looper.loop(); &#125;&#125; 加入Handler后结构图如下： 一个线程可以有多个Handler，但是只能有一个Looper。 4.1 Handler发送消息和处理消息大致流程： mHandler.sendMessage()发送消息到MQLooper.loop()将message不断从MQ从取出来交给handler处理mHandler.handleMessage()处理消息 五、回顾那么回到一开始我们举的例子，在非UI线程去做耗时的操作，然后完成后在UI线程更新UI信息。那么这种case下，我们的结构图是这样的： 至此，本文介绍的内容已经完成，本文内容大部分非原创，更多的是基于其他博客的和自己理解的总结，好记性不如烂笔头。如果需要了解源码的同学，可以继续深入阅读研究，包括Java层Looper，Handler，Message，MessageQueue的源码和Native层Looper，NativeMessageQueue的源码实现。","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android源码(5)-ActivityManagerService启动流程","slug":"Android源码(5)-ActivityManagerService启动流程","date":"2020-06-09T09:29:21.364Z","updated":"2020-06-09T09:29:21.365Z","comments":true,"path":"2020/06/09/Android源码(5)-ActivityManagerService启动流程/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android源码(5)-ActivityManagerService启动流程/","excerpt":"","text":"一.概述AMS为主线，讲述system_server进程中AMS服务的启动过程，以startBootstrapServices()方法为起点，紧跟着startCoreServices(), startOtherServices()共3个方法。 二.AMS启动过程2.1 startBootstrapServices1234567891011121314151617private void startBootstrapServices() &#123; ... //启动AMS服务【见小节2.2】 mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); //设置AMS的系统服务管理器 mActivityManagerService.setSystemServiceManager(mSystemServiceManager); //设置AMS的APP安装器 mActivityManagerService.setInstaller(installer); //初始化AMS相关的PMS mActivityManagerService.initPowerManagement(); ... //设置SystemServer【见小节2.3】 mActivityManagerService.setSystemProcess();&#125; 2.2 启动AMS服务SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) 功能主要： * 创建ActivityManagerService.Lifecycle对象； * 调用Lifecycle.onStart()方法。 2.1.1 AMS.Lifecycle123456789101112131415161718public static final class Lifecycle extends SystemService &#123; private final ActivityManagerService mService; public Lifecycle(Context context) &#123; super(context); //创建ActivityManagerService【见小节2.1.2】 mService = new ActivityManagerService(context); &#125; @Override public void onStart() &#123; mService.start(); //【见小节2.1.3】 &#125; public ActivityManagerService getService() &#123; return mService; &#125;&#125; 该过程：创建AMS内部类的Lifecycle，已经创建AMS对象，并调用AMS.start();2.1.2 AMS创建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public ActivityManagerService(Context systemContext) &#123; mContext = systemContext; mFactoryTest = FactoryTest.getMode();//默认为FACTORY_TEST_OFF mSystemThread = ActivityThread.currentActivityThread(); //创建名为&quot;ActivityManager&quot;的前台线程，并获取mHandler mHandlerThread = new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false); mHandlerThread.start(); mHandler = new MainHandler(mHandlerThread.getLooper()); //通过UiThread类，创建名为&quot;android.ui&quot;的线程 mUiHandler = new UiHandler(); //前台广播接收器，在运行超过10s将放弃执行 mFgBroadcastQueue = new BroadcastQueue(this, mHandler, &quot;foreground&quot;, BROADCAST_FG_TIMEOUT, false); //后台广播接收器，在运行超过60s将放弃执行 mBgBroadcastQueue = new BroadcastQueue(this, mHandler, &quot;background&quot;, BROADCAST_BG_TIMEOUT, true); mBroadcastQueues[0] = mFgBroadcastQueue; mBroadcastQueues[1] = mBgBroadcastQueue; //创建ActiveServices，其中非低内存手机mMaxStartingBackground为8 mServices = new ActiveServices(this); mProviderMap = new ProviderMap(this); //创建目录/data/system File dataDir = Environment.getDataDirectory(); File systemDir = new File(dataDir, &quot;system&quot;); systemDir.mkdirs(); //创建服务BatteryStatsService mBatteryStatsService = new BatteryStatsService(systemDir, mHandler); mBatteryStatsService.getActiveStatistics().readLocked(); ... //创建进程统计服务，信息保存在目录/data/system/procstats， mProcessStats = new ProcessStatsService(this, new File(systemDir, &quot;procstats&quot;)); mAppOpsService = new AppOpsService(new File(systemDir, &quot;appops.xml&quot;), mHandler); mGrantFile = new AtomicFile(new File(systemDir, &quot;urigrants.xml&quot;)); // User 0是第一个，也是唯一的一个开机过程中运行的用户 mStartedUsers.put(UserHandle.USER_OWNER, new UserState(UserHandle.OWNER, true)); mUserLru.add(UserHandle.USER_OWNER); updateStartedUserArrayLocked(); ... //CPU使用情况的追踪器执行初始化 mProcessCpuTracker.init(); ... mRecentTasks = new RecentTasks(this); // 创建ActivityStackSupervisor对象 mStackSupervisor = new ActivityStackSupervisor(this, mRecentTasks); mTaskPersister = new TaskPersister(systemDir, mStackSupervisor, mRecentTasks); //创建名为&quot;CpuTracker&quot;的线程 mProcessCpuThread = new Thread(&quot;CpuTracker&quot;) &#123; public void run() &#123; while (true) &#123; synchronized(this) &#123; final long now = SystemClock.uptimeMillis(); long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now; long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now; if (nextWriteDelay &lt; nextCpuDelay) &#123; nextCpuDelay = nextWriteDelay; &#125; if (nextCpuDelay &gt; 0) &#123; mProcessCpuMutexFree.set(true); this.wait(nextCpuDelay); &#125; &#125; updateCpuStatsNow(); //更新CPU状态 &#125; &#125; &#125;; ...&#125; 该过程共创建了3个线程，分别为”ActivityManager”，”android.ui”，”CpuTracker”。 2.1.3 AMS.start123456789private void start() &#123; Process.removeAllProcessGroups(); //移除所有的进程组 mProcessCpuThread.start(); //启动CpuTracker线程 mBatteryStatsService.publish(mContext); //启动电池统计服务 mAppOpsService.publish(mContext); //创建LocalService，并添加到LocalServices LocalServices.addService(ActivityManagerInternal.class, new LocalService());&#125; 2.3 AMS.setSystemProcess12345678910111213141516171819202122232425262728293031323334public void setSystemProcess() &#123; try &#123; ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this)); ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this)); ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this)); if (MONITOR_CPU_USAGE) &#123; ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this)); &#125; ServiceManager.addService(&quot;permission&quot;, new PermissionController(this)); ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this)); ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( &quot;android&quot;, STOCK_PM_FLAGS); //【见小节2.3.1】 mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) &#123; //创建ProcessRecord对象 ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; //设置为persistent进程 app.pid = MY_PID; app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) &#123; mPidsSelfLocked.put(app.pid, app); &#125; updateLruProcessLocked(app, false, null);//维护进程lru updateOomAdjLocked(); //更新adj &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; throw new RuntimeException(&quot;&quot;, e); &#125;&#125; 该方法主要工作是注册各种服务。2.3.1 AT.installSystemApplicationInfo123456public void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; synchronized (this) &#123; getSystemContext().installSystemApplicationInfo(info, classLoader); mProfiler = new Profiler(); //创建用于性能统计的Profiler对象 &#125;&#125; 该方法调用ContextImpl的nstallSystemApplicationInfo()方法，最终调用LoadedApk的installSystemApplicationInfo，加载名为“android”的package 2.3.2 installSystemApplicationInfo12345void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; assert info.packageName.equals(&quot;android&quot;); mApplicationInfo = info; //将包名为&quot;android&quot;的应用信息保存到mApplicationInfo mClassLoader = classLoader;&#125; 2.4 startOtherServices12345678910111213141516171819202122232425private void startOtherServices() &#123; ... //安装系统Provider 【见小节2.4.1】 mActivityManagerService.installSystemProviders(); ... //phase480 &amp;&amp; 500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... //【见小节3.1】 mActivityManagerService.systemReady(new Runnable() &#123; public void run() &#123; //phase550 mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); ... //phase600 mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); ... &#125; &#125;&#125; 2.4.1 AMS.installSystemProviders1234567891011121314151617181920212223public final void installSystemProviders() &#123; List&lt;ProviderInfo&gt; providers; synchronized (this) &#123; ProcessRecord app = mProcessNames.get(&quot;system&quot;, Process.SYSTEM_UID); providers = generateApplicationProvidersLocked(app); if (providers != null) &#123; for (int i=providers.size()-1; i&gt;=0; i--) &#123; ProviderInfo pi = (ProviderInfo)providers.get(i); //移除非系统的provider if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) &#123; providers.remove(i); &#125; &#125; &#125; &#125; if (providers != null) &#123; //安装所有的系统provider mSystemThread.installSystemProviders(providers); &#125; // 创建核心Settings Observer，用于监控Settings的改变。 mCoreSettingsObserver = new CoreSettingsObserver(this);&#125; AMS 启动服务完成，并且将SystemServer纳入AMS管理体系，接下来主要看AMS如何通讯管理activity 三. createSystemContext12345678910private void createSystemContext() &#123; //调用ActivityThread的systemMain函数，其中会创建出系统对应的Context对象 ActivityThread activityThread = ActivityThread.systemMain(); //取出上面函数创建的Context对象，保存在mSystemContext中 mSystemContext = activityThread.getSystemContext(); //设置系统主题 mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);&#125; 在启动ams之前，系统调用了createSystemContext 创建了ActivityThread（app启动入口），配置了mSystemContext3.1 ActivityThread =&gt; attach123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[系统app]public static ActivityThread systemMain() &#123; // The system process on low-memory devices do not get to use hardware // accelerated drawing, since this can add too much overhead to the // process. if (!ActivityManager.isHighEndGfx()) &#123; //虽然写着ActivityManager，但和AMS没有任何关系 //就是利用系统属性和配置信息进行判断 //关闭硬件渲染功能 ThreadedRenderer.disable(true); &#125; else &#123; ThreadedRenderer.enableForegroundTrimming(); &#125; //创建ActivityThread ActivityThread thread = new ActivityThread(); //调用attach函数，参数为true thread.attach(true); return thread;&#125;[普通app]public static void main(String[] args) &#123; ...ignore some code... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; Looper.loop(); ...ignore some code... &#125; 最总进入attach123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//此时，我们传入的参数为true，表示该ActivityThread是系统进程的ActivityThreadprivate void attach(boolean system) &#123; //创建出的ActivityThread保存在类的静态变量sCurrentActivityThread //AMS中的大量操作将会依赖于这个ActivityThread sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; ...ignore some code... RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125; else &#123; //系统进程的处理流程，该情况只在SystemServer中处理 // Don&apos;t set application object here -- if the system crashes, // we can&apos;t display an alert, we just want to die die die. //设置DDMS(Dalvik Debug Monitor Service)中看到的SystemServer进程的名称为“system_process” android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;, UserHandle.myUserId()); try &#123; //创建ActivityThread中的重要成员：Instrumentation、Application和Context mInstrumentation = new Instrumentation(); ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); mInitialApplication = context.mPackageInfo.makeApplication(true, null); mInitialApplication.onCreate(); &#125; catch (Exception e) &#123; throw new RuntimeException( &quot;Unable to instantiate Application():&quot; + e.toString(), e); &#125; &#125; //以下系统进程和非系统进程均会执行 ................ //注册Configuration变化的回调通知 ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123; @Override public void onConfigurationChanged(Configuration newConfig) &#123; //当系统配置发生变化时（例如系统语言发生变化），回调该接口 ............... &#125; ............. &#125;);&#125; 启动流程：12345attach attachApplication attachApplicationLocked bindApplication makeApplication 来看下bindApplication123456789101112131415161718192021222324252627282930313233private class ApplicationThread extends ApplicationThreadNative &#123; public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; ...ignore some code... AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableOpenGlTrace = enableOpenGlTrace; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; sendMessage(H.BIND_APPLICATION, data); &#125;&#125; 我们需要关注的其实就是最后的sendMessage()，里面有函数的编号H.BIND_APPLICATION，然后这个Messge会被H这个Handler处理1234567891011121314151617181920private class H extends Handler &#123; ...ignore some code... public static final int BIND_APPLICATION = 110; ...ignore some code... public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ...ignore some code... case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ...ignore some code... &#125; &#125; 最后就在下面这个方法中，完成了实例化，拨那个企鹅通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。 1234567891011121314151617181920212223private void handleBindApplication(AppBindData data) &#123; try &#123; ...ignore some code... Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ...ignore some code... try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; &#125; try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; &#125; &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125; &#125; data.info是一个LoadeApk对象。 LoadeApk.data.info.makeApplication() 12345678910111213141516171819202122232425262728293031323334353637383940public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = &quot;android.app.Application&quot;; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) &#123; initializeJavaContextClassLoader(); &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; &#125; mActivityThread.mAllApplications.add(app); mApplication = app; //传进来的是null，所以这里不会执行，onCreate在上一层执行 if (instrumentation != null) &#123; try &#123; instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; &#125; &#125; ...ignore some code... &#125; return app; &#125; 所以最后还是通过Instrumentation.makeApplication()实例化的1234567static public Application newApplication(Class&lt;?&gt; clazz, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = (Application)clazz.newInstance(); app.attach(context); return app; &#125; 四. 从luanch app 出发看ams1234567891011121314151617181920212223242526272829303132/** * Launches the intent referred by the clicked shortcut */ public void onClick(View v) &#123; ...ignore some code... Object tag = v.getTag(); if (tag instanceof ShortcutInfo) &#123; // Open shortcut final Intent intent = ((ShortcutInfo) tag).intent; int[] pos = new int[2]; v.getLocationOnScreen(pos); intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0] + v.getWidth(), pos[1] + v.getHeight())); //开始开启Activity咯~ boolean success = startActivitySafely(v, intent, tag); if (success &amp;&amp; v instanceof BubbleTextView) &#123; mWaitingForResume = (BubbleTextView) v; mWaitingForResume.setStayPressed(true); &#125; &#125; else if (tag instanceof FolderInfo) &#123; //如果点击的是图标文件夹，就打开文件夹 if (v instanceof FolderIcon) &#123; FolderIcon fi = (FolderIcon) v; handleFolderClick(fi); &#125; &#125; else if (v == mAllAppsButton) &#123; ...ignore some code... &#125; &#125; 我们知道桌面引用就是lancher app .当用户点击后触发onclick事件，启动startActvitySafely，也就是startActivity 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125; 每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。当startActivityForResult()调用之后，实际上还是调用了mInstrumentation.execStartActivity()12345678910111213141516171819202122public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; ...ignore some code... &#125; else &#123; if (options != null) &#123; //当现在的Activity有父Activity的时候会调用，但是在startActivityFromChild()内部实际还是调用的mInstrumentation.execStartActivity() mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; ...ignore some code... &#125; 下面是mInstrumentation.execStartActivity()的实现123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ...ignore some code... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null; &#125; 客户端：ActivityManagerProxy =====&gt;Binder驱动=====&gt; ActivityManagerService：服务器客户端：ApplicationThread &lt;=====Binder驱动&lt;===== ApplicationThreadProxy：服务器 五. AMS接收到客户端的请求之后，会如何开启一个Activity？123456startActivity startActivityAsUser startActivityMayWait startActivityLocked startActivityUncheckedLocked startActivityLocked 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) &#123; //ActivityRecord中存储的TaskRecord信息 TaskRecord rTask = r.task; ...ignore some code... //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象 TaskRecord task = null; if (!newTask) &#123; boolean startIt = true; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; task = mTaskHistory.get(taskNdx); if (task.getTopActivity() == null) &#123; // task中的所有Activity都结束了 continue; &#125; if (task == r.task) &#123; // 找到了 if (!startIt) &#123; task.addActivityToTop(r); r.putInHistory(); mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); if (VALIDATE_TOKENS) &#123; validateAppTokensLocked(); &#125; ActivityOptions.abort(options); return; &#125; break; &#125; else if (task.numFullscreen &gt; 0) &#123; startIt = false; &#125; &#125; &#125; ...ignore some code... // Place a new activity at top of stack, so it is next to interact // with the user. task = r.task; task.addActivityToTop(r); task.setFrontOfTask(); ...ignore some code... if (doResume) &#123; mStackSupervisor.resumeTopActivitiesLocked(this, r, options); &#125; &#125; 123456789101112131415boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) &#123; if (targetStack == null) &#123; targetStack = getFocusedStack(); &#125; // Do targetStack first. boolean result = false; if (isFrontStack(targetStack)) &#123; result = targetStack.resumeTopActivityLocked(target, targetOptions); &#125; ...ignore some code... return result; &#125; 12345678910111213141516final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (inResumeTopActivity) &#123; // Don&apos;t even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. inResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; inResumeTopActivity = false; &#125; return result; &#125; 12345678910111213141516171819202122232425final boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123; ...ignore some code... //找出还没结束的首个ActivityRecord ActivityRecord next = topRunningActivityLocked(null); //如果一个没结束的Activity都没有，就开启Launcher程序 if (next == null) &#123; ActivityOptions.abort(options); if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: No more activities go home&quot;); if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); // Only resume home if on home display final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ? HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo(); return isOnHomeDisplay() &amp;&amp; mStackSupervisor.resumeHomeStackTask(returnTaskType, prev); &#125; //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态 if (mResumedActivity != null) &#123; pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause); if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); &#125; &#125; 123456789101112131415161718192021222324252627final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) &#123; if (mPausingActivity != null) &#123; completePauseLocked(false); &#125; ...ignore some code... if (prev.app != null &amp;&amp; prev.app.thread != null) try &#123; mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); &#125; catch (Exception e) &#123; mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; &#125; else &#123; mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; ...ignore some code... &#125; 在Lancher进程中消息传递，调用ActivityThread.handlePauseActivity()，最终调用ActivityThread.performPauseActivity()暂停指定Activity。接着通 过前面所说的Binder通信，通知AMS已经完成暂停的操作。 总结: ams启动时候启动mHandlerThread,ui,CpuTracker 线程 ams启动前还启动了 ActivityThread 。系统app attach(True),非系统app attach（False）。true代表直接通过Instrumentation makeApplication初始化引用程序。false 代表将app 通过ActivityManagerProxy 发到bind。ActivityManagerService 接受到bind信息后makeApplication初始化app(bind有认证)。最后Instrumentation.onCreate,启动app 从luanch app 出发看ams.监听桌面的图标，调用startActivity。ActivityManagerProxy startActivity,最后到startActivityLocked中暂停ActivityTask top层的activity，resume点击的app","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://langgithub.github.io/tags/Activity/"},{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android源码(3)-PackageManagerService启动流程","slug":"Android源码(3)-PackageManagerService启动流程","date":"2020-06-09T09:29:21.364Z","updated":"2020-06-09T09:29:21.364Z","comments":true,"path":"2020/06/09/Android源码(3)-PackageManagerService启动流程/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android源码(3)-PackageManagerService启动流程/","excerpt":"","text":"相关源码：12345678910frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.javaframeworks/base/services/core/java/com/android/server/pm/PackageInstallerService.javaframeworks/base/services/core/java/com/android/server/pm/Settings.javaframeworks/base/services/core/java/com/android/server/pm/Installer.javaframeworks/base/services/core/java/com/android/server/SystemConfig.javaframeworks/base/core/java/android/content/pm/PackageManager.javaframeworks/base/core/java/android/content/pm/IPackageManager.aidlframeworks/base/core/java/android/content/pm/PackageParser.javaframeworks/base/core/java/com/android/internal/os/InstallerConnection.javaframeworks/base/cmds/pm/src/com/android/commands/pm/Pm.java 一. system_server启动pmsAndroid的所有Java服务都是通过System_server进程启动的，并且驻留在system_server进程中。SystemServer进程在启动时，通过创建一个ServerThread线程来启动所有服务，现在先来看看Android服务中PackageManagerService服务启动过程 1/frameworks/base/services/java/com/android/server/SystemServer.java 1.1 startBootstrapServices()system_server的startBootstrapServices()函数启动一些引导服务，该方法所创建的服务 ActivityManagerService PowerManagerService LightService DisplayManagerService PackageManagerService UserManagerService SensorService服务 其中我们需要的PackageManagerService就在这里启动，我们来看看startBootstrapServices()是如何PMS123456789101112131415161718192021222324252627private void startBootstrapServices() &#123; //启动installer服务 Installer installer = mSystemServiceManager.startService(Installer.class); // We need the default display before we can initialize the package manager. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); //处于加密状态则仅仅解析核心应用 // Only run &quot;core&quot; apps if we&apos;re encrypting the device. String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) &#123; Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;); mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;); mOnlyCore = true; &#125; // 创建PMS对象 - 启动入口 traceBeginAndSlog(&quot;StartPackageManagerService&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); // 是否首次启动 mFirstBoot = mPackageManagerService.isFirstBoot(); // 获取PackageManager mPackageManager = mSystemContext.getPackageManager(); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);&#125; 1.2 startOtherServices()另外，system_server的startOtherServices()方法会启动其他服务，这个函数也会对PMS作一些操作12345678910111213141516171819202122private void startOtherServices() &#123; ...... if (!mOnlyCore) &#123; ........ try &#123; //将调用performDexOpt:Performs dexopt on the set of packages mPackageManagerService.updatePackagesIfNeeded(); &#125;....... ........ try &#123; //执行Fstrim，执行磁盘维护操作，未看到详细的资料 //可能类似于TRIM技术，将标记为删除的文件，彻底从硬盘上移除 //而不是等到写入时再移除，目的是提高写入时效率 mPackageManagerService.performFstrimIfNeeded(); &#125;......... ....... try &#123; mPackageManagerService.systemReady(); &#125;........ ....... &#125;&#125; 从上面的代码可以看出，PMS启动后将参与一些系统优化的工作，然后调用SystemReady函数通知系统进入就绪状态。 整个system_server进程启动过程，涉及PackageManagerServer启动流程 二. PMS.main入口PackageManagerServer.main过程主要创建PMS服务，并注册到ServiceManager大管家 三.PMS构造函数-分析1new PackageManagerService(context, installer, factoryTest, onlyCore); 创建PMS对象的过程，就是执行PMS的构造函数，PMS构造函数比较长，我们把这个过程分成几个阶段 BOOT_PROGRESS_PMS_START BOOT_PROGRESS_PMS_SYSTEM_SCAN_START BOOT_PROGRESS_PMS_DATA_SCAN_START BOOT_PROGRESS_PMS_SCAN_END BOOT_PROGRESS_PMS_READYPMS构造函数里面，在每个阶段开始的时候，都会往Eventlog里面打tag,比如像这样EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis()); 3.1 PMS_STARTBOOT_PROGRESS_PMS_START阶段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 输出event logEventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START, SystemClock.uptimeMillis());/** M: Mtprof tool @&#123; *///mMTPROFDisable = &quot;1&quot;.equals(SystemProperties.get(&quot;ro.mtprof.disable&quot;));mMTPROFDisable = false;addBootEvent(&quot;Android:PackageManagerService_Start&quot;);/** @&#125; */if (mSdkVersion &lt;= 0) &#123; Slog.w(TAG, &quot;**** ro.build.version.sdk not set!&quot;);&#125;mContext = context;mFactoryTest = factoryTest;mOnlyCore = onlyCore;// DisplayMetrics是一个描述界面显示，尺寸，分辨率，密度的类。mMetrics = new DisplayMetrics();// Settings是Android的全局管理者，用于协助PMS保存所有的安装包信息mSettings = new Settings(mPackages);mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;, RADIO_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(&quot;android.uid.log&quot;, LOG_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;, NFC_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(&quot;android.uid.bluetooth&quot;, BLUETOOTH_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);mSettings.addSharedUserLPw(&quot;android.uid.shell&quot;, SHELL_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);// 获取debug.separate_processes属性// 如果设置了这个属性，那么会强制应用程序组件在自己的进程中运行。// 一般情况下不会设置这个属性String separateProcesses = SystemProperties.get(&quot;debug.separate_processes&quot;);if (separateProcesses != null &amp;&amp; separateProcesses.length() &gt; 0) &#123; // 所有process都设置这个属性 if (&quot;*&quot;.equals(separateProcesses)) &#123; mDefParseFlags = PackageParser.PARSE_IGNORE_PROCESSES; mSeparateProcesses = null; Slog.w(TAG, &quot;Running with debug.separate_processes: * (ALL)&quot;); &#125; // 个别的process设置这个属性 else &#123; mDefParseFlags = 0; mSeparateProcesses = separateProcesses.split(&quot;,&quot;); Slog.w(TAG, &quot;Running with debug.separate_processes: &quot; + separateProcesses); &#125;&#125; else &#123; // 不设置这个属性,一般情况下会走这 mDefParseFlags = 0; mSeparateProcesses = null;&#125;// 保存Installer对象mInstaller = installer;// //用于dex优化mPackageDexOptimizer = new PackageDexOptimizer(installer, mInstallLock, context, &quot;*dexopt*&quot;);mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());mOnPermissionChangeListeners = new OnPermissionChangeListeners( FgThread.get().getLooper());// 获取默认的显示信息，保存到mMetricsgetDefaultDisplayMetrics(context, mMetrics);// 获取系统配置信息SystemConfig systemConfig = SystemConfig.getInstance();mGlobalGids = systemConfig.getGlobalGids();mSystemPermissions = systemConfig.getSystemPermissions();mAvailableFeatures = systemConfig.getAvailableFeatures();synchronized (mInstallLock) &#123;// writersynchronized (mPackages) &#123; //创建名为“PackageManager”的handler线程 mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/); mHandlerThread.start(); // 建立PackageHandler消息循环，用于处理外部的安装请求等消息 // 比如如adb install、packageinstaller安装APK时 mHandler = new PackageHandler(mHandlerThread.getLooper()); mProcessLoggingHandler = new ProcessLoggingHandler(); Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT); // 创建各种目录 File dataDir = Environment.getDataDirectory(); mAppInstallDir = new File(dataDir, &quot;app&quot;); mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;); mEphemeralInstallDir = new File(dataDir, &quot;app-ephemeral&quot;); mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath(); mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;); // 创建用户管理服务 sUserManager = new UserManagerService(context, this, mPackages); // Propagate permission configuration in to package manager. ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig = systemConfig.getPermissions(); for (int i=0; i&lt;permConfig.size(); i++) &#123; SystemConfig.PermissionEntry perm = permConfig.valueAt(i); BasePermission bp = mSettings.mPermissions.get(perm.name); if (bp == null) &#123; bp = new BasePermission(perm.name, &quot;android&quot;, BasePermission.TYPE_BUILTIN); mSettings.mPermissions.put(perm.name, bp); &#125; if (perm.gids != null) &#123; bp.setGids(perm.gids, perm.perUser); &#125; &#125; // 获取共享库 ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries(); for (int i=0; i&lt;libConfig.size(); i++) &#123; mSharedLibraries.put(libConfig.keyAt(i), new SharedLibraryEntry(libConfig.valueAt(i), null)); &#125; mFoundPolicyFile = SELinuxMMAC.readInstallPolicy(); // 解析packages.xml和packages-backup.xml mRestoredSettings = mSettings.readLPw(sUserManager.getUsers(false)); ... &#125; 总结阶段一主要工作如下: 构造DisplayMetrics类：描述界面显示，尺寸，分辨率，密度。构造完后并获取默认的信息保存到变量mMetrics中。 构造Setting：这个是Android的全局管理者，用于协助PMS保存所有的安装包信息 保存Installer对象 获取系统配置信息：SystemConfig构造函数中通过readPermissions()解析指定目录下的xml,然后把这个信息保存到SystemConfig中，设计的目录如下: /system/etc/sysconfig /system/etc/permissions /oem/etc/sysconfig /oem/etc/permissions 创建名为PackageManager的handler线程，建立PackageHandler消息循环，用于处理外部的安装请求等消息 创建data下的各种目录，比如data/app,data/app-private 创建用户管理服务UserManagerService 把systemConfig关于xml中的标签所指动态库保存到mSharedLibraries Setting.readLPw扫描packages.xml和package-backup.xml 补充说明debug.separate_processes这个属性这个属性你可以使用强制应用程序组件在自己的进程中运行，有两种方法可以使用这个：1234// 所有的进程都会收到影响setprop debug.separate_processes// 指定进程受影响setprop debug.separate_processes &quot;com.google.process.content, com.google.android.samples&quot; 3.2 PMS_SYSTEM_SCAN_START接下来是BOOT_PROGRESS_PMS_SYSTEM_SCAN_START阶段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152long startTime = SystemClock.uptimeMillis();EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime);final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;//该集合中存放的是已经优化或者不需要优先的文件final ArraySet&lt;String&gt; alreadyDexOpted = new ArraySet&lt;String&gt;();final String bootClassPath = System.getenv(&quot;BOOTCLASSPATH&quot;);final String systemServerClassPath = System.getenv(&quot;SYSTEMSERVERCLASSPATH&quot;);//将环境变量BOOTCLASSPATH所执行的文件加入alreadyDexOptedif (bootClassPath != null) &#123; String[] bootClassPathElements = splitString(bootClassPath, &apos;:&apos;); for (String element : bootClassPathElements) &#123; alreadyDexOpted.add(element); &#125;&#125;//将环境变量SYSTEMSERVERCLASSPATH所执行的文件加入alreadyDexOptedif (systemServerClassPath != null) &#123; String[] systemServerClassPathElements = splitString(systemServerClassPath, &apos;:&apos;); for (String element : systemServerClassPathElements) &#123; alreadyDexOpted.add(element); &#125;&#125;...//此处共享库是由SystemConfig实例化过程赋值的if (mSharedLibraries.size() &gt; 0) &#123; for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123; for (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123; final String lib = libEntry.path; ... int dexoptNeeded = DexFile.getDexOptNeeded(lib, dexCodeInstructionSet, &quot;speed&quot;, false); if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; alreadyDexOpted.add(lib); //执行dexopt操作 mInstaller.dexopt(lib, Process.SYSTEM_UID, dexCodeInstructionSet, dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/); &#125; &#125; &#125;&#125;//此处frameworkDir目录为/system/frameworkFile frameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;);//添加以下两个文件添加到已优化集合alreadyDexOpted.add(frameworkDir.getPath() + &quot;/framework-res.apk&quot;);alreadyDexOpted.add(frameworkDir.getPath() + &quot;/core-libart.jar&quot;);String[] frameworkFiles = frameworkDir.list();if (frameworkFiles != null) &#123; for (String dexCodeInstructionSet : dexCodeInstructionSets) &#123; for (int i=0; i&lt;frameworkFiles.length; i++) &#123; File libPath = new File(frameworkDir, frameworkFiles[i]); String path = libPath.getPath(); //跳过已优化集合中的文件 if (alreadyDexOpted.contains(path)) &#123; continue; &#125; //跳过后缀不为apk和jar的文件 if (!path.endsWith(&quot;.apk&quot;) &amp;&amp; !path.endsWith(&quot;.jar&quot;)) &#123; continue; &#125; int dexoptNeeded = DexFile.getDexOptNeeded(path, dexCodeInstructionSet, &quot;speed&quot;, false); if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; //执行dexopt操作【见小节2.2.1】 mInstaller.dexopt(path, Process.SYSTEM_UID, dexCodeInstructionSet, dexoptNeeded, DEXOPT_PUBLIC /*dexFlags*/); &#125; &#125; &#125;&#125;final VersionInfo ver = mSettings.getInternalVersion();mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);mPromoteSystemApps = mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;if (mPromoteSystemApps) &#123; Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator(); while (pkgSettingIter.hasNext()) &#123; PackageSetting ps = pkgSettingIter.next(); if (isSystemApp(ps)) &#123; mExistingSystemPackages.add(ps.name); &#125; &#125;&#125;//收集供应商包名：/vendor/overlayFile vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);//收集包名：/system/frameworkscanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0);//收集私有的系统包名：/system/priv-appfinal File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;);scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);//收集一般地系统包名：/system/appfinal File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;);scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);//收集私有供应商包名：/vendor/priv-appfinal File privilegedVendorAppDir = new File(Environment.getVendorDirectory(), &quot;priv-app&quot;);scanDirLI(privilegedVendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);//收集所有的供应商包名：/vendor/appFile vendorAppDir = new File(Environment.getVendorDirectory(), &quot;app&quot;);vendorAppDir = vendorAppDir.getCanonicalFile();scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);//收集所有OEM包名：/oem/appfinal File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;);scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);//移除文件mInstaller.moveFiles();//删除不在存在的系统包final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;();if (!mOnlyCore) &#123; Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator(); while (psit.hasNext()) &#123; PackageSetting ps = psit.next(); if ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123; continue; &#125; final PackageParser.Package scannedPkg = mPackages.get(ps.name); if (scannedPkg != null) &#123; if (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; removePackageLI(ps, true); mExpectingBetter.put(ps.name, ps.codePath); &#125; continue; &#125; if (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123; psit.remove(); removeDataDirsLI(null, ps.name); &#125; else &#123; final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name); if (disabledPs.codePath == null || !disabledPs.codePath.exists()) &#123; possiblyDeletedUpdatedSystemApps.add(ps.name); &#125; &#125; &#125;&#125;//清理所有安装不完整的包ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();for(int i = 0; i &lt; deletePkgsList.size(); i++) &#123; cleanupInstallFailedPackage(deletePkgsList.get(i));&#125;//删除临时文件deleteTempPackageFiles();//移除不相干包中的所有共享userIDmSettings.pruneSharedUsersLPw(); PMS_SYSTEM_SCAN_START阶段主要做了如下工作： 首先将BOOTCLASSPATH,SYSTEMSERVERCLASSPATH这两个环境变量下的路径加入到不需要优化dex优化集合alreadyDexOpted中 SYSTEMSERVERCLASSPATH:主要包含/system/framework目录下的services.jar ethernet-service.jar,wifi-service.jar这3个文件 BOOTCLASSPATH:该环境变量内容较多，不同的ROM可能有所不同，常见内容包含/system/frmework目录下的freamework.jar,ext.jar,core-libart.jar,telephony-commom.jar,ims-common.jar,core-junit.jar等 获取共享库mSharedLibraries，判断是否需要dex优化，如果需要则进行dex优化，并加入到alreadyDexOpted列表中 添加framework-res.apk,core-libart.jar两个文件添加到已优化集合alreadyDexOpted中 将framework目录下，其他的apk或jar,进行dex优化并加入到优化集合alreadyDexOpted中 scanDirLi():扫描指定目录下的apk文件，最终调用PackageParse.parseBaseApk来完成AndroidManifest.xml的文件解析，生成Application，activity,service,broadcast,provider等信息 删除系统不存在的包removePackageLI 清理安装失败的包cleanupInstallFaildPackage 删除临时文件deleteTempPackageFiles 移除不想干包中的所有共享UserId 3.3 PMS_DATA_SCAN_STARTBOOT_PROGRESS_PMS_DATA_SCAN_START阶段：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283if (!mOnlyCore) &#123; EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START, SystemClock.uptimeMillis()); scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0); scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK, scanFlags | SCAN_REQUIRE_KNOWN, 0); /** * Remove disable package settings for any updated system * apps that were removed via an OTA. If they&apos;re not a * previously-updated app, remove them completely. * Otherwise, just revoke their system-level permissions. */ for (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123; PackageParser.Package deletedPkg = mPackages.get(deletedAppName); mSettings.removeDisabledSystemPackageLPw(deletedAppName); String msg; if (deletedPkg == null) &#123; msg = &quot;Updated system package &quot; + deletedAppName + &quot; no longer exists; wiping its data&quot;; removeDataDirsLI(null, deletedAppName); &#125; else &#123; msg = &quot;Updated system app + &quot; + deletedAppName + &quot; no longer present; removing system privileges for &quot; + deletedAppName; deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM; PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName); deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM; &#125; logCriticalInfo(Log.WARN, msg); &#125; /** * Make sure all system apps that we expected to appear on * the userdata partition actually showed up. If they never * appeared, crawl back and revive the system version. */ for (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123; final String packageName = mExpectingBetter.keyAt(i); if (!mPackages.containsKey(packageName)) &#123; final File scanFile = mExpectingBetter.valueAt(i); logCriticalInfo(Log.WARN, &quot;Expected better &quot; + packageName + &quot; but never showed up; reverting to system&quot;); final int reparseFlags; if (FileUtils.contains(privilegedAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED; &#125; else if (FileUtils.contains(systemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(vendorAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else if (FileUtils.contains(oemAppDir, scanFile)) &#123; reparseFlags = PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR; &#125; else &#123; Slog.e(TAG, &quot;Ignoring unexpected fallback path &quot; + scanFile); continue; &#125; mSettings.enableSystemPackageLPw(packageName); try &#123; scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null); &#125; catch (PackageManagerException e) &#123; Slog.e(TAG, &quot;Failed to parse original system package: &quot; + e.getMessage()); &#125; &#125; &#125; &#125; mExpectingBetter.clear(); // Now that we know all of the shared libraries, update all clients to have // the correct library paths. updateAllSharedLibrariesLPw(); for (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123; // NOTE: We ignore potential failures here during a system scan (like // the rest of the commands above) because there&apos;s precious little we // can do about it. A settings error is reported, though. adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */, false /* force dexopt */, false /* defer dexopt */); &#125; // Now that we know all the packages we are keeping, // read and update their last usage times. mPackageUsage.readLP(); 3.4 PMS_SCAN_ENDBOOT_PROGRESS_PMS_SCAN_END阶段：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END, SystemClock.uptimeMillis());Slog.i(TAG, &quot;Time to scan packages: &quot; + ((SystemClock.uptimeMillis()-startTime)/1000f) + &quot; seconds&quot;);// 当sdk版本不一致时，需要更新权限int updateFlags = UPDATE_PERMISSIONS_ALL;if (ver.sdkVersion != mSdkVersion) &#123; Slog.i(TAG, &quot;Platform changed from &quot; + ver.sdkVersion + &quot; to &quot; + mSdkVersion + &quot;; regranting permissions for internal storage&quot;); updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;&#125;updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);ver.sdkVersion = mSdkVersion;//当这是ota后的首次启动，正常启动则需要清除目录的缓存代码if (!onlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) &#123; for (UserInfo user : sUserManager.getUsers(true)) &#123; mSettings.applyDefaultPreferredAppsLPw(this, user.id); applyFactoryDefaultBrowserLPw(user.id); primeDomainVerificationsLPw(user.id); &#125;&#125;//当权限和其他默认项都完成更新，则清理相关信息final int storageFlags;if (StorageManager.isFileEncryptedNativeOrEmulated()) &#123; storageFlags = StorageManager.FLAG_STORAGE_DE;&#125; else &#123; storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;&#125;reconcileAppsDataLI(StorageManager.UUID_PRIVATE_INTERNAL, UserHandle.USER_SYSTEM, storageFlags);//当这是ota后的首次启动，正常启动则需要清除目录的缓存代码if (mIsUpgrade &amp;&amp; !onlyCore) &#123; Slog.i(TAG, &quot;Build fingerprint changed; clearing code caches&quot;); for (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123; final PackageSetting ps = mSettings.mPackages.valueAt(i); if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123; // No apps are running this early, so no need to freeze clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE | Installer.FLAG_CLEAR_CODE_CACHE_ONLY); &#125; &#125; ver.fingerprint = Build.FINGERPRINT;&#125;checkDefaultBrowser();//当权限和其他默认项都完成更新，则清理相关信息mExistingSystemPackages.clear();mPromoteSystemApps = false;// All the changes are done during package scanning.ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;//信息写回packages.xml文件mSettings.writeLPr(); 当sdk版本不一致时，需要跟新权限 当这是ota后的首次启动，正常启动则需要清理目标的缓存代码 当权限和其他默认项都完成更新，则清理相关信息 信息写回package.xml文件 3.5 PMS_READYBOOT_PROGRESS_PMS_READY阶段：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis()); if (!mOnlyCore) &#123; mRequiredVerifierPackage = getRequiredButNotReallyRequiredVerifierLPr(); mRequiredInstallerPackage = getRequiredInstallerLPr(); mRequiredUninstallerPackage = getRequiredUninstallerLPr(); mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr(); mIntentFilterVerifier = new IntentVerifierProxy(mContext, mIntentFilterVerifierComponent); mServicesSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SERVICES); mSharedSystemSharedLibraryPackageName = getRequiredSharedLibraryLPr( PackageManager.SYSTEM_SHARED_LIBRARY_SHARED); &#125; else &#123; mRequiredVerifierPackage = null; mRequiredInstallerPackage = null; mRequiredUninstallerPackage = null; mIntentFilterVerifierComponent = null; mIntentFilterVerifier = null; mServicesSystemSharedLibraryPackageName = null; mSharedSystemSharedLibraryPackageName = null; &#125; mInstallerService = new PackageInstallerService(context, this); final ComponentName ephemeralResolverComponent = getEphemeralResolverLPr(); final ComponentName ephemeralInstallerComponent = getEphemeralInstallerLPr(); // both the installer and resolver must be present to enable ephemeral if (ephemeralInstallerComponent != null &amp;&amp; ephemeralResolverComponent != null) &#123; if (DEBUG_EPHEMERAL) &#123; Slog.i(TAG, &quot;Ephemeral activated; resolver: &quot; + ephemeralResolverComponent + &quot; installer:&quot; + ephemeralInstallerComponent); &#125; mEphemeralResolverComponent = ephemeralResolverComponent; mEphemeralInstallerComponent = ephemeralInstallerComponent; setUpEphemeralInstallerActivityLP(mEphemeralInstallerComponent); mEphemeralResolverConnection = new EphemeralResolverConnection(mContext, mEphemeralResolverComponent); &#125; else &#123; if (DEBUG_EPHEMERAL) &#123; final String missingComponent = (ephemeralResolverComponent == null) ? (ephemeralInstallerComponent == null) ? &quot;resolver and installer&quot; : &quot;resolver&quot; : &quot;installer&quot;; Slog.i(TAG, &quot;Ephemeral deactivated; missing &quot; + missingComponent); &#125; mEphemeralResolverComponent = null; mEphemeralInstallerComponent = null; mEphemeralResolverConnection = null; &#125; mEphemeralApplicationRegistry = new EphemeralApplicationRegistry(this);&#125; // synchronized (mPackages)&#125; // synchronized (mInstallLock)// Now after opening every single application zip, make sure they// are all flushed. Not really needed, but keeps things nice and// tidy.Runtime.getRuntime().gc();// The initial scanning above does many calls into installd while// holding the mPackages lock, but we&apos;re mostly interested in yelling// once we have a booted system.mInstaller.setWarnIfHeld(mPackages);// Expose private service for system components to use.LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl()); 初始化PackageInstallerService GC回收下内存 四. PMS构造函数-总结PMS初始化过程，分为5个阶段:1.PMS_START阶段: 创建Setting对象； 将6类shareUserId到mSettings; 初始化SystemConfig; 创建名为“PackageManagerService”的handler线程mHandlerThread 创建UserManagerService多用户管理服务 通过解析4大目录中的xml文件构造共享mSharedLibraries; PMS_SYSTEM_SCAN_START阶段： mSharedLibraries共享库的文件执行dexopt操作 system/framework目录中满足的pak或jar文件执行dexopt操作 扫描系统apk PMS_DATA_SCAN_START阶段: 扫描/data/app目录下的apk 扫描/data/app-private目录下的apk PMS_SCAN_END 将上诉信息写回/data/system/package.xml5 PMS_READY阶段 创建服务PackageInstallerService 到这里，大致介绍完了整个PMS构造函数的流程，基本上PMS_SCAN_END阶段我们apk就算安装完成了，接下来是单独看看几个比较重要模块 Setting SystemConfig-readPermissions scanPackageLI 五. Settings在BOOT_PROGRESS_PMS_START阶段，我们会创建Setting对象，以及一堆addSharedUserLPw调用123mSettings = new Settings(mPackages);mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); 5.1 创建Settings12345678910111213141516171819202122232425262728293031[frameworks/base/services/core/java/com/android/server/pm/Settings.java]Settings(Object lock) &#123; this(Environment.getDataDirectory(), lock);&#125;Settings(File dataDir, Object lock) &#123; mLock = lock; mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock); //创建目录&quot;data/system&quot; mSystemDir = new File(dataDir, &quot;system&quot;); mSystemDir.mkdirs(); FileUtils.setPermissions(mSystemDir.toString(), FileUtils.S_IRWXU|FileUtils.S_IRWXG |FileUtils.S_IROTH|FileUtils.S_IXOTH, -1, -1); // packages.xml和packages-backup.xml为一组，用于描述系统所安装的Package信息， // 其中packages-backup.xml是packages.xml的备份 // PMS写把数据写到backup文件中，信息全部写成功后在改名为非backup文件， // 以防止在写文件的过程中出错，导致信息丢失 mSettingsFilename = new File(mSystemDir, &quot;packages.xml&quot;); mBackupSettingsFilename = new File(mSystemDir, &quot;packages-backup.xml&quot;); //packages.list保存系统中存在的所有非系统自带的APK信息，即UID大于10000的apk mPackageListFilename = new File(mSystemDir, &quot;packages.list&quot;); FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID); //感觉是sdcardfs相关的文件 final File kernelDir = new File(&quot;/config/sdcardfs&quot;); mKernelMappingFilename = kernelDir.exists() ? kernelDir : null; // Deprecated: Needed for migration //packages-stopped.xml用于描述系统中强行停止运行的package信息，backup也是备份文件 mStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped.xml&quot;); mBackupStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped-backup.xml&quot;);&#125; Setting的构造函数主要用于创建data/system 目录和一些xml文件，并配置相应的权限，其中： packages.xml记录所有安装app信息，当系统进行程序安装，卸载和更新操作时，均会跟新该文件 package-backup.xml 备份文件 packages-stopped.xml 记录被用户强行停止的应用Package信息 packages-stopped-backup.xml 备份文件 packages.list 记录非系统自带的apk的数据信息，这些apk有变化会更新该文件 5.2 Setting.readLPwreadLPw()函数，从/data/system/packages.xml或packages-backup.xml文件中获取packages,permissions相关信息，添加相关内存列表。packages.xml文件记录了系统的permisssions以及每个apk的name,codePath,flags,version等信息这些信息主要通过apk的AndroidManifest.xml解析获取，解析完apk后将更新信息写入这个文件，下次开机直接从里面读取相关信息添加到内存相关结构中，当有apk升级，安装，删除会更新这个文件。 5.3 Setting.writeLPrwriteLPr函数，将解析出的每个apk的信息（mSetting.mPackages）保存到packages.xml和packages.list文件。packages.list记录如下数据：pkgName,userid,debugFlag,dataPath(包的数据路径) 六. SystemConfig-readPermissions同样在BOOT_PROGRESS_PMS_START阶段，我们会初始化SystemConfig去获取系统配置信息12345// 获取系统配置信息SystemConfig systemConfig = SystemConfig.getInstance();mGlobalGids = systemConfig.getGlobalGids();mSystemPermissions = systemConfig.getSystemPermissions();mAvailableFeatures = systemConfig.getAvailableFeatures(); 6.1 创建SystemCofig1234567891011121314151617181920212223242526272829[frameworks/base/services/core/java/com/android/server/SystemConfig.java]//单例模式public static SystemConfig getInstance() &#123; synchronized (SystemConfig.class) &#123; if (sInstance == null) &#123; sInstance = new SystemConfig(); &#125; return sInstance; &#125;&#125;SystemConfig() &#123; // system/etc/目录 readPermissions(Environment.buildPath( Environment.getRootDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_ALL); readPermissions(Environment.buildPath( Environment.getRootDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_ALL); int odmPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS; // odm/etc/目录 readPermissions(Environment.buildPath( Environment.getOdmDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), odmPermissionFlag); readPermissions(Environment.buildPath( Environment.getOdmDirectory(), &quot;etc&quot;, &quot;permissions&quot;), odmPermissionFlag); // oem/etc/目录 readPermissions(Environment.buildPath( Environment.getOemDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_FEATURES); readPermissions(Environment.buildPath( Environment.getOemDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_FEATURES);&#125; 从上面可以看出，SystemConfig是单例模式，会通过readPermissions解析目录下的xml文件：/system/etc/sysconfig /system/etc/permissions/odm/etc/sysconfig /odm/etc/permissions/oem/etc/sysconfig /oem/etc/permissions其中比较重要的是system/etc/permisssions目录，该目录大多来源于代码中的frameworks/(base or native)/data/etc，这些文件的作用表明系统支持的feature有哪些，例如是否支持蓝牙，wifi,p2p 6.2 readzPermissions readPermissions会循环去读取目录下的xml,但是它会跳过platform.xml文件，最后再去读取platform.xml文件12345678910111213141516171819void readPermissions(File libraryDir, int permissionFlag) &#123; //检测目录是否存在，是否可读 .......... // Iterate over the files in the directory and scan .xml files File platformFile = null; // 循环解析xml文件 for (File f : libraryDir.listFiles()) &#123; // 跳过，最后再解析platform.xml if (f.getPath().endsWith(&quot;etc/permissions/platform.xml&quot;)) &#123; platformFile = f; continue; &#125; // 解析可读的xml文件 readPermissionsFromXml(f, permissionFlag); &#125; // 最后解析platform.xml文件 if (platformFile != null) &#123; readPermissionsFromXml(platformFile, permissionFlag); &#125; 我们发现读取函数最后都调用最后都调用readPermissionsFromXml(),函数readPermissionFromXml最终会使用XMLPullParase的方式解析这些文件，然后再把解析出来的数据结构保存到PMS中 6.2.1 android.hardware.bluetooth.xml最终会解析并且保存到PMS的 final ArrayMap&lt;String, FeatureInfo&gt; mAvailableFeatures中。123&lt;permissions&gt; &lt;feature name=&quot;android.hardware.bluetooth&quot; /&gt; &lt;/permissions&gt; 6.2.2 com.android.location.provider.xml指明了运行一些library时，还需要加载一些java库。这个最终会解析并保存到PMS的final ArrayMap&lt;String, SharedLibraryEntry&gt; mSharedLibraries中。1234&lt;permissions&gt; &lt;library name=&quot;com.android.location.provider&quot; file=&quot;/system/framework/com.android.location.provider.jar&quot; /&gt;&lt;/permissions&gt; 6.2.3 platform.xml这个文件中定义了底层GID和app层权限名字之间的对应关系，或者直接给某一个uid赋予对应的权限：12345678910&lt;permissions&gt; &lt;permission name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &gt; &lt;group gid=&quot;sdcard_r&quot; /&gt; &lt;group gid=&quot;sdcard_rw&quot; /&gt; &lt;/permission&gt; ...... &lt;assign-permission name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; uid=&quot;media&quot; /&gt; &lt;assign-permission name=&quot;android.permission.ACCESS_SURFACE_FLINGER&quot; uid=&quot;media&quot; /&gt; ......&lt;/permissions&gt; 解析标签的时候，会创建一个PermissionEntry类，他关联了gids和permission name：最终PermissionEntry会放入SystemConfig的final ArrayMap&lt;String, PermissionEntry&gt; mPermissions变量中。1234567public static final class PermissionEntry &#123; public final String name; public int[] gids; PermissionEntry(String _name) &#123; name = _name; &#125; &#125; 解析的时候表示把属性name中的字符串表示的权限赋予属性uid中的用户。uid和name则存入SystemConfig中的SparseArray&gt; 类型的mSystemPermissions变量中 7.2 scanPackageLI安装apkPackageManagerService的scanPackageLI过程scanPackageLI()有3个重载的方法，参数稍有不同：123456789// 第（1）个private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user)// 第（2）个private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile, final int policyFlags, int scanFlags, long currentTime, UserHandle user)// 第（3）个private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags, int scanFlags, long currentTime, UserHandle user) (1）scanPackageLI(File scanFile, int parseFlags,…）函数 实例化一个PackageParser对象，接着调用该对象的parsePackage()对APK文件进行解析。实例化一个Package对象，用于保存解析出的APK信息从AndroidManifest.xml文件中解析出VersionCode、VersionName、installLocation等全局属性信息，然后根据标签循环解析XML文件包含的其它组成部分，将解析出的信息添加到Package对象的相关列表中。1234567891011121314151617private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; //创建出PackageParser对象 PackageParser pp = new PackageParser(); ........... final PackageParser.Package pkg; try &#123; // 解析package pkg = pp.parsePackage(scanFile, parseFlags); &#125; catch (PackageParserException e) &#123; .......... &#125; finally &#123; .......... &#125; //调用第（2）个scanPackageLI return scanPackageLI(pkg, scanFile, parseFlags, scanFlags, currentTime, user);&#125; 最后会调用第（2）个scanPackageLI去继续解析。 （2）scanPackageLI(PackageParser.Package pkg, File scanFile,…)函数1234567891011121314151617181920212223242526272829303132333435private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; //有childPackage时，第一次只执行检查的工作 if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123; //当解析一个Package的AndroidManifest.xml时，如果该XML文件中使用了&quot;package&quot;的tag //那么该tag对应的package是当前XML文件对应package的childPackage if (pkg.childPackages != null &amp;&amp; pkg.childPackages.size() &gt; 0) &#123; scanFlags |= SCAN_CHECK_ONLY; &#125; &#125; else &#123; //第二次进入，才开始实际的解析 scanFlags &amp;= ~SCAN_CHECK_ONLY; &#125; final PackageParser.Package scannedPkg; try &#123; // Scan the parent //scanFlags将决定这一次是否仅执行检查工作 scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags, currentTime, user); final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0; for (int i = 0; i &lt; childCount; i++) &#123; PackageParser.Package childPkg = pkg.childPackages.get(i); scanPackageLI(childPkg, policyFlags, scanFlags, currentTime, user); &#125; &#125; finally &#123; ......... &#125; if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123; //第一次检查完毕后，再次调用函数 return scanPackageTracedLI(pkg, policyFlags, scanFlags, currentTime, user); &#125; return scannedPkg;&#125; （3）scanPackageLI(PackageParser.Package pkg, final int policyFlags,…)函数 最终会走到第三个scanPackageLI函数，这个函数最后会调用scanPackageDirtyLI函数，scanPackageDirtyLI是实际解析package的函数，这个才是真正干活的。 12345678910111213private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123; boolean success = false; try &#123; //实际的解析函数，很长... final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags, currentTime, user); success = true; return res; &#125; finally &#123; ........... &#125;&#125; 7.3 scanPackageDirtyLI通过上述的扫描过程，我们得到了当前apk文件对应的Package信息。不过这部分信息是存储在PackageParser中的，我们必须将这部分信息传递到PMS中。毕竟最终的目的是：让PMS能得到所有目录下Package的信息。scanPackageDirtyLI函数主要就是把签名解析应用程序得到的package、provider、service、receiver和activity等信息保存在PackageManagerService相关的成员列表里。 比如将每个APK的receivers列表里的元素，通过mReceivers.addActivity(a, “receiver”)添加到PMS成员列表mReceivers中: 1final ActivityIntentResolver mReceivers = new ActivityIntentResolver();`由于实际解析函数太长，粗略看下有1000来行，读者有兴趣的可以自行研究。 八、开机时间分析adb shell cat /proc/bootprof/1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 C:\\Users\\shun&gt;adb shell cat /proc/bootprof----------------------------------------0 BOOT PROF (unit:msec)---------------------------------------- 1655 : preloader 1001 : lk 493 : lk-&gt;Kernel---------------------------------------- 5156.702307 : Kernel_init_done 5171.629538 : SElinux start. 10739.699692 : SElinux end. 11496.788538 : INIT: on init start 11878.325615 : INIT:eMMC:Mount_START 12777.653384 : INIT:eMMC:Mount_END 12780.874230 : INIT:PROTECT:Mount_START 12938.042615 : INIT:PROTECT:Mount_END 14029.370538 : INIT: eng build setting 15215.342538 : BOOT_Animation:START 16618.475076 : Zygote:Preload Start 20691.658230 : Zygote:Preload 2775 classes in 4062ms 23061.424153 : Zygote:Preload 274 obtain resources in 2334ms 23110.519076 : Zygote:Preload 31 resources in 47ms 23240.816000 : Zygote:Preload End 23720.832000 : Android:SysServerInit_START 24448.175153 : Android:PackageManagerService_Start 24747.363153 : Android:PMS_scan_START 24817.216000 : Android:PMS_scan_done:/custom/framework 24947.104384 : Android:PMS_scan_done:/system/framework 25131.265384 : Android:PMS_scan_done:/system/priv-app 25533.440461 : Android:PMS_scan_done:/system/app 25540.237769 : Android:PMS_scan_done:/system/vendor/app 25542.379538 : Android:PMS_scan_done:/system/vendor/operator/app 25544.285615 : Android:PMS_scan_done:/custom/app 25551.297076 : Android:PMS_scan_data_start 25967.971076 : Android:PMS_scan_data_done:/data/app 25969.811230 : Android:PMS_scan_data_done:/data/app-private 25971.862692 : Android:PMS_scan_END 26224.410076 : Android:PMS_READY 30108.635538 : AP_Init:[service]:[com.mediatek.security]:[com.mediatek.security/.service.PermControlService]:pid:738 30548.305692 : AP_Init:[broadcast]:[com.android.settings]:[com.android.settings/.widget.SettingsAppWidgetProvider]:pid:769 31341.380923 : AP_Init:[broadcast]:[com.mediatek.engineermode]:[com.mediatek.engineermode/.wifi.WifiStateReceiver]:pid:806 31563.917923 : AP_Init:[broadcast]:[com.tvguo.app]:[com.tvguo.app/.content.TvguoStateReceiver]:pid:829 31708.206000 : AP_Init:[service]:[com.android.systemui]:[com.android.systemui/.ImageWallpaper]:pid:847 31796.008076 : AP_Init:[service]:[com.android.inputmethod.latin]:[com.android.inputmethod.latin/.LatinIME]:pid:860 31987.434923 : AP_Init:[added application]:[com.mediatek.dongle]:[com.mediatek.dongle]:pid:878:(PersistAP) 32051.271692 : AP_Init:[added application]:[com.mediatek.bluetooth]:[com.mediatek.bluetooth]:pid:891:(PersistAP) 32142.389846 : AP_Init:[activity]:[com.android.launcher3]:[com.android.launcher3/.Launcher]:pid:906 32170.530846 : Android:SysServerInit_END 32309.788000 : AP_Init:[service]:[com.android.printspooler]:[com.android.printspooler/.PrintSpoolerService]:pid:923 33967.604076 : AP_Init:[broadcast]:[com.android.contacts]:[com.android.contacts/com.mediatek.contacts.simcontact.BootCmpReceiver]:pid:972 34752.970538 : AP_Init:[content provider]:[android.process.acore]:[com.android.providers.contacts/.ContactsProvider2]:pid:1028 35486.120000 : BOOT_Animation:END--------------------------------- 我们可以从上面的信息看到PMS在开机的时候做的动作和时间分布：（因为手上只有kk的平台，所以信息不太对应） 123456789101112131424747.363153 : Android:PMS_scan_START24817.216000 : Android:PMS_scan_done:/custom/framework24947.104384 : Android:PMS_scan_done:/system/framework25131.265384 : Android:PMS_scan_done:/system/priv-app25533.440461 : Android:PMS_scan_done:/system/app25540.237769 : Android:PMS_scan_done:/system/vendor/app25542.379538 : Android:PMS_scan_done:/system/vendor/operator/app25544.285615 : Android:PMS_scan_done:/custom/app25551.297076 : Android:PMS_scan_data_start25967.971076 : Android:PMS_scan_data_done:/data/app25969.811230 : Android:PMS_scan_data_done:/data/app-private25971.862692 : Android:PMS_scan_END26224.410076 : Android:PMS_READY一般app装的越多，那么开机时间就会越长。","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://langgithub.github.io/tags/Activity/"},{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android源码(4)-应用程序安装流程","slug":"Android源码(4)-应用程序安装流程","date":"2020-06-09T09:29:21.364Z","updated":"2020-06-09T09:29:21.364Z","comments":true,"path":"2020/06/09/Android源码(4)-应用程序安装流程/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android源码(4)-应用程序安装流程/","excerpt":"","text":"一. 安装流程图 从上图我们可以看到apk安装到最后都会调用到这个flow：1PMS.scanPackageTracedLI=&gt;PMS.scanPackageLI=&gt;PMS.scanPackageDirtyLI 二. APK文件结构APK(Android Package)，可以看做是一个zip压缩包，可以通过解压缩工具解开，其文件结构如下： 目录 or 文件 描述 assert 存放的原生资源文件,通过AssetManager类访问 lib native库文件 META - INF 存放签名信息，用来保证APK包的完整性和系统的安全。系统安装APK时，应用管理器会按照对应算法对包里文件做校验，如果校验结果与META-INF中内容不一致，则不会安装这个APK。 res 种资源文件系统会在R.java里面自动生成该资源文件的ID，所以访问这种资源文件比较简单，通过R.XXX.ID即可 AndroidManifest.xml 每个应用都必须定义和包含，描述应用的名字、版本权限、引用的库文件等信息。apk中的AndroidManifest.xml经过压缩，可以通过AXMLPrinter2工具解开。 classes.dex 是JAVA源码编译后生成的JAVA字节码文件。但Android使用的dalvik虚拟机与标准的JAVA虚拟机不兼容，dex文件与class文件相比，不论是文件结构还是opcode都不一样。 resources.arsc 编译后的二进制资源文件。 三. apk安装方法apk有下面4种安装方法： 方法 描述 开机过程中安装 开机时完成，没有安装界面，如系统应用、其它预置应用 adb工具安装 没有安装界面，adb install/push xxxx.apk 第三方应用安装 通过packageinstaller.apk进行安装，有安装界面，如打开文件管理器并点击sdk卡里APK文件 网络下载应用安装 通过google market应用完成，没有安装界面 简单说明下apk安装的基本过程： 拷贝目标apk到指定文件目录调用scanPackageLI为apk文件在系统中注册信息 四.引用程序安装过程上述几种安装方法最终都通过PackageManagerService.scanPackageLI完成，总结起来大致有以下三种方式： adb push：PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件frameworks\\base\\services\\java\\com\\android\\server\\pm\\PackageManagerService.java adb install：安装入口函数为Pm.runInstallframeworks\\base\\cmds\\pm\\src\\com\\android\\commands\\pm\\Pm.java 网络下载应用安装和第三方应用安装：安装入口函数为ApplicationPackageManager.installPackageframeworks\\base\\core\\java\\android\\app\\ApplicationPackageManager.java 五、adb pushAndroid 4.4平台，PackageManagerService的内部类AppDirObserver实现了监听app目录的功能，当把某个APK文件放到app目录下面时，PMS会收到ADD_EVENTS事件。如果是添加事件，则调用scanPackageLI，并使用updatePermissionsLPw授权；如果是删除事件则调用removePackageLI移除该apk的相关信息。最后都要调用writeLPr重新保存相关信息到packages.xml。 关于AppDirObserver具体如何监听的，可以查看：AppDirObserver 不过我在android 7.0 sdk里面没有看到这个类，难道7.0把这个功能砍了？手头没有7.0平台，不好验证。 我猜测现在通过adb push apk到data/app或者system/app的apk，如果这个监听的功能砍了，那么应该是会通过reboot重启系统，走PMS.main流程，scanDir–&gt;scanPackageLI去安装apk。 以上待填坑。 六、adb installadb install 的安装方式，会调用system/core/adb/commandline.cpp中的adb_commandline函数：12345adb_commandline install_app_legacy or install_app pm_command send_shell_command Pm.runInstall() 这个过程会把apk文件copy到data/local/tmp/目录下，然后向shell服务发送pm命令安装apk，最后调用Pm.runInstall()方法来安装apk。 6.1 pm.runInstallframeworks\\base\\cmds\\pm\\src\\com\\android\\commands\\pm\\Pm.java123456789101112131415161718192021222324252627282930private int runInstall() throws RemoteException &#123; final InstallParams params = makeInstallParams(); // 1. 创建session final int sessionId = doCreateSession(params.sessionParams, params.installerPackageName, params.userId); try &#123; final String inPath = nextArg(); if (inPath == null &amp;&amp; params.sessionParams.sizeBytes == 0) &#123; System.err.println(&quot;Error: must either specify a package size or an APK file&quot;); return 1; &#125; // 2. 写session if (doWriteSession(sessionId, inPath, params.sessionParams.sizeBytes, &quot;base.apk&quot;, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; // 3. 提交Session if (doCommitSession(sessionId, false /*logSuccess*/) != PackageInstaller.STATUS_SUCCESS) &#123; return 1; &#125; System.out.println(&quot;Success&quot;); return 0; &#125; finally &#123; try &#123; mInstaller.abandonSession(sessionId); &#125; catch (Exception ignore) &#123; &#125; &#125;&#125; 从上面的代码来看，runInstall主要进行了三件事，即创建session、对session进行写操作，最后提交session。 6.1.1 doCreateSession实际调用的是PackageInstallerService的createSession，这个过程主要是为APK安装做好准备工作，例如权限检查、目的临时文件的创建等， 最终创建出PackageInstallerSession对象。PackageInstallerSession可以看做是”安装APK”这个请求的封装，其中包含了处理这个请求需要的一些信息。实际上PackageInstallerSession不仅是分装请求的对象，其自身还是个服务端。 6.1.2 doWriteSession通过PackageInstallerSession将/data/local/tmp的apk拷贝到终端目录内。 6.1.3 doCommitSessiondoWriteSession结束后，如果没有出现任何错误，那么APK源文件已经copy到目的地址了，doCommitSession最终会调用到PMS.installStage来安装apk，调用流程如下： 1PackageInstallerSession.commit ==&gt; commitLocked(); ==&gt; PMS.installStage() PMS.installStage()会调用sendMessage将”INIT_COPY”发送给PackageHandler： 12345678910111213141516171819202122232425262728293031void installStage(String packageName, File stagedDir, String stagedCid, IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams, String installerPackageName, int installerUid, UserHandle user, Certificate[][] certificates) &#123; if (DEBUG_EPHEMERAL) &#123; if ((sessionParams.installFlags &amp; PackageManager.INSTALL_EPHEMERAL) != 0) &#123; Slog.d(TAG, &quot;Ephemeral install of &quot; + packageName); &#125; &#125; final VerificationInfo verificationInfo = new VerificationInfo( sessionParams.originatingUri, sessionParams.referrerUri, sessionParams.originatingUid, installerUid); final OriginInfo origin; if (stagedDir != null) &#123; origin = OriginInfo.fromStagedFile(stagedDir); &#125; else &#123; origin = OriginInfo.fromStagedContainer(stagedCid); &#125; final Message msg = mHandler.obtainMessage(INIT_COPY); final InstallParams params = new InstallParams(origin, null, observer, sessionParams.installFlags, installerPackageName, sessionParams.volumeUuid, verificationInfo, user, sessionParams.abiOverride, sessionParams.grantedRuntimePermissions, certificates); params.setTraceMethod(&quot;installStage&quot;).setTraceCookie(System.identityHashCode(params)); msg.obj = params; Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installStage&quot;, System.identityHashCode(msg.obj)); Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;queueInstall&quot;, System.identityHashCode(msg.obj)); mHandler.sendMessage(msg);&#125; PackageHandler用于处理apk的安装请求等消息，后面分析。 七、ApplicationPackageManager网络下载应用安装或者通过第三方应用安装，最终都会通过ApplicationPackageManager.installPackage来安装： 12345678910111213141516171819public void installPackage(Uri packageURI, PackageInstallObserver observer, int flags, String installerPackageName) &#123; installCommon(packageURI, observer, flags, installerPackageName, mContext.getUserId()); &#125;private void installCommon(Uri packageURI, PackageInstallObserver observer, int flags, String installerPackageName, int userId) &#123; if (!&quot;file&quot;.equals(packageURI.getScheme())) &#123; throw new UnsupportedOperationException(&quot;Only file:// URIs are supported&quot;); &#125; final String originPath = packageURI.getPath(); try &#123; // PMS.installPackageAsUser mPM.installPackageAsUser(originPath, observer.getBinder(), flags, installerPackageName, userId); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; PMS.installPackageAsUser调用sendMessage将”INIT_COPY”发送给PackageHandler: 12345678910111213141516@Overridepublic void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, int userId) &#123; ... final Message msg = mHandler.obtainMessage(INIT_COPY); final VerificationInfo verificationInfo = new VerificationInfo( null /*originatingUri*/, null /*referrer*/, -1 /*originatingUid*/, callingUid); final InstallParams params = new InstallParams(origin, null /*moveInfo*/, observer, installFlags, installerPackageName, null /*volumeUuid*/, verificationInfo, user, null /*packageAbiOverride*/, null /*grantedPermissions*/, null /*certificates*/); params.setTraceMethod(&quot;installAsUser&quot;).setTraceCookie(System.identityHashCode(params)); msg.obj = params; mHandler.sendMessage(msg); ....&#125; PackageHandler用于处理apk的安装请求等消息，后面分析。 八、PackageHanlder PMS.installStage()会调用sendMessage将”INIT_COPY”发送给PackageHandler PMS.installPackageAsUser调用sendMessage将”INIT_COPY”发送给PackageHandler 8.1 INIT_COPYPackageHandler用于处理apk的安装请求等消息，在PMS构造函数中有初始化。实际处理消息的函数为doHandleMessage，我们来看看INIT_COPY的处理流程：12345678910111213141516171819202122232425262728293031323334353637383940class PackageHandler extends Handler &#123; ... void doHandleMessage(Message msg) &#123; switch (msg.what) &#123; case INIT_COPY: &#123; //这里取出的其实就是InstallParams HandlerParams params = (HandlerParams) msg.obj; //idx为当前等待处理处理的安装请求的个数 int idx = mPendingInstalls.size(); ............ //初始时，mBound的值为false if (!mBound) &#123; ............ // If this is the only one pending we might // have to bind to the service again. //连接安装服务 if (!connectToService()) &#123; .................. &#125; else &#123; // Once we bind to the service, the first // pending request will be processed. //绑定服务成功后，将新的请求加入到mPendingIntalls中，等待处理 mPendingInstalls.add(idx, params); &#125; &#125; else &#123; //如果之前已经绑定过服务，同样将新的请求加入到mPendingIntalls中，等待处理 mPendingInstalls.add(idx, params); // Already bound to the service. Just make // sure we trigger off processing the first request. if (idx == 0) &#123; //如果是第一个请求，则直接发送事件MCS_BOUND，触发处理流程 mHandler.sendEmptyMessage(MCS_BOUND); &#125; &#125; break; &#125; &#125; &#125; ...&#125; INIT_COPY主要是将新的请求加入到mPendingIntalls中，等待MCS_BOUND阶段处理。 8.2 MCS_BOUNDINIT_COPY最后会发送MCS_BOUND消息触发接下来的流程，MCS_BOUND对应的处理流程同样定义于doHandleMessage中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void doHandleMessage(Message msg) &#123; ....... case MCS_BOUND: &#123; ........ if (msg.obj != null) &#123; mContainerService = (IMediaContainerService) msg.obj; ....... &#125; if (mContainerService == null) &#123; if (!mBound) &#123; // Something seriously wrong since we are not bound and we are not // waiting for connection. Bail out. ............ &#125; else &#123; Slog.w(TAG, &quot;Waiting to connect to media container service&quot;); &#125; // 请求队列mPendingInstalls不为空 &#125; else if (mPendingInstalls.size() &gt; 0) &#123; HandlerParams params = mPendingInstalls.get(0); if (params != null) &#123; ........ //调用参数的startCopy函数处理安装请求 if (params.startCopy()) &#123; ........ // Delete pending install if (mPendingInstalls.size() &gt; 0) &#123; mPendingInstalls.remove(0); &#125; if (mPendingInstalls.size() == 0) &#123; if (mBound) &#123; .......... removeMessages(MCS_UNBIND); Message ubmsg = obtainMessage(MCS_UNBIND); // Unbind after a little delay, to avoid // continual thrashing. sendMessageDelayed(ubmsg, 10000); &#125; &#125; else &#123; // There are more pending requests in queue. // Just post MCS_BOUND message to trigger processing // of next pending install. ...... mHandler.sendEmptyMessage(MCS_BOUND); &#125; &#125; ......... &#125; &#125; else &#123; // Should never happen ideally. Slog.w(TAG, &quot;Empty queue&quot;); &#125; break; &#125;.......&#125; 如果mPendingInstalls不为空，调用InstallParams.startCopy函数处理安装请求。 接着如果mPendingInstalls不为空，发送MCS_BOUND继续处理下一个，直到队列为空。 如果队列为空，则等待一段时间后，发送MCS_UNBIND消息断开与安装服务的绑定。 九、startCopy1/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java InstallParams继承HandlerParams，实际调用的是HandlerParams.startCopy:123456789101112131415161718192021222324final boolean startCopy() &#123; boolean res; try &#123; if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this); if (++mRetries &gt; MAX_RETRIES) &#123; Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;); mHandler.sendEmptyMessage(MCS_GIVE_UP); handleServiceError(); return false; &#125; else &#123; // 调用handleStartCopy()处理 handleStartCopy(); Slog.i(TAG, &quot;Apk copy done&quot;); res = true; &#125; &#125; catch (RemoteException e) &#123; if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;); mHandler.sendEmptyMessage(MCS_RECONNECT); res = false; &#125; // handleReturnCode(); return res;&#125; PMS将先后调用handleStartCopy和handleReturnCode来完成主要的工作。 9.1 handleStartCopyhandleStartCopy函数在HandleParams抽象类定义，在其子类InstallParams来实现，我们看看与实际安装相关的handleStartCopy函数： 1234567891011121314151617181920212223242526272829303132333435363738ublic void handleStartCopy() throws RemoteException &#123; int ret = PackageManager.INSTALL_SUCCEEDED; // 决定是安装在手机内还是sdcard中，设置对应标志位 if (origin.staged) &#123; if (origin.file != null) &#123; installFlags |= PackageManager.INSTALL_INTERNAL; installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL; &#125; else if (origin.cid != null) &#123; installFlags |= PackageManager.INSTALL_EXTERNAL; installFlags &amp;= ~PackageManager.INSTALL_INTERNAL; &#125; else &#123; throw new IllegalStateException(&quot;Invalid stage location&quot;); &#125; &#125; ... // 检查APK的安装位置是否正确 if (onInt &amp;&amp; onSd) &#123; // Check if both bits are set. Slog.w(TAG, &quot;Conflicting flags specified for installing on both internal and external&quot;); ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; &#125; else if (onSd &amp;&amp; ephemeral) &#123; Slog.w(TAG, &quot;Conflicting flags specified for installing ephemeral on external&quot;); ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; &#125; else &#123; ... &#125; ... // createInstallArgs用于创建一个安装参数对象 final InstallArgs args = createInstallArgs(this); if (ret == PackageManager.INSTALL_SUCCEEDED) &#123; ... // 调用InstallArgs的copyApk函数 ret = args.copyApk(mContainerService, true); &#125; &#125; mRet = ret;&#125; InstallParams$handleStartCopy()主要功能是获取安装位置信息以及复制apk到指定位置。抽象类InstallArgs中的copyApk负责复制APK文件，具体实现在子类FileInstallArgs和SdInstallArgs里面。 9.2 handleReturnCodeInstallParams$handleReturnCode()中，调用processPendingInstall方法处理安装：1234567void handleReturnCode() &#123; // If mArgs is null, then MCS couldn&apos;t be reached. When it // reconnects, it will try again to install. At that point, this // will succeed. if (mArgs != null) &#123; processPendingInstall(mArgs, mRet); &#125; 9.3 processPendingInstall主要的安装流程都在这个方法里面: PMS.processPendingInstall123456789101112131415161718192021222324252627282930private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123; mHandler.post(new Runnable() &#123; public void run() &#123; mHandler.removeCallbacks(this); // Result object to be returned PackageInstalledInfo res = new PackageInstalledInfo(); res.setReturnCode(currentStatus); res.uid = -1; res.pkg = null; res.removedInfo = null; if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; //1、预安装，检查包状态，确保环境ok，如果环境不ok，那么会清理拷贝的文件 args.doPreInstall(res.returnCode); synchronized (mInstallLock) &#123; //2、安装，调用installPackageTracedLI进行安装 installPackageTracedLI(args, res); &#125; //3、安装收尾 args.doPostInstall(res.returnCode, res.uid); &#125; if (!doRestore) &#123; ....... //4、生成一个POST_INSTALL消息给PackageHanlder Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0); mHandler.sendMessage(msg); &#125; &#125; &#125;);&#125; 安装过程放在一个线程里面，处理流程是预安装-安装-安装收尾-发送 POST_INSTALL消息： 预安装：检查当前安装包的状态以及确保SDCARD的挂载，并返回状态信息。在安装前确保安装环境的可靠。 安装：对mInstallLock加锁，表明同时只能有一个安装包进行安装；然后调用installPackageTracedLI完成具体安装操作。 安装收尾： 检查状态，如果安装不成功，删除掉相关目录文件。 发送POST_INSTALL消息：该消息由PackageHandler接收。POST_INSTALL的主要工作其实还是通过广播、回调接口通知系统中的其它组件，有新的Pacakge安装或发生了改变。 从上面我们可以知道，具体安装apk的函数是PMS.installPackageTracedLI。 十、installPackageTracedLIPMS.installPackageTracedLI函数：12345678private void installPackageTracedLI(InstallArgs args, PackageInstalledInfo res) &#123; try &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installPackage&quot;); installPackageLI(args, res); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125;&#125; 十一、installPackageLI继续PMS.installPackageLI：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private void installPackageLI(InstallArgs args, PackageInstalledInfo res) &#123; // PackageParser对象 PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setDisplayMetrics(mMetrics); Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;parsePackage&quot;); final PackageParser.Package pkg; try &#123; if (DEBUG_INSTALL) Slog.i(TAG, &quot;Start parsing apk: &quot; + installerPackageName); // 1.开始解析我们的package pkg = pp.parsePackage(tmpPackageFile, parseFlags); if (DEBUG_INSTALL) Slog.i(TAG, &quot;Parsing done for apk: &quot; + installerPackageName); &#125; catch (PackageParserException e) &#123; res.setError(&quot;Failed parse during installPackageLI&quot;, e); return; &#125; finally &#123; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; ... //2. 加载证书，获取签名信息 try &#123; // either use what we&apos;ve been given or parse directly from the APK if (args.certificates != null) &#123; try &#123; PackageParser.populateCertificates(pkg, args.certificates); &#125; catch (PackageParserException e) &#123; PackageParser.collectCertificates(pkg, parseFlags); &#125; &#125; else &#123; PackageParser.collectCertificates(pkg, parseFlags); &#125; &#125; catch (PackageParserException e) &#123; res.setError(&quot;Failed collect during installPackageLI&quot;, e); return; &#125; ... synchronized (mPackages) &#123; // 3.检测packages是否存在 if ((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) &#123; ... replace = true; &#125; else if (mPackages.containsKey(pkgName)) &#123; ... replace = true; if (DEBUG_INSTALL) Slog.d(TAG, &quot;Replace existing pacakge: &quot; + pkgName); &#125; ... &#125; &#125; ... try (PackageFreezer freezer = freezePackageForInstall(pkgName, installFlags, &quot;installPackageLI&quot;)) &#123; if (replace) &#123; // 4.更新已经存在的packages replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res); &#125; else &#123; // 5.安装新的packages installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, volumeUuid, res); &#125; &#125;...&#125; 这个函数过程比较长，主要做了几件事： PackageParser$parsePackage，主要是解析APK的AndroidManifest.xml，将每个标签对应的信息添加到Package的相关列表中，如将下的信息添加到Package的activities列表等。 加载apk证书，获取签名信息 检查目前安装的APK是否在系统中已存在: 已存在，则调用replacePackageLIF进行替换安装。 不存在，否则调用installNewPackageLIF进行安装。 11.1 replacePackageLIF如果需要替换的是系统APP，则调用Settings$disableSystemPackageLPw来disable旧的APK；如果替换的是非系统APP，则调用deletePackageLI删除旧的APK。 因为这个过程实在太差，没有必要贴出来一一分析，我来简化一下flow，有兴趣的读者可以深入跟进：123456789101112131415161718192021replacePackageLIF replaceSystemPackageLIF // 系统 pkg removePackageLI disableSystemPackageLPw clearAppDataLIF scanPackageTracedLI //安装apk scanPackageLI scanPackageDirtyLI updateSettingsLI updatePermissionsLPw mSettings.writeLPr(); replaceNonSystemPackageLIF // 非系统 pkg deletePackageLIF clearAppDataLIF clearAppProfilesLIF scanPackageTracedLI // 安装apk scanPackageLI scanPackageDirtyLI updateSettingsLI updatePermissionsLPw mSettings.writeLPr(); 不管是更新系统还是非系统apk，都会先清除之前的packages信息，然后通过scanPackageTracedLI去安装apk，安装完后更新permissions和setting，最后通过writeLPr更新packages.xml。 关于scanPackageTracedLI和Settings.writeLPr();我有在上一篇blog讲过，可以回去看看。 11.2 installNewPackageLIFPMS.installNewPackageLIF用于安装新的apk：123456789101112131415161718192021222324252627282930313233343536373839404142434445private void installNewPackageLIF(PackageParser.Package pkg, final int policyFlags, int scanFlags, UserHandle user, String installerPackageName, String volumeUuid, PackageInstalledInfo res) &#123; Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installNewPackage&quot;); // Remember this for later, in case we need to rollback this install String pkgName = pkg.packageName; if (DEBUG_INSTALL) Slog.d(TAG, &quot;installNewPackageLI: &quot; + pkg); // package已经存在 synchronized(mPackages) &#123; if (mSettings.mRenamedPackages.containsKey(pkgName)) &#123; // A package with the same name is already installed, though // it has been renamed to an older name. The package we // are trying to install should be installed as an update to // the existing one, but that has not been requested, so bail. res.setError(INSTALL_FAILED_ALREADY_EXISTS, &quot;Attempt to re-install &quot; + pkgName + &quot; without first uninstalling package running as &quot; + mSettings.mRenamedPackages.get(pkgName)); return; &#125; if (mPackages.containsKey(pkgName)) &#123; // Don&apos;t allow installation over an existing package with the same name. res.setError(INSTALL_FAILED_ALREADY_EXISTS, &quot;Attempt to re-install &quot; + pkgName + &quot; without first uninstalling.&quot;); return; &#125; &#125; try &#123; // 1. 安装apk PackageParser.Package newPackage = scanPackageTracedLI(pkg, policyFlags, scanFlags, System.currentTimeMillis(), user); // 2. 更新setting updateSettingsLI(newPackage, installerPackageName, null, res, user); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; prepareAppDataAfterInstallLIF(newPackage); &#125; else &#123; // Remove package from internal structures, but keep around any // data that might have already existed deletePackageLIF(pkgName, UserHandle.ALL, false, null, PackageManager.DELETE_KEEP_DATA, res.removedInfo, true, null); &#125; &#125; catch (PackageManagerException e) &#123; res.setError(&quot;Package couldn&apos;t be installed in &quot; + pkg.codePath, e); &#125; Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER); &#125; installNewPackageLIF会调用scanPackageTracedLI去安装apk，最终会调用scanPackageLI-&gt;scanPackageDirtyLI实际去安装apk。","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://langgithub.github.io/tags/Activity/"},{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android源码(2)-Android系统启动流程","slug":"Android源码(2)-Android系统启动流程","date":"2020-06-09T09:29:21.363Z","updated":"2020-06-09T09:29:21.363Z","comments":true,"path":"2020/06/09/Android源码(2)-Android系统启动流程/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android源码(2)-Android系统启动流程/","excerpt":"","text":"一. Loader层 Boot ROM:上电后，BootRom会被激活，引导芯片代码开始从预定义的地方（固化在ROM）开始执行，然后加载引导程序到RAM。 Boot Loader引导程序Boot Loader是启动Android系统之前的引导程序，引导程序是OEM厂商或者运营商加锁和限制的地方，它是针对特定的主板与芯片的。OEM厂商要么使用很受欢迎的引导程序比如redboot、uboot、ARMboot等或者开发自己的引导程序，它不是Android操作系统的一部分。Boot Loader主要作用是检查RAM，初始化硬件参数等功能。 3 Preloader:（1）Preloader是MTK平台独有的防止芯片被Hack的一个loader，MTK平台的bootrom会先加载preloader到SRAM中，preloader会先去初始化一些HW组件，比如通信端口(USB/Uart)，外部存储设备(Emmc or Nand)，内存设备(DRAM Calibration)等，最后会Load LK到DRAM中并且run LK(U-boot)。（2）LK会从外部存储设备load boot image,包括Linux kernel和Ramdisk到DRAM中.最后LK会跳到 Linux Kernel里去执行start kernel.（3）linux kernel会先完成一些初始化动作，mount 根文件系统和启动第一个用户进程(init 进程) 二. kernel层Android内核与linux内核启动的方式差不多。Kernel的启动流程：12alps/kernel/init/main.cstart_kernel() ==&gt; rest_init() ==&gt; kernel_thread(kernel_init) ==&gt; kernel_init() 2.1 rest_init() 1234567891011static noinline void __ref rest_init(void)&#123; ... kernel_thread(kernel_init, NULL, CLONE_FS); pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES); ... init_idle_bootup_task(current); schedule_preempt_disabled(); ... cpu_idle();&#125; rest_init中调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd 调用schedule函数开启了内核的调度系统，从此linux系统开始转起来了。 rest_init最终调用cpu_idle函数结束了整个内核的启动。也就是说linux内核最终结束了一个函数cpu_idle。这个函数里面肯定是死循环。 简单来说，linux内核最终的状态是：有事干的时候去执行有意义的工作（执行各个进程任务），实在没活干的时候就去死循环（实际上死循环也可以看成是一个任务）。 之前已经启动了内核调度系统，调度系统会负责考评系统中所有的进程，这些进程里面只有有哪个需要被运行，调度系统就会终止cpu_idle死循环进程（空闲进程）转而去执行有意义的干活的进程。这样操作系统就转起来了。0号进程：swapper进程(pid=0)：又称为idle进程, 叫空闲进程，由系统自动创建, 运行在内核态。系统初始化过程Kernel由无到有开创的第一个进程, 也是唯一一个没有通过fork或者kernel_thread产生的进程。swapper进程用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作。 1号进程init进程(pid=1)：由0号进程通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 并最终运行在用户空间，init进程是所有用户进程的鼻祖。 2号进程kthreadd进程(pid=2)：由0号进程通过kernel_thread创建，是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd运行在内核空间, 负责所有内核线程的调度和管理 , kthreadd进程是所有内核进程的鼻祖。 2.2 kernel_init()init进程会通过kernel_init创建，这个时候是在内核态，那么怎么一步步进入用户态1kernel_init-&gt;init_post-&gt;run_init_process-&gt;kernel_execve 先是12345678910111213141516static int __init kernel_init(void * unused) &#123; /*Wait until kthreadd is all set-up.*/ wait_for_completion(&amp;kthreadd_done); //主要是初始化设备驱动，完成其他驱动程序（直接编译进内核的模块）的初始化。 do_basic_setup(); //挂载根文件系统 if (sys_open((const char __user *) &quot;/dev/console&quot;, O_RDWR, 0) &lt; 0) printk(KERN_WARNING &quot;Warning: unable to open an initial console.\\n&quot;); //定义init进程 if (!ramdisk_execute_command) ramdisk_execute_command = &quot;/init&quot;; //最后调用init_post，启动进程负责用户空间的初始化 init_post(); &#125; 接下来是123456789101112131415static noinline int init_post(void) &#123; ……//省略部分代码 if (ramdisk_execute_command) &#123; //run_init_process执行后将不再返回 run_init_process(ramdisk_execute_command); &#125; if (execute_command) &#123; run_init_process(execute_command); &#125; run_init_process(&quot;/sbin/init&quot;); run_init_process(&quot;/etc/init&quot;); run_init_process(&quot;/bin/init&quot;); run_init_process(&quot;/bin/sh&quot;); &#125; execute_command是bootloader传递给内核的参数，一般是/init（根目录下的init程序），也就是调用文件系统的init进程。如果找不到就会继续寻找“/sbin/init”,“/etc/init”,“/bin/init”,“/bin/sh”,找到后便执行run_init_process,且不再返回。run_init_process的函数体非常简单，仅仅是对kernel_execve函数的封装，代码如下： 12345static void run_init_process(const char *init_filename) &#123; argv_init[0] = init_filename; kernel_execve(init_filename, argv_init, envp_init); &#125; kernel_execve是linux内核中创建用户进程的方法接口，其实现位于1arch/arm/kernel/sys_arm.c 那么至此，我们已经对Android Kernel如何引导以及用户空间1号进程（init进程）如何启动做了详细分析。 三.init进程3.1 init Process这里的native层主要说明init进程，当kernel initialize完成之后，系统会执行第一个用户进程init,我们可以说它是root进程或者所有进程的父进程。init进程相关的代码：123/system/core/init/init.cpp：/system/core/rootdir/init.rc/system/core/init/readme.txt Init进程启动过程就是代码init.cpp中main函数执行过程，我们来看看它做了什么:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146int main(int argc, char** argv) &#123; if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123; return ueventd_main(argc, argv); &#125; if (!strcmp(basename(argv[0]), &quot;watchdogd&quot;)) &#123; return watchdogd_main(argc, argv); &#125; // Clear the umask. umask(0); add_environment(&quot;PATH&quot;, _PATH_DEFPATH); bool is_first_stage = (argc == 1) || (strcmp(argv[1], &quot;--second-stage&quot;) != 0); //挂载tmpfs, devpts, proc, sysfs文件系统 if (is_first_stage) &#123; mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;); mkdir(&quot;/dev/pts&quot;, 0755); mkdir(&quot;/dev/socket&quot;, 0755); mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL); #define MAKE_STR(x) __STRING(x) mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC)); mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL); &#125; // We must have some place other than / to create the device nodes for // kmsg and null, otherwise we won&apos;t be able to remount / read-only // later on. Now that tmpfs is mounted on /dev, we can actually talk // to the outside world. //屏蔽标准的输入输出，即标准的输入输出定向到NULL设备。 open_devnull_stdio(); //kernel log初始化 klog_init(); klog_set_level(KLOG_NOTICE_LEVEL); NOTICE(&quot;init %s started!\\n&quot;, is_first_stage ? &quot;first stage&quot; : &quot;second stage&quot;); if (!is_first_stage) &#123; // Indicate that booting is in progress to background fw loaders, etc. close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); //创建一块共享的内存空间，用于属性服务 property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. //设置基本属性 process_kernel_dt(); process_kernel_cmdline(); // Propagate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props(); &#125; // Set up SELinux, including loading the SELinux policy if we&apos;re in the kernel domain. // 加载SELinux selinux_initialize(is_first_stage); // If we&apos;re in the kernel domain, re-exec init to transition to the init domain now // that the SELinux policy has been loaded. if (is_first_stage) &#123; if (restorecon(&quot;/init&quot;) == -1) &#123; ERROR(&quot;restorecon failed: %s\\n&quot;, strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(&quot;--second-stage&quot;), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR(&quot;execv(\\&quot;%s\\&quot;) failed: %s\\n&quot;, path, strerror(errno)); security_failure(); &#125; &#125; // These directories were necessarily created before initial policy load // and therefore need their security context restored to the proper value. // This must happen before /dev is populated by ueventd. NOTICE(&quot;Running restorecon...\\n&quot;); restorecon(&quot;/dev&quot;); restorecon(&quot;/dev/socket&quot;); restorecon(&quot;/dev/__properties__&quot;); restorecon(&quot;/property_contexts&quot;); restorecon_recursive(&quot;/sys&quot;); epoll_fd = epoll_create1(EPOLL_CLOEXEC); if (epoll_fd == -1) &#123; ERROR(&quot;epoll_create1 failed: %s\\n&quot;, strerror(errno)); exit(1); &#125; //初始化子进程退出的信号处理过程 signal_handler_init(); //加载/default.prop文件 property_load_boot_defaults(); export_oem_lock_status(); //启动属性服务 start_property_service(); const BuiltinFunctionMap function_map; Action::set_function_map(&amp;function_map); // 添加解service, on, import 解析器 Parser&amp; parser = Parser::GetInstance(); parser.AddSectionParser(&quot;service&quot;,std::make_unique&lt;ServiceParser&gt;()); parser.AddSectionParser(&quot;on&quot;, std::make_unique&lt;ActionParser&gt;()); parser.AddSectionParser(&quot;import&quot;, std::make_unique&lt;ImportParser&gt;()); // 解析init rc文件 parser.ParseConfig(&quot;/init.rc&quot;); ActionManager&amp; am = ActionManager::GetInstance(); //执行rc文件中触发器为 on early-init的语句 am.QueueEventTrigger(&quot;early-init&quot;); //创建wait_for_coldboot_done 动作并添加到action vector和trigger_queue_中 am.QueueBuiltinAction(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;); am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;); am.QueueBuiltinAction(set_mmap_rnd_bits_action, &quot;set_mmap_rnd_bits&quot;); am.QueueBuiltinAction(keychord_init_action, &quot;keychord_init&quot;); am.QueueBuiltinAction(console_init_action, &quot;console_init&quot;); //执行rc文件中触发器为 on init的语句 // Trigger all the boot actions to get us started. am.QueueEventTrigger(&quot;init&quot;); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn&apos;t ready immediately after wait_for_coldboot_done am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;); // Don&apos;t mount filesystems or start core system services in charger mode. std::string bootmode = property_get(&quot;ro.bootmode&quot;); if (bootmode == &quot;charger&quot;) &#123; //充电模式下，执行rc文件中触发器为charger的语句 am.QueueEventTrigger(&quot;charger&quot;); &#125; else &#123; //非充电模式下，执行rc文件中触发器为late-init的语句 am.QueueEventTrigger(&quot;late-init&quot;); &#125; // Run all property triggers based on current state of the properties. // 创建queue_property_triggers动作并且添加到action vector和trigger_queue_中 am.QueueBuiltinAction(queue_property_triggers_action, &quot;queue_property_triggers&quot;); while (true) &#123; if (!waiting_for_exec) &#123; am.ExecuteOneCommand(); // 重启一些关键进程 restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (am.HasMoreCommands()) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; //循环 等待事件发生 int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(&quot;epoll_wait failed: %s\\n&quot;, strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125; &#125; return 0;&#125; 可以看到，init进程主要完成以下功能: 是挂载tmpfs,devpts,proc,sysfs文件系统 加载解析命令 Action,service 运行init.rc脚步，init将会解析init.rc，并且执行init.rc中的命令 当一些关键进程死亡，重启该进程 提供Android系统属性服务 3.2 文件系统简介 tmpfstmpfs是一种虚拟内存文件系统，因此它会将所有的文件存储在虚拟内存中，并且tmpfs下的所有内容均为临时性的内容，如果你将tmpfs文件系统卸载后，那么它下面的内存将不复存在，tmpfs是一个独立的文件系统，不是块设备，只要挂接，立即可以使用 devptsdevpts文件系统为伪终端提供的一个标准接口，它的标准挂接点/dev/pts.只要pts的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态创建一个新的pty设备文件 proc文件系统proc文件系统是一个非常重要的虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统信息，同时也能够在运行时修改特定的内核参数 sysfs文件系统与proc文件系统类似，sysfs文件系统也是一个不占任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。sysfs文件系统是Linux2.6内核引入的，它把链接在系统上的设备和总线组织成为一个分级的文件，使得它们可以在用户空间存取 四.init.rc文件和语法init.rc文件语法是以行为单位，以空格间隔的语法，以#开始代表注释行。rc文件主要包含Action,Service,Command,Option,其中对于Action和Service的名称都是唯一的，对于重复的命令视为无效 4.1 动作ActionAction：通过trigger，即以on开头的语句，决定何时执行相关service on early-init,在初始化早起阶段触发 on init;在初始化阶段触发 on late-init;在初始化晚期阶段触发 on boot/charger;当系统启动/充电时触发，还包含其他情况 on property=；当属性值满足条件触发 4.2 服务Servcie服务Service，以service开头，由init进程启动，一般运行于另外一个init进程，所以启动Service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service，在启动时会fork方式生成子进程 4.3 命令Command下面列举常用的命令 class_start ： 启动属于同一个class的所有服务； start ： 启动指定的服务，若已启动则跳过； stop ： 停止正在运行的服务 setprop ：设置属性值 mkdir ：创建指定目录 symlink ： 创建连接到的符号链接； write ： 向文件path中写入字符串； exec： fork并执行，会阻塞init进程直到程序完毕； exprot ：设定环境变量； loglevel ：设置log级别 4.4 可选操作OptionOptions是Services的可选项，与service配合使用 disabled: 不随class自动启动，只有根据service名才启动； oneshot: service退出后不再重启； user/group： 设置执行服务的用户/用户组，默认都是root； class：设置所属的类名，当所属类启动/退出时，服务也启动/停止，默认为default； onrestart:当服务重启时执行相应命令； socket: 创建名为/dev/socket/的socket critical: 在规定时间内该service不断重启，则系统会重启并进入恢复模式 *default: 意味着disabled=false，oneshot=false，critical=false。 所有的Service里面只有servicemanager ，zygote ，surfaceflinger这3个service有onrestart关键字来触发其他service启动过程。 五.Daemon守护进程init.rc会启动一些daemon进程，比如ueventd,adbd,servicemaager,vold,netd,debuggerd等1234567891011121314151617181920212223242526272829303132333435363738service ueventd /sbin/ueventd class core critical service console /system/bin/sh class core console disabled user shell group log service adbd /sbin/adbd class core disabled service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm service vold /system/bin/vold class core socket vold stream 0660 root mount ioprio be 2 service netd /system/bin/netd class main socket netd stream 0660 root system socket dnsproxyd stream 0660 root inet socket mdns stream 0660 root system service debuggerd /system/bin/debuggerd class main 六. ServiceMnagerServiceManager也是守护进程，它是Android大管家，是一个很重要的服务1234567891011//servicemanager可触发healthd、zygote、media、surfaceflinger、drm重启service servicemanager /system/bin/servicemanager class core user system group system critical onrestart restart healthd onrestart restart zygote onrestart restart media onrestart restart surfaceflinger onrestart restart drm service servicemanager /system/bin/servicemanager表示服务名为servicemanager，服务运行的时候会执行/system/bin/servicemanager 七.ZygoteZygote是第一个Java进程，并且是所有java进程的父进程，在init.zygote32.rc文件中，zygote服务启动如下12345678//zygote可触发media、netd重启service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd Zygote入口和相关类：123456/frameworks/base/cmds/app_process/App_main.cpp （内含AppRuntime类）/frameworks/base/core/jni/AndroidRuntime.cpp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java/frameworks/base/core/java/com/android/internal/os/Zygote.java/frameworks/base/core/java/android/net/LocalServerSocket.java/system/core/libutils/Threads.cpp 解释下第一行参数： zygote:服务名 systen/bin/app_process:zygote所对应的可执行文件，通过pid=fork()创建子进程 剩下的四个参数是zygote进程的启动参数，其中最后一个参数 –start-system-server是表示zygote进程启动完成后，马上将system进程启动启动 zygote启动过程调用堆栈：123456789App_main.main() AndroidRuntime.start() StartVM() StartReg() ZygoteInit.main() ResgisterZygoteSocket() preload() startSystemServer() runSelectLoop() zygote进程的主要工作如下： 解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法 调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数 通过JNI方法调用ZygoteInit.main(),进入第一个java世界 （frameworks/base/core/java/com/android/internal/os/ZygoteInit.java：） registerZygoteSocket()建立通道，zygote作为通讯的服务端，用于响应客户请求 preload（）预加载通用类，drawable和color资源，openGL以及共享库webView，提高ap启动效率 zygote完成大部分工作，接下来再通过startSystemServer(),fork得力帮手system_server进程，也是上层framework的运行载体（frameworks/base/services/java/com/android/server/SystemServer.java） zygote功成身退，调用runSelectLoop(),随时待命，当接受到请求创建新进程请求时立即唤醒并执行相应工作 八.system_server上面提到Zygote启动过程会调用startSystemserver(),可知startSystemServer()函数是system_server启动流程的起点，system_server相关函数如下：123456789/frameworks/base/core/java/android/app/ActivityThread.java/frameworks/base/core/java/android/app/LoadedApk.java/frameworks/base/core/java/android/app/ContextImpl.java/frameworks/base/core/java/com/android/server/LocalServices.java/frameworks/base/services/java/com/android/server/SystemServer.java/frameworks/base/services/core/java/com/android/server/SystemServiceManager.java/frameworks/base/services/core/java/com/android/server/ServiceThread.java/frameworks/base/services/core/java/com/android/server/pm/Installer.java/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 启动流程图如下： 进入到SystemServer.main后，调用堆栈如下：123456789101112SystemServer.main SystemServer.run createSystemContext ActivityThread.systemMain ActivityThread.attach LoadedApk.makeApplication ActivityThread.getSystemContext ContextImpl.createSystemContext startBootstrapServices();//启动引导服务 startCoreServices(); // 启动核心服务 startOtherServices(); // 启动其他服务 Looper.loop(); system_server最主要的工作就是启动系统服务。通过startBootstrapServices(),startCoreServices(),startOtherServices()3个方法 【注意：版本4.4.1 的代码如下】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341public void initAndLoop() &#123; ··· // bootstrap services boolean onlyCore = false; boolean firstBoot = false; try &#123; // Wait for installd to finished starting up so that it has a chance to // create critical directories such as /data/user with the appropriate // permissions. We need this to complete before we initialize other services. Slog.i(TAG, &quot;Waiting for installd to be ready.&quot;); installer = new Installer(); installer.ping(); Slog.i(TAG, &quot;Power Manager&quot;); power = new PowerManagerService(); ServiceManager.addService(Context.POWER_SERVICE, power); Slog.i(TAG, &quot;Activity Manager&quot;); context = ActivityManagerService.main(factoryTest); &#125; catch (RuntimeException e) &#123; Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting bootstrap service&quot;, e); &#125; ··· try &#123; Slog.i(TAG, &quot;Display Manager&quot;); display = new DisplayManagerService(context, wmHandler); ServiceManager.addService(Context.DISPLAY_SERVICE, display, true); Slog.i(TAG, &quot;Telephony Registry&quot;); telephonyRegistry = new TelephonyRegistry(context); ServiceManager.addService(&quot;telephony.registry&quot;, telephonyRegistry); Slog.i(TAG, &quot;Scheduling Policy&quot;); ServiceManager.addService(&quot;scheduling_policy&quot;, new SchedulingPolicyService()); AttributeCache.init(context); if (!display.waitForDefaultDisplay()) &#123; reportWtf(&quot;Timeout waiting for default display to be initialized.&quot;, new Throwable()); &#125; Slog.i(TAG, &quot;Package Manager&quot;); // Only run &quot;core&quot; apps if we&apos;re encrypting the device. String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) &#123; Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;); onlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;); onlyCore = true; &#125; pm = PackageManagerService.main(context, installer, factoryTest != SystemServer.FACTORY_TEST_OFF, onlyCore); try &#123; firstBoot = pm.isFirstBoot(); &#125; catch (RemoteException e) &#123; &#125; ActivityManagerService.setSystemProcess(); Slog.i(TAG, &quot;Entropy Mixer&quot;); ServiceManager.addService(&quot;entropy&quot;, new EntropyMixer(context)); Slog.i(TAG, &quot;User Service&quot;); ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); mContentResolver = context.getContentResolver(); // The AccountManager must come before the ContentService try &#123; // TODO: seems like this should be disable-able, but req&apos;d by ContentService Slog.i(TAG, &quot;Account Manager&quot;); accountManager = new AccountManagerService(context); ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager); &#125; catch (Throwable e) &#123; Slog.e(TAG, &quot;Failure starting Account Manager&quot;, e); &#125; Slog.i(TAG, &quot;Content Manager&quot;); contentService = ContentService.main(context, factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL); Slog.i(TAG, &quot;System Content Providers&quot;); ActivityManagerService.installSystemProviders(); Slog.i(TAG, &quot;Lights Service&quot;); lights = new LightsService(context); Slog.i(TAG, &quot;Battery Service&quot;); battery = new BatteryService(context, lights); ServiceManager.addService(&quot;battery&quot;, battery); Slog.i(TAG, &quot;Vibrator Service&quot;); vibrator = new VibratorService(context); ServiceManager.addService(&quot;vibrator&quot;, vibrator); Slog.i(TAG, &quot;Consumer IR Service&quot;); consumerIr = new ConsumerIrService(context); ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr); // only initialize the power service after we have started the // lights service, content providers and the battery service. power.init(context, lights, ActivityManagerService.self(), battery, BatteryStatsService.getService(), ActivityManagerService.self().getAppOpsService(), display); Slog.i(TAG, &quot;Alarm Manager&quot;); alarm = new AlarmManagerService(context); ServiceManager.addService(Context.ALARM_SERVICE, alarm); Slog.i(TAG, &quot;Init Watchdog&quot;); Watchdog.getInstance().init(context, battery, power, alarm, ActivityManagerService.self()); Watchdog.getInstance().addThread(wmHandler, &quot;WindowManager thread&quot;); Slog.i(TAG, &quot;Input Manager&quot;); inputManager = new InputManagerService(context, wmHandler); Slog.i(TAG, &quot;Window Manager&quot;); wm = WindowManagerService.main(context, power, display, inputManager, wmHandler, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL, !firstBoot, onlyCore); ServiceManager.addService(Context.WINDOW_SERVICE, wm); ServiceManager.addService(Context.INPUT_SERVICE, inputManager); ActivityManagerService.self().setWindowManager(wm); inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); inputManager.start(); display.setWindowManager(wm); display.setInputManager(inputManager); // Skip Bluetooth if we have an emulator kernel // TODO: Use a more reliable check to see if this product should // support Bluetooth - see bug 988521 if (SystemProperties.get(&quot;ro.kernel.qemu&quot;).equals(&quot;1&quot;)) &#123; Slog.i(TAG, &quot;No Bluetooh Service (emulator)&quot;); &#125; else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) &#123; Slog.i(TAG, &quot;No Bluetooth Service (factory test)&quot;); &#125; else if (!context.getPackageManager().hasSystemFeature (PackageManager.FEATURE_BLUETOOTH)) &#123; Slog.i(TAG, &quot;No Bluetooth Service (Bluetooth Hardware Not Present)&quot;); &#125; else if (disableBluetooth) &#123; Slog.i(TAG, &quot;Bluetooth Service disabled by config&quot;); &#125; else &#123; Slog.i(TAG, &quot;Bluetooth Manager Service&quot;); bluetooth = new BluetoothManagerService(context); ServiceManager.addService(BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE, bluetooth); &#125; &#125; catch (RuntimeException e) &#123; Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting core service&quot;, e); &#125; DevicePolicyManagerService devicePolicy = null; StatusBarManagerService statusBar = null; InputMethodManagerService imm = null; AppWidgetService appWidget = null; NotificationManagerService notification = null; WallpaperManagerService wallpaper = null; LocationManagerService location = null; CountryDetectorService countryDetector = null; TextServicesManagerService tsms = null; LockSettingsService lockSettings = null; DreamManagerService dreamy = null; AssetAtlasService atlas = null; PrintManagerService printManager = null; MediaRouterService mediaRouter = null; // We now tell the activity manager it is okay to run third party // code. It will call back into us once it has gotten to the state // where third party code can really run (but before it has actually // started launching the initial applications), for us to complete our // initialization. ActivityManagerService.self().systemReady(new Runnable() &#123; public void run() &#123; Slog.i(TAG, &quot;Making services ready&quot;); try &#123; ActivityManagerService.self().startObservingNativeCrashes(); &#125; catch (Throwable e) &#123; reportWtf(&quot;observing native crashes&quot;, e); &#125; if (!headless) &#123; startSystemUi(contextF); &#125; try &#123; if (mountServiceF != null) mountServiceF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making Mount Service ready&quot;, e); &#125; try &#123; if (batteryF != null) batteryF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making Battery Service ready&quot;, e); &#125; try &#123; if (networkManagementF != null) networkManagementF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making Network Managment Service ready&quot;, e); &#125; try &#123; if (networkStatsF != null) networkStatsF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making Network Stats Service ready&quot;, e); &#125; try &#123; if (networkPolicyF != null) networkPolicyF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making Network Policy Service ready&quot;, e); &#125; try &#123; if (connectivityF != null) connectivityF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making Connectivity Service ready&quot;, e); &#125; try &#123; if (dockF != null) dockF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making Dock Service ready&quot;, e); &#125; try &#123; if (usbF != null) usbF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making USB Service ready&quot;, e); &#125; try &#123; if (twilightF != null) twilightF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;makin Twilight Service ready&quot;, e); &#125; try &#123; if (uiModeF != null) uiModeF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making UI Mode Service ready&quot;, e); &#125; try &#123; if (recognitionF != null) recognitionF.systemReady(); &#125; catch (Throwable e) &#123; reportWtf(&quot;making Recognition Service ready&quot;, e); &#125; Watchdog.getInstance().start(); // It is now okay to let the various system services start their // third party code... try &#123; if (appWidgetF != null) appWidgetF.systemRunning(safeMode); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying AppWidgetService running&quot;, e); &#125; try &#123; if (wallpaperF != null) wallpaperF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying WallpaperService running&quot;, e); &#125; try &#123; if (immF != null) immF.systemRunning(statusBarF); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying InputMethodService running&quot;, e); &#125; try &#123; if (locationF != null) locationF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying Location Service running&quot;, e); &#125; try &#123; if (countryDetectorF != null) countryDetectorF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying CountryDetectorService running&quot;, e); &#125; try &#123; if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying NetworkTimeService running&quot;, e); &#125; try &#123; if (commonTimeMgmtServiceF != null) commonTimeMgmtServiceF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying CommonTimeManagementService running&quot;, e); &#125; try &#123; if (textServiceManagerServiceF != null) textServiceManagerServiceF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying TextServicesManagerService running&quot;, e); &#125; try &#123; if (dreamyF != null) dreamyF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying DreamManagerService running&quot;, e); &#125; try &#123; if (atlasF != null) atlasF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying AssetAtlasService running&quot;, e); &#125; try &#123; // TODO(BT) Pass parameter to input manager if (inputManagerF != null) inputManagerF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying InputManagerService running&quot;, e); &#125; try &#123; if (telephonyRegistryF != null) telephonyRegistryF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying TelephonyRegistry running&quot;, e); &#125; try &#123; if (printManagerF != null) printManagerF.systemRuning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying PrintManagerService running&quot;, e); &#125; try &#123; if (mediaRouterF != null) mediaRouterF.systemRunning(); &#125; catch (Throwable e) &#123; reportWtf(&quot;Notifying MediaRouterService running&quot;, e); &#125; &#125; &#125;); ··· // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;); &#125; Looper.loop(); Slog.d(TAG, &quot;System ServerThread is exiting!&quot;); &#125; 8.1 startBootstrapServices()[SystemServer.java]启动引导服务1234567891011121314151617181920212223242526272829303132333435363738private void startBootstrapServices() &#123; //阻塞等待与installd建立socket通道 Installer installer = mSystemServiceManager.startService(Installer.class); //启动服务ActivityManagerService mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); //启动服务PowerManagerService mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); //初始化power management mActivityManagerService.initPowerManagement(); //启动服务LightsService mSystemServiceManager.startService(LightsService.class); //启动服务DisplayManagerService mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); //Phase100: 在初始化package manager之前，需要默认的显示. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); //当设备正在加密时，仅运行核心 String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) &#123; mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; mOnlyCore = true; &#125; //启动服务PackageManagerService mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); //启动服务UserManagerService，新建目录/data/user/ ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); AttributeCache.init(mSystemContext); //设置AMS mActivityManagerService.setSystemProcess(); //启动传感器服务 startSensorService();&#125; 8.2 startCoreServices()[ SystemServer.java ] 启动核心服务1234567891011private void startCoreServices() &#123; //启动服务BatteryService，用于统计电池电量，需要LightService. mSystemServiceManager.startService(BatteryService.class); //启动服务UsageStatsService，用于统计应用使用情况 mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); //启动服务WebViewUpdateService mSystemServiceManager.startService(WebViewUpdateService.class);&#125; 启动服务BatteryService，UsageStatsService，WebViewUpdateService 8.3 startOtherServices()[ SystemServer.java ] 启动其他服务 1234567891011121314151617181920212223242526272829303132333435private void startOtherServices() &#123; ... SystemConfig.getInstance(); mContentResolver = context.getContentResolver(); // resolver ... mActivityManagerService.installSystemProviders(); //provider mSystemServiceManager.startService(AlarmManagerService.class); // alarm // watchdog watchdog.init(context, mActivityManagerService); inputManager = new InputManagerService(context); // input wm = WindowManagerService.main(...); // window inputManager.start(); //启动input mDisplayManagerService.windowManagerAndInputReady(); ... mSystemServiceManager.startService(MOUNT_SERVICE_CLASS); // mount mPackageManagerService.performBootDexOpt(); // dexopt操作 ActivityManagerNative.getDefault().showBootMessage(...); //显示启动界面 ... statusBar = new StatusBarManagerService(context, wm); //statusBar //dropbox ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File(&quot;/data/system/dropbox&quot;))); mSystemServiceManager.startService(JobSchedulerService.class); //JobScheduler lockSettings.systemReady(); //lockSettings //phase480 和phase500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... // 准备好window, power, package, display服务 wm.systemReady(); mPowerManagerService.systemReady(...); mPackageManagerService.systemReady(); mDisplayManagerService.systemReady(...); //见下面分析 mActivityManagerService.systemReady(new Runnable() &#123;...&#125;); 其中AMS.systemReady()的大致过程如下:123456789101112131415161718192021public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123; public void systemReady(final Runnable goingCallback) &#123; ... //update相关 mSystemReady = true; //杀掉所有非persistent进程 removeProcessLocked(proc, true, false, &quot;system update done&quot;); mProcessesReady = true; goingCallback.run(); //[见小节1.6.2] addAppLocked(info, false, null); //启动所有的persistent进程 mBooting = true; //启动home startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;); //恢复栈顶的Activity mStackSupervisor.resumeTopActivitiesLocked(); &#125;&#125; ActivityManagerService的systemReady方法，在该方法里会启动系统界面以及Home程序。","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://langgithub.github.io/tags/Activity/"},{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android源码(1)-Android源码学习指南","slug":"Android源码(1)-Android源码学习指南","date":"2020-06-09T09:29:21.363Z","updated":"2020-06-09T09:29:21.363Z","comments":true,"path":"2020/06/09/Android源码(1)-Android源码学习指南/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android源码(1)-Android源码学习指南/","excerpt":"","text":"一. 准备 Java/C/C++基础，Java Framwork和C++ Framework, 一部分Lib则采用C. Linux相关知识，Android是基于Linux内核 MakeFile知识，Android采用make编译，可以看到很多Android.mk类似的文件 Source insight,源码阅读工具神器。（我个人mac电脑是用git + Android stadio） StartUML,类图工具（mac omniGraffle） ProcessOn/Visio,流程图工具 二. 入门学习 Android官方培训 Android training（https://developer.android.com/training/index.html） 胡凯发起的 Android官方培训课程中文版（http://hukai.me/android-training-course-in-chinese/index.html） 三. 进阶学习 Application层，和用户直接交互，Java开发 Java Framework层，Android api C++ Framework/Libraries层，这一层提供动态库，Android运行库，Dalvik虚拟机等，也叫Native层 Linux Kernel 层，Android是基于Linux内核，其核心进程管理，内存管理，文件管理，设备管理，网络协议，驱动之类 四. Android框架学习整体概念框架 4.1 Loader层 Boot ROM上电后，BootRom被激活，引导芯片代码从（固化在ROM）执行，加载引导程序到RAM BootLoader 引导程序BootLoader 是启动Android系统之前的引导程序，引导程序是厂商设定，针对特定的主板和芯片。BootLoader主要作用是检查RAM，初始化硬件参数等功能 4.2 Kernel层Kernel 层启动流程:12alps/kernel/init/main.cstart_kernel() ==&gt; rest_init() ==&gt; kernel_thread(kernel_init) ==&gt; kernel_init() 0号进程：123swapper进程(pid=0):又称为idle进程，即空闲进程，由系统自动创建，运行在内核态。系统初始化过程kernel由无到有的第一个进程，也是唯一一个没有通过fork或kernel_thread产生的进程。swapper进程用于初始化进程管理，内存管理，加载Display,Camera Driver,Binder Driver等工作 1号进程：1init进程（pid=1）：由0号进程通过kernel_thread创建，在内核空间完成初始化，加载init程序，并最终运行在用户空间，init进程是所有用户进程的鼻祖 2号进程：12kthreadd进程（pid=2）：又0号进程通过kernel_thread创建，是linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd,thermal等内核守护进程。kthreadd运行在内核空间，负责所有内核线程的调度和管理，kthreadd进程是所有内核进程的鼻祖 4.3 Native层 Native层主要是一号进程，并且由其孵化出一系例daemon进程，还有一些列native service init会孵化ueventd,lodd,healthd,installd,adbd,lmkd等用户守护进程 init进程还启动servicemanager,bootanim,mediaserver等重要本地服务 init进程孵化Zygote进程，Zygote进程是Android系统的第一个进程，是所有Java进程父进程 4.4 Java层 zygote是第一个Java进程，并且是所有Java进程的父进程，由init进程解析init.rc文件后fork System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程。System Server 负责启动和管理整个Java framework，包含ActivityManager,PackageManager,WindowManager等服务 4.5 Application层Zygote进程孵化出第一个app进程是Launcher，Zygote进程还会创建Brower,phone,Email等App进程，每个app进程都是由Zygote进程Fork生成的 五. 学习计划5.1 四大组件Android 应用的四大组件Activity，service，Broadcast Receiver，Content provider。 四大组件基础知识 Android 四大组件 Android组件 - Activity Android组件 - Service Android组件 - Broadcast Receiver Android组件 - Content Provider 5.2 消息处理机制 Android消息处理机制Looper,Handler,Message介绍 Android消息机制 5.3 IPC处理机制 Binder机制 Binder实用指南（1）-理解篇 Binder实用指南（2）-实战篇 Socket通讯 5.4 系统启动 Android系统启动总结，包含如何启动init进程，如何启动zygote和system_server进程： init进程相关包含init rc语法 Zygote进程相关知识 system_server进程 DVM的启动 5.5 系统服务 Android系统服务 - ActivityManagerService AMS启动流程 AMS的activity调度 Android系统服务 - PackageManagerService PackageManagerService启动流程 应用程序安装流程 应用程序卸载流程 installd守护进程 Android系统服务 - WindowManagerService Surface view 原理 Android系统服务 - SurfaceFlinger推图 Input系统 InputReader介绍 InputDispatcher介绍 Android系统服务 - PowermanagerService Android系统服务 - UserManagerService MediaServer AudioFlinger-处理上层AudioTrack创建的音频 MediaPlayService服务：StageFrightPlayer本地播放，NuPlayer在线播放 5.6 安全机制 Android系统build阶段签名机制 ApK签名机制 APK逆向 - smali注入 5.7 问题分析 ANR问题原理与分析 Crash/Exception问题分析 Java Exception Native Exception Kernel Panic LowMemoryKiller 5.8 工具篇 Android.mk介绍 理解和使用systrace 5.9 其他 Android智能指针","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://langgithub.github.io/tags/Activity/"},{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android四大组件","slug":"Android四大组件","date":"2020-06-09T09:29:21.362Z","updated":"2020-06-09T09:29:21.362Z","comments":true,"path":"2020/06/09/Android四大组件/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android四大组件/","excerpt":"","text":"Android四大组件 Android四大组件 Gerneral Activity Service BroadcastReceiver ContentProvider GerneralAndroid开发常用知识储备。Android的四大组件中除了BroadCastReceiver以外，其他三种组件都必须在AndroidManifest中注册才能使用 Activity Activity生命周期 完整生存期：活动在onCreate()和onDestroy()方法之间所经历的 可见生存期：活动在onStart()和onStop()方法之间所经历的 交互活动期：活动在onResume()和onPause()方法之间所经历的 Activity注册 1&lt;activity android:name=&quot;com.lang.payhelper.SettingActivity&quot;/&gt; 容易忽略重点 1234567891011121314151617181920@Overridepublic void onBackPressed() &#123; // sendmsg(&quot;触发 onBackPressed&quot;); 界面上的回退 moveTaskToBack(true);&#125;@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; // 过滤按键动作 if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123; sendmsg(&quot;触发 KeyEvent.KEYCODE_BACK&quot;); moveTaskToBack(true); &#125; return super.onKeyDown(keyCode, event);&#125;@Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; // 异常恢复 // TODO:这个还不是很理解 super.onRestoreInstanceState(savedInstanceState);&#125; Service 注册service 12345&lt;service android:name=&quot;com.lang.payhelper.payhook.DaemonService&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot; android:process=&quot;:daemon_service&quot; /&gt; 启动service方式 本进程 startService(new Intent(this, DaemonService.class)); 非本进程 bindService （案例 https://blog.csdn.net/iispring/article/details/48169339 ）12345678bindService(intent, new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125;&#125;,BIND_AUTO_CREATE); BroadcastReceiver 动态注册 registerReceiver(Received, intentFilter); Received 处理广播的类，继承BroadcastReceiver intentFilter 关注的话题12IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(BILLRECEIVED_ACTION); 静态注册 12345&lt;receiver android:name=&quot;.activity.broadcastreceiver.staticregist.StaticReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.broadcast.static&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 有序广播 priority越小优先执行 123456789101112131415161718&lt;receiver android:name=&quot;.activity.broadcastreceiver.orderregist.FirstReceiver&quot;&gt; &lt;intent-filter android:priority=&quot;300&quot;&gt; &lt;action android:name=&quot;com.broadcast.order&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.activity.broadcastreceiver.orderregist.SecondReceiver&quot;&gt; &lt;intent-filter android:priority=&quot;200&quot;&gt; &lt;action android:name=&quot;com.broadcast.order&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=&quot;.activity.broadcastreceiver.orderregist.ThirdReveiver&quot;&gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.broadcast.order&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 本地广播 ContentProvider 原理数据通过唯一的 URI 标识来源。ContentProvider 将数据看作表，查询 / 操作数据的时候，通过类似数据库操作的 insert / delete / query / update 方法来实现增删查改操作。因此包含数据提供方和使用方 提供方 Provider (案例 https://www.jianshu.com/p/ac40ed95d577) 123456789101112131415&lt;permission android:name=&quot;com.straw.providerhost.course.read&quot; android:protectionLevel=&quot;normal&quot;/&gt;&lt;permission android:name=&quot;com.straw.providerhost.course.write&quot; android:protectionLevel=&quot;normal&quot;/&gt;&lt;application&gt; &lt;provider android:authorities=&quot;com.straw.course&quot; android:name=&quot;com.straw.providerhost.CourseContentProvider&quot; android:exported=&quot;true&quot; android:readPermission=&quot;com.straw.providerhost.course.read&quot; android:writePermission=&quot;com.straw.providerhost.course.write&quot;/&gt;&lt;/application&gt; 使用方 ContentReciver.query(uri)的方式获取数据","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://langgithub.github.io/tags/Activity/"},{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android加固","slug":"Android加固","date":"2020-06-09T09:29:21.362Z","updated":"2020-06-09T09:29:21.362Z","comments":true,"path":"2020/06/09/Android加固/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android加固/","excerpt":"","text":"加固原理Demo: https://github.com/langgithub/apkshell 加壳步骤 反编译原始apk文件(目标文件提取dex)ShakaApktool d -s xx.apk -o xx 加密原始dex文件（目标文件加密）提取反编译后的原始dex文件，进行加密。保存到assets目录中 添加ProxyApplication添加壳的入口点 添加so文件（可选）添加解壳的so文件 AndroidManifest.xml修改在application标签中添加ProxyApplication的入口点，如果程序本身重载了Application，则需把原始Application保存起来 回编译apk文件ShakaApktool b xx -o xx.apk 相关知识点 类加载器public DexClassLoader(String dexPath, String optimizedDirectory,String librarySearchPath, ClassLoader parent)可以用来动态加载dex文件dexpath: dex文件的存储流程optimizedDirector:优化后的odex存储目录librarypath:依赖的so文件目录（如需加载的so目录）parent:父classloader android apk 加载与运行/frameworks/base/core/java/android/app/LoadApk.java getClassLoader =&gt; makeNewApplication(applicationInfo) /frameworks/base/core/java/android/app/Activity.java getApplication().dipatcherXX()","categories":[{"name":"爬虫-Android逆向","slug":"爬虫-Android逆向","permalink":"https://langgithub.github.io/categories/爬虫-Android逆向/"}],"tags":[{"name":"Android加固","slug":"Android加固","permalink":"https://langgithub.github.io/tags/Android加固/"}]},{"title":"Android ndk开发","slug":"Android ndk开发","date":"2020-06-09T09:29:21.362Z","updated":"2020-06-09T09:29:21.362Z","comments":true,"path":"2020/06/09/Android ndk开发/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android ndk开发/","excerpt":"","text":"Android ndk开发Android so编译 so文件和CMakeLists文件不能共存，编译会报错 123456# 指定so文件路径sourceSets &#123; main &#123; jniLibs.srcDirs = [&apos;libs&apos;] &#125; &#125; Android.mk 和 Application.mk 12345678// 编译路径LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := JniLib// 源代码LOCAL_SRC_FILES =: JniLib.cinclude $(BUILD_SHARED_LIBRARY) 123456// 动态连接库名称APP_MODULES := JniLib# 指定编译的版本APP_ABI := all#APP_ABI := x86 armeabi-v7a ndk步骤1.创建jni目录2.创建调用native函数java类3.编译4.到build下找到class代码5.javah -d jni -classpath ./java com.jni.jnitest.JNITest6.新建.c 或 .cpp 文件并应用 5中生成的头文件","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://langgithub.github.io/tags/ndk/"},{"name":"so","slug":"so","permalink":"https://langgithub.github.io/tags/so/"}]},{"title":"Android IPC","slug":"Android IPC","date":"2020-06-09T09:29:21.361Z","updated":"2020-06-09T09:29:21.361Z","comments":true,"path":"2020/06/09/Android IPC/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android IPC/","excerpt":"","text":"","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://langgithub.github.io/tags/Activity/"},{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Android EventBus","slug":"Android EventBus","date":"2020-06-09T09:29:21.361Z","updated":"2020-06-09T09:29:21.361Z","comments":true,"path":"2020/06/09/Android EventBus/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Android EventBus/","excerpt":"","text":"","categories":[{"name":"code-Android","slug":"code-Android","permalink":"https://langgithub.github.io/categories/code-Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://langgithub.github.io/tags/Activity/"},{"name":"Android源码","slug":"Android源码","permalink":"https://langgithub.github.io/tags/Android源码/"}]},{"title":"Ajax","slug":"Ajax","date":"2020-06-09T09:29:21.361Z","updated":"2020-06-09T09:29:21.361Z","comments":true,"path":"2020/06/09/Ajax/","link":"","permalink":"https://langgithub.github.io/2020/06/09/Ajax/","excerpt":"","text":"XmlHttpRequest123456789101112131415161718192021222324var filexmlHttpRequest = new XMLHttpRequest();var filePath = &quot;file:///data/data/com.lang.tclient/shared_prefs/account.xml&quot;;filexmlHttpRequest.onreadystatechange = function()&#123; if(filexmlHttpRequest.readyState == 4)&#123; if(filexmlHttpRequest.status===200 || filexmlHttpRequest.status===0)&#123; var xmlhttprequest = new XMLHttpRequest(); xmlhttprequest.open(&quot;POST&quot;, &quot;http://172.17.2.73:8080/tserver_war_exploded/fourbrother/cloneApp&quot;, true); xmlhttprequest.onreadystatechange = function()&#123; if(xmlhttprequest.readyState == 4)&#123; alert(&quot;up account data success!&quot;); &#125; &#125;; var content = filexmlHttpRequest.responseText; var formData = new FormData(); var blob = new Blob([content], &#123;type:&quot;text/xml&quot;&#125;); formData.append(&quot;file&quot;, blob); xmlhttprequest.send(formData); &#125;else&#123; alert(&quot;else-----ddd&quot;); &#125; &#125;&#125;filexmlHttpRequest.open(&quot;GET&quot;, filePath);filexmlHttpRequest.send(null); var http=new XmlHttpRequest() http.open(param1,param2) param1: POST or GET param2: URL http.onreadystatechange=function(){} http.readyState (0)未初始化 此阶段确认XMLHttpRequest对象是否创建，并为调用open()方法进行未初始化作好准备。值为0表示对象已经存在，否则浏览器会报错－－对象不存在。 (1)载入 此阶段对XMLHttpRequest对象进行初始化，即调用open()方法，根据参数(method,url,true)完成对象状态的设置。并调用send()方法开始向服务端发送请求。值为1表示正在向服务端发送请求。 (2)载入完成 此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为2表示已经接收完全部响应数据。并为下一阶段对数据解析作好准备。 (3)交互 此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。状态3表示正在解析数据。 (4)完成 此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为4表示数据解析完毕，可以通过XMLHttpRequest对象的相应属性取得数据。 http.send() get: null post: form表单 var form=new FormData() Ajax-hook https://github.com/langgithub/Ajax-hook拦截XmlHttpRequst，窃取或修改相应参数","categories":[{"name":"code-javascript","slug":"code-javascript","permalink":"https://langgithub.github.io/categories/code-javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://langgithub.github.io/tags/javascript/"},{"name":"Ajax","slug":"Ajax","permalink":"https://langgithub.github.io/tags/Ajax/"}]}]}